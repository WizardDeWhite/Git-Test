1. Normal API, Can't store reserved value.
================================================================================

1.1. DEFINE_MTREE() / mt_init()
================================================================================

1.2. mtree_store()/mtree_store_range(), would overwrite if exist
================================================================================

1.3. mtree_insert(), not overwrite if already exist
================================================================================
1.3.1 mas_insert()
================================================================================
1.3.1.1 mas_start()
================================================================================
1.3.1.2 mas_store_root(mas, entry)
================================================================================
1.3.1.2.1 mas_root_expand()
================================================================================
1.3.1.3 mas_wr_walk() 
================================================================================
1.3.1.4 mas_wr_modify()
================================================================================

1.4. mtree_erase()
================================================================================

1.5. mtree_load()
================================================================================

1.6. mt_find()
================================================================================

1.5. mt_for_each()
================================================================================

2. Advanced, Reserved value can be stored.
================================================================================

2.1 mas_wr_bnode()
================================================================================
2.1.0 mas_store_b_node()
================================================================================
2.1.0.1 mas_mab_cp()
================================================================================
2.1.1 mas_commit_b_node()
================================================================================

0. data struct
================================================================================
Testing:
userspace:    tools/testing/radix-tree/maple.c
kernel space: lib/test_maple_tree.c

History:

commit 54a611b605901c7d5d05b6b8f5d04a6ceb0962aa
Author: Liam R. Howlett <Liam.Howlett@Oracle.com>
Date:   Tue Sep 6 19:48:39 2022 +0000

    Maple Tree: add new data structure
    
    Patch series "Introducing the Maple Tree"

Document: Documentation/core-api/maple_tree.rst
Blog: https://blogs.oracle.com/linux/the-maple-tree

0.0 B-Tree
================================================================================

0.0.1 property
================================================================================
 1. 平衡: 所有叶子节点都在同一层
 2. 有序: 节点内元素和各子树间有序
 3. 多路: m阶，最多:有m个分支，m-1个元素；
              最少: 根节点有1个元素，其他节点(m/2 - 1) 个元素. m/2上取整

0.0.2 insertion
================================================================================
 1. 插入都在叶子节点
 2. 如果元素个数没有超过最大个数m-1，则完成
 3. 如果元素个数超过了m-1，则将第m/2个元素上移到父节点。原节点两边作为上移节点的子树
 4. 再回到第二步，查看父节点是否上溢出

0.0.3 deletion
================================================================================
 1. 如果是叶子节点则直接删除。如果不是叶子节点则找到后继/前驱，替换后删除。
 2. 删除后如果没有下溢出（小于 (m/2- 1) 个元素），结束
 3. 如果发生下溢出：
    如果兄弟够借，父下兄上。同时带上原来的子树一起移动。
    如果兄弟不够，挑一个兄弟合并。把父节点下移，再把兄弟合并过来。此时需要再判断父节点是否有下溢出

0.1 maple_tree
================================================================================
Currently there are two types of tree:

  * normal tree
  * allocation tree, allow user to search for a gap


    maple_tree
    +--------------------------------------------+
    |ma_lock                                     |
    |    (struct spinlock_t)                     |
    |ma_flags                                    |
    |    (unsigned int)                          |
    |                                            |
    |ma_root                                     |
    |    (void *)                                |
    +--------------------------------------------+

0.1.1 ma_flags, with height encoded
================================================================================

                              6            1  0
 +----------------------------+------------+--+--+
 |                            |   height   |r |a |
 +----------------------------+------------+--+--+

 bit 2-6 for height, max 2^5-1 = 31

0.2 maple_node
================================================================================

xarray operation:
  xa_is_internal(): entry & 3 == 2
  xa_mk_internal(): (v << 2) | 2 
  xa_to_internal(): v >> 2

  mt_is_reserved(): is_internal() && (v < 4096)

  xa_is_node(): is_internal() && (v > 4096)
  xa_mk_node(): v | 2
  xa_to_node(): v - 2

  xa_is_value(): (v & 1)
  xa_mk_value(): (v << 1) | 1
  xa_to_value(): v >> 1

maple tree operation:
  mt_mk_node(): encode maple_type, node | (type << MAPLE_ENODE_TYPE_SHIFT),
	        but bit 1 is 0
  mte_to_node(): clear low 8 bits, entry & ~MAPLE_NODE_MASK

  mte_mk_root(): make an enode to root node, by set bit 1
  mte_safe_root(): convert root node to enode, by clearing bit 1
  
    maple_node (1 + 31) * 8 = 256 byte
    +--------------------------------------------+
    |parent                                      |
    |    (struct maple_pnode*)                   |
    |slot[MAPLE_NODE_SLOTS]                      | 31
    |    (void *)                                |
    +============================================+
    |mr64                                        |
    |    (struct maple_range_64)                 |
    +============================================+
    |ma64                                        |
    |    (struct maple_arange_64)                |
    +============================================+
    |alloc                                       |
    |    (struct maple_alloc)                    |
    +============================================+
    |pad                                         |
    |    (void *)                                |
    |rcu                                         |
    |    (struct rcu_head)                       |
    |piv_parent                                  |
    |    (struct maple_enode*)                   |
    |parent_slot                                 |
    |    (unsigned char)                         |
    |type                                        |
    |    (enum maple_type)                       |
    |slot_len                                    |
    |    (unsigned char)                         |
    |ma_flags                                    |
    |    (unsigned int)                          |
    +--------------------------------------------+

0.2.0 enum maple_type
================================================================================
	maple_dense,
	maple_leaf_64,
	maple_range_64,
	maple_arange_64,

mte_node_type() 由entry的bit 3-6决定. see comment of maple_range_64 and MAPLE_PARENT_ROOT.
有一个前提条件：Non-leaf node大小是256B对齐的，所以低8位可以利用。

0.2.0.1 mt_slots[]/mt_pivots[]/mt_min_slots[]
================================================================================

0.2.1 maple_pnode, a pseudo struct only used as pointer
================================================================================

0.2.2 maple_enode, maple encoded node
================================================================================

0.2.3 maple_range_64
================================================================================

    maple_range_64 (1 + 15 + 16) * 8 = 256 byte
    +--------------------------------------------+
    |parent                                      |
    |    (struct maple_pnode*)                   |
    |pivot[MAPLE_RANGE64_SLOTS - 1]              | 15
    |slot[MAPLE_RANGE64_SLOTS]                   | 16
    |    (void *)                                |
    |                                            |
    |                                            |
    +--------------------------------------------+

0.2.3.1 slot/pivot represent
================================================================================

 S: slot
 P: pivot (P0 < P1 < P2 ...)


 +------+......+------+......+------+
 |  S0  |  P0  |  S1  |  P1  |  S2  |
 +------+......+------+......+------+

 [min, P0]     [P0+1, P1]    [P1+1, max]


0.2.4 maple_arange_64
================================================================================

    maple_arange_64 (1 + 9 + 10 + 10 + 1) * 8 = 248 byte
    +--------------------------------------------+
    |parent                                      |
    |    (struct maple_pnode*)                   |
    |pivot[MAPLE_ARANGE64_SLOTS - 1]             | 9
    |    (unsigned long)                         |
    |slot[MAPLE_ARANGE64_SLOTS]                  | 10
    |    (void *)                                |
    |gap[MAPLE_ARANGE64_SLOTS]                   | 10
    |    (unsigned long)                         |
    |meta                                        |
    |    (struct maple_metadata)                 |
    |    +---------------------------------------+
    |    |end                                    | zero indexed last slot
    |    |gap                                    | offset of the highest sub-gap in this node
    |    |    (unsigned char)                    |
    +----+---------------------------------------+

0.2.5 maple_alloc
================================================================================

    maple_alloc (1 + 1 + 30) * 8 = 256 byte
    +--------------------------------------------+
    |total                                       |
    |    (unsigned long)                         |
    |node_count                                  |
    |    (unsigned char)                         |
    |request_count                               |
    |    (unsigned int)                          |
    |slot[MAPLE_ALLOC_SLOTS]                     | 30
    |    (struct maple_alloc*)                   |
    +--------------------------------------------+

0.2.6 maple_big_node
================================================================================

    maple_big_node
    +--------------------------------------------+
    |parent                                      |
    |    (struct maple_pnode*)                   |
    |pivot[MAPLE_BIG_NODE_SLOTS - 1]             |
    |slot[MAPLE_BIG_NODE_SLOTS]                  | = MAPLE_RANGE64_SLOTS * 2 + 2 = 16 * 2 + 2
    |    (void *)                                |
    |                                            |
    |b_end                                       |
    |    (unsigned char)                         |
    |type                                        |
    |    (enum maple_type)                       |
    +--------------------------------------------+

0.3 ma_state
================================================================================
Define: MA_STATE()
Set up: mas_start() when mas->status == mas_start

    ma_state
    +--------------------------------------------+
    |tree                                        | set to tree
    |    (struct maple_tree*)                    |
    |index                                       | specify range [index, last]
    |last                                        |
    |    (unsigned long)                         |
    |node                                        | encoded node in interest
    |    (struct maple_enode*)                   |
    |min                                         | default [0, ULONG_MAX]
    |max                                         | [r_min, r_max] during mas_wr_walk_traverse
    |    (unsigned long)                         | which is the range of mas->node
    |status                                      | default ma_start
    |    (enum maple_status)                     |
    |depth                                       |
    |offset                                      | in slot/pivot
    |mas_flags                                   |
    |end                                         | the end of data in node, get from ma_data_end()
    |    (unsigned char)                         |
    |                                            |
    |alloc                                       | bit 0 set: requested nodes
    |    (struct maple_alloc*)                   | bit 0 clear: maple_alloc structure
    |    +---------------------------------------+
    |    |total                                  | allocated number
    |    |request_count                          | requested number
    |    |node_count                             |
    |    |slot[MAPLE_ALLOC_SLOTS]                |
    |    |                                       |
    +----+---------------------------------------+

0.4 ma_wr_state
================================================================================
Define: MA_WR_STATE()

    ma_wr_state
    +--------------------------------------------+
    |mas                                         |
    |    (struct ma_state*)                      |
    |node                                        | decoded mas->node
    |    (struct maple_node*)                    |
    |type                                        | mas->node's type
    |    (enum maple_type)                       |
    |pivots                                      | mas->node->pivots
    |    (unsigned long*)                        |
    |slots                                       | mas->node->slots
    |    (void *)                                |
    |r_min/r_max                                 | range min/max at offset
    |    (unsigned long)                         |
    |offset_end                                  | the offset where mas->last
    |    (unsigned char)                         |
    |end_piv                                     | pivots[offset_end], set in mas_wr_end_piv()
    |    (unsigned long)                         |
    |                                            |
    |entry                                       | the new entry to be stored
    |content                                     | existing entry to be overwritten
    |    (void*)                                 |
    |                                            |
    +--------------------------------------------+

0.5 maple_status
================================================================================

	ma_active
	ma_start
	ma_root
	ma_none
	ma_pause
	ma_overflow
	ma_underflow
	ma_error

0.10 mas_wr_walk()
================================================================================

 mas->node
 +------+......+------+......+------+......+------+......+------+
 |  S0  |  P0  |  S1  |  P1  |  S2  |  P2  |  S3  |  P3  |  S4  |
 +------+......+------+......+------+......+------+......+------+
 [mas->min,                                             mas->max]
               [r_min, r_max]           [, end_piv]
	       [index,                        last]

                   ^                           ^
                   |                           |
                offset                    offset_end

  means:

  P0+1 <= mas->index <= P1
  P2+1 <= mas->last  <= P3
  P2+1 <= wr_mas->end_piv  <= P3

0.10 Cases for mas_wr_node_store()
================================================================================

0.10.1 offset == offset_end
================================================================================

Before:

    +------+......+------+......+------+
    |  S0  |  P0  |  S1  |  P1  |  S2  |
    +------+......+------+......+------+

                      ^
                      |
                   offset

  [r_min, r_max] = [P0+1, P1]
  end_piv = P1
  P0+1 <= mas->index <= P1
  P0+1 <= mas->last  <= P1

0.10.1.0 index == r_min && last == r_max
================================================================================

After:

    +------+......+------+......+------+
    |  S0  |  P0  | entry|  P1  |  S2  |
    +------+......+------+......+------+
                  |      |
                  |      |
		  direct replace

 new_end = end

0.10.1.1 index != r_min && last != r_max
================================================================================

After:

    +------+......+------+......+------+......+------+......+------+
    |  S0  |  P0  |  S1  | idx-1| entry| last |  S1  |  P1  |  S2  |
    +------+......+------+......+------+......+------+......+------+
    |             |                           |                    |
    |<- copied  ->|<---    modified       --->|<---    copied  --->|

 new_end = end + 2

0.10.1.2 index == r_min && last != r_max
================================================================================

After:
           P0 == index
    +------+......+------+......+------+......+------+
    |  S0  |  P0  | entry| last |  S1  |  P1  |  S2  |
    +------+......+------+......+------+......+------+
    |             |             |                    |
    |<- copied  ->|<-modified ->|<---    copied  --->|

 new_end = end + 1

0.10.1.3 index != r_min && last == r_max
================================================================================

After:
                                        P1 == last
    +------+......+------+......+------+......+------+
    |  S0  |  P0  |  S1  | idx-1| entry|  P1  |  S2  |
    +------+......+------+......+------+......+------+
    |             |                           |      |
    |<- copied  ->|<---     modified      --->|< cp >|

 new_end = end + 1

0.10.2 offset < offset_end
================================================================================

Before:

    +------+......+------+......+       +------+......+------+
    |  S0  |  P0  |  S1  |  P1  |  xxx  |  Se  |  Pe  |  Sx  |
    +------+......+------+......+       +------+......+------+

                      ^                    ^
                      |                    |
                   offset               offset_end

  [r_min, r_max] = [P0+1, P1]
  end_piv = Pe
  P0+1 <= mas->index <= P1
  P(e-1)+1 <= mas->last  <= Pe

0.10.2.0 index == r_min && last == end_piv
================================================================================

After:

    +------+......+------+......+------+
    |  S0  |  P0  | entry|  Pe  |  Sx  |
    +------+......+------+......+------+
    |             |             |      |
    |<- copied  ->|<- modified >|< cp >|

 new_end = end - (offset_end - offset)

0.10.2.1 index != r_min && last != end_piv
================================================================================

After:

    +------+......+------+......+------+......+------+......+------+
    |  S0  |  P0  |  S1  | idx-1| entry| last |  Se  |  Pe  |  Sx  |
    +------+......+------+......+------+......+------+......+------+
    |             |                           |                    |
    |<- copied  ->|<---    modified       --->|<---    copied  --->|

 new_end = end + 2 - (offset_end - offset)

0.10.2.2 index == r_min && last != end_piv
================================================================================

After:
           P0 == index
    +------+......+------+......+------+......+------+
    |  S0  |  P0  | entry| last |  Se  |  Pe  |  Sx  |
    +------+......+------+......+------+......+------+
    |             |             |                    |
    |<- copied  ->|<-modified ->|<---    copied  --->|

 new_end = end + 1 - (offset_end - offset)

0.10.2.3 index |= r_min && last == end_piv
================================================================================

After:

    +------+......+------+......+------+......+------+
    |  S0  |  P0  |  S1  | idx-1| entry| last |  Sx  |
    +------+......+------+......+------+......+------+
    |             |                           |      |
    |<- copied  ->|<---     modified      --->|< cp >|

 new_end = end + 1 - (offset_end - offset)

0.11 Cases for mas_store_b_node()
================================================================================

copy to maple_big_node with new range and data

0.11.1 offset == offset_end
================================================================================

Before:

    maple_node
    +------+......+------+......+------+......+------+
    |  S0  |  P0  |  S1  |  P1  |  S2  |  P2  |  S3  |
    +------+......+------+......+------+......+------+

                      ^
                      |
                   offset

0.11.1.1 index != r_min && last != r_max
================================================================================

After:
    maple_big_node
    +------+......+------+......+------+......+------+......+------+......+------+......+
    |  S0  |  P0  |  S1  | idx-1| entry| last |  S1  |  P1  |  S2  |  P2  |  S3  |  max |
    +------+......+------+......+------+......+------+......+------+......+------+......+
    |             |                                         |             |             |
    |<-mas_mab_cp>|<---           modified              --->|<-mas_mab_cp>|             |
                                                            |                           |
                                                            |<---     mas_mab_cp    --->|

The second mas_mab_cp()'s behavior is very interesting.

According to current design, P2 may have two posibility:

  * P2 == max
  * P2 != max

If P2 == max, this means S3 is nil and doesn't means anything.
If P2 != max, this means S3 do represent the value in range [P2 + 1, max]. And
current implementation would append a max after S3 during mas_mab_cp(). 

0.11.1.2 index == r_min && last != r_max
================================================================================

After:
    maple_big_node
    +------+......+------+......+------+......+------+......+------+......+
    |  S0  |  P0  | entry| last |  S1  |  P1  |  S2  |  P2  |  S3  |  max |
    +------+......+------+......+------+......+------+......+------+......+
    |             |                           |             |             |
    |<-mas_mab_cp>|<---    modified       --->|<-mas_mab_cp>|             |
                                              |                           |
                                              |<---     mas_mab_cp    --->|

0.11.1.3 index != r_min && last == r_max
================================================================================

After:
    maple_big_node
    +------+......+------+......+------+......+------+......+------+......+
    |  S0  |  P0  |  S1  | idx-1| entry| last |  S2  |  P2  |  S3  |  max |
    +------+......+------+......+------+......+------+......+------+......+
    |             |                           |             |             |
    |<-mas_mab_cp>|<---    modified       --->|<-mas_mab_cp>|             |
                                              |                           |
                                              |<---     mas_mab_cp    --->|

0.11.2 offset != offset_end
================================================================================

Before:

    maple_node
    +------+......+------+......+------+......+------+
    |  S0  |  P0  |  S1  |  P1  |  S2  |  P2  |  S3  |
    +------+......+------+......+------+......+------+

                      ^            ^
                      |            |
                   offset       offset_end

0.11.2.1 index != r_min && last != r_max
================================================================================

After:
    maple_big_node
    +------+......+------+......+------+......+------+......+------+......+
    |  S0  |  P0  |  S1  | idx-1| entry| last |  S2  |  P2  |  S3  |  max |
    +------+......+------+......+------+......+------+......+------+......+
    |             |                                         |             |
    |<-mas_mab_cp>|<---           modified              --->|<-mas_mab_cp>|
