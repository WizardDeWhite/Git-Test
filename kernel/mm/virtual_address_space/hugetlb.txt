1. hugetlb_init, subsys_initcall()
================================================================================
1.1 hugepages_supported() -> boot_cpu_has(X86_FEATURE_PSE)
================================================================================
1.2 hugetlb_add_hstate(HUGETLB_PAGE_ORDER), add the default(?) hstate
================================================================================
1.3 hugetlb_cma_check()
================================================================================
1.4 hugetlb_init_hstates()
================================================================================
1.4.1 hugetlb_hstate_alloc_pages(), alloc page to max_huge_pages
================================================================================
1.4.1.1 alloc_pool_huge_page(h, &node_states[N_MEMORY], node_alloc_noretry)
================================================================================
1.5 gather_bootmem_prealloc(), prepare hugepage at boot stage
================================================================================
1.6 report_hugepages()
================================================================================
1.7 hugetlb_sysfs_init()
================================================================================
1.7.1 hugepages_kobj = kobject_create_and_add("hugepages", mm_kobj);
================================================================================
1.7.2 err = hugetlb_sysfs_add_hstate(h, hugepages_kobj, hstate_kobjs, &hstate_attr_group);
================================================================================
1.7.2.1 hstate_kobjs[hi] = kobject_create_and_add(h->name, hugepages_kobj)
================================================================================
1.7.2.2 retval = sysfs_create_group(hstate_kobjs[hi], hstate_attr_group);
================================================================================
1.8 hugetlb_register_all_nodes()
================================================================================
1.9 hugetlb_cgroup_file_init()
================================================================================
1.10 hugetlb_fault_mutex_table = kmalloc_array()
================================================================================
1.11 mutex_init(hugetlb_fault_mutex_table[i])
================================================================================

2. alloc_pool_huge_page(h, nodes_allowed, node_alloc_noretry)
================================================================================
2.0 for_each_node_mask_to_alloc(), get the proper node to alloc
================================================================================
2.0.1 node = hstate_next_node_to_alloc(hs, mask)
================================================================================
2.0.1.1 nid = get_valid_node_allowed(h->next_nid_to_alloc, nodes_allowed);
================================================================================
2.0.1.2 h->next_nid_to_alloc = next_node_allowed(nid, nodes_allowed);
================================================================================
2.1 alloc_fresh_huge_page(h, gfp_mask, node, nodes_allowed, node_alloc_noretry)
================================================================================
2.1.0 alloc_gigantic_page()
================================================================================
2.1.1 alloc_buddy_huge_page()
================================================================================
2.1.1.1 order = huge_page_order(h)
================================================================================
2.1.1.2 __alloc_pages_nodemask(gfp_mask, order, nid, nmask)
================================================================================
2.1.2 prep_new_huge_page(h, page, page_to_nid(page))
================================================================================
2.1.2.1 set_compound_page_dtor(page, HUGETLB_PAGE_DTOR);
================================================================================
2.1.2.2 h->nr_huge_pages++;
================================================================================
2.1.2.3 h->nr_huge_pages_node[nid]++;
================================================================================
2.2 put_page(page) -> __put_page(page) -> __put_compound_page(page);
================================================================================
2.2.1 free_huge_page() -> __free_huge_page()
================================================================================
2.2.1.1 h = page_hstate(page)
================================================================================
2.2.1.2 spool = page_private(page)
================================================================================
2.2.1.3 clear_page_huge_active(page)
================================================================================
2.2.1.4 update_and_free_page(page), return to buddy
================================================================================
2.2.1.5 enqueue_huge_page(h, page), link to freelist
================================================================================

3. free_pool_huge_page(h, nodes_allowed, 0)
================================================================================
3.1 update_and_free_page(h, page)
================================================================================
3.1.1 h->nr_huge_pages--;
================================================================================
3.1.2 h->nr_huge_pages_node[page_to_nid(page)]--;
================================================================================
3.1.3 reset page->flags
================================================================================
3.1.3 set_compound_page_dtor(page, NULL_COMPOUND_DTOR);
================================================================================
3.1.4 set_page_refcounted(page);
================================================================================
3.1.5 __free_pages(page, huge_page_order(h)), return to buddy
================================================================================

4. mmap -> ksys_mmap_pgoff()
================================================================================

const struct file_operations hugetlbfs_file_operations = {
	.read_iter		= hugetlbfs_read_iter,
	.mmap			= hugetlbfs_file_mmap,
	.fsync			= noop_fsync,
	.get_unmapped_area	= hugetlb_get_unmapped_area,
	.llseek			= default_llseek,
	.fallocate		= hugetlbfs_fallocate,
};

const struct vm_operations_struct hugetlb_vm_ops = {
	.fault = hugetlb_vm_op_fault,
	.open = hugetlb_vm_op_open,
	.close = hugetlb_vm_op_close,
	.split = hugetlb_vm_op_split,
	.pagesize = hugetlb_vm_op_pagesize,
};


    mmap()
        file->f_op->mmap(file, vma) -> hugetlbfs_file_mmap()
            vma->vm_flags |= VM_HUGETLB | VM_DONTEXPAND;
            vma->vm_ops = &hugetlb_vm_ops

4.1 flags & MAP_HUGETLB
================================================================================
4.2 hs = hstate_sizelog((flags >> MAP_HUGE_SHIFT) & MAP_HUGE_MASK), may get default_hstate
================================================================================
4.3 len = ALIGN(len, huge_page_size(hs))
================================================================================
4.4 file = hugetlb_file_setup(HUGETLB_ANON_FILE, len, ), prepare the backend file
================================================================================
4.4.1 mnt = hugetlbfs_vfsmount[hstate_idx]
================================================================================
4.4.2 inode = hugetlbfs_get_inode(mnt->mnt_sb, NULL, )
================================================================================
4.4.3 inode->i_size = size
================================================================================
4.4.4 hugetlb_reserve_pages(inode, 0, size >> huge_page_shift())
================================================================================
4.4.5 file = alloc_file_pseudo(inode, mnt, name, &hugetlbfs_file_operations)
================================================================================
4.4.6 return file
================================================================================
4.5 vm_mmap_pgoff(file, addr, len, prot, flags, pgoff) -> do_mmap_pgoff -> do_mmap -> mmap_region
================================================================================
4.5.1 vma->vm_file = get_file(file)
================================================================================
4.5.2 call_mmap(file, vma) -> file->f_op->mmap() -> hugetlbfs_file_mmap()
================================================================================
4.5.2.1 vma->vm_flags |= VM_HUGETLB | VM_DONTEXPAND
================================================================================
4.5.2.2 vma->vm_ops = &hugetlb_vm_ops
================================================================================

6. hugetlb_reserve_pages(inode, from, to, vma, vm_flags)
================================================================================
6.1 h = hstate_inode(inode)
================================================================================
6.1.1 return HUGETLBFS_SB(i->i_sb)->hstate;
================================================================================
6.2 spool = subpool_inode(inode)
================================================================================
6.2.1 return HUGETLBFS_SB(inode->i_sb)->spool;
================================================================================
6.3 return 0, if (vm_flags & VM_NORESERVE), only reserve if asked
================================================================================
6.4 resv_map = inode_resv_map(inode)
================================================================================
6.5 chg = region_chg(resv_map, from, to, &regions_needed), prepare file_region in resv_map
================================================================================
6.5.1 add_reservation_in_range(resv, f, t, NULL, NULL, out_regions_needed, true)
================================================================================
6.5.1.1 nrg = get_file_region_entry_from_cache(), get one file_region from cache
================================================================================
6.5.1.2 list_add(nrg->link, rg->link.prev)
================================================================================
6.5.1.3 coalesce_file_region(resv, nrg)
================================================================================
6.5.2 allocate_file_region_entries(resv, out_regions_needed), prepare region_cache
================================================================================
6.1 resv_map = resv_map_alloc()
================================================================================
6.2 set_vma_resv_map(vma, resv_map), save to vma->private_data
================================================================================
6.3 set_vma_resv_flags(vma, HPAGE_RESV_OWNER)
================================================================================
6.4 gbl_reserve = hugepage_subpool_get_pages(spool, chg), # to reserve
================================================================================
6.5 hugetlb_acct_memory(h, gbl_reserve)
================================================================================
6.5.1 gather_surplus_pages(h, gbl_reserve)
================================================================================
6.5.1.1 alloc_surplus_huge_page(h, htlb_alloc_mask(h)) -> alloc_fresh_huge_page
================================================================================
6.5.2 return_unused_surplus_pages(h, gbl_reserve)
================================================================================
6.5.2.1 free_pool_huge_page(h, &node_state[N_MEMORY], 1)
================================================================================
6.6 region_add(resv_map, from, to, regions_needed, h, h_cg), add file_region to resv_map
================================================================================

7. hugetlb_fault(), invoked by handle_mm_fault()
================================================================================
7.0 h = hstate_vma(vma), vma -> file -> inode -> sb -> hstate
================================================================================
7.1 haddr = address & huge_page_mask(h)
================================================================================
7.2 ptep = huge_pte_offset(mm, haddr, huge_page_size())
================================================================================
7.3 handle migration and hwpoison, if (ptep)
================================================================================
7.4 ptep = huge_pte_alloc(mm, haddr, huge_page_size(h))
================================================================================
7.5 idx = vma_hugecache_offset(h, vma, haddr), index within mapping
================================================================================
7.6 hash = hugetlb_fault_mutex_hash(mapping, idx), idx to hash
================================================================================
7.7 hugetlb_no_page(mm, vma, mapping, idx, address, ptep, flags)
================================================================================
7.7.1 find_lock_page(mapping, idx)
================================================================================
7.7.2 alloc_huge_page(vma, haddr, 0)
================================================================================
7.7.3 clear_huge_page(page, address, pages_per_huge_page(h))
================================================================================
7.7.3.1 process_huge_page(, pages_per_huge_page, clear_subpage), clear page before use
================================================================================
7.7.4 new_pte = make_huge_pte()
================================================================================
7.7.5 set_huge_pte_at(mm, haddr, ptep, new_pte)
================================================================================
7.8 hugetlb_cow()
================================================================================

8. alloc_huge_page(vma, addr, avoid_reserve), consider whether consume reserve page
================================================================================
8.1 spool = spool_vma(vma)
================================================================================
8.2 h = hstate_vma(vma)
================================================================================
8.3 idx = hstate_index(h)
================================================================================
8.4 map_chg = gbl_chg = vma_needs_reservation(h, vma, addr)
================================================================================
8.4.1 return __vma_reservation_common(h, vma, addr, VMA_NEEDS_RESV)
================================================================================
8.4.1.1 ret = region_chg(resv, idx, idx+1, &dummy_out_regions_needed)
================================================================================
8.3 page = dequeue_huge_page_vma(h, vma, addr, avoid_reserv, gbl_chg)
================================================================================
8.3.1 vma_has_reserves(vma, gbl_chg)
================================================================================
8.3.2 page = dequeue_huge_page_nodemask(h, gfp_mask, nid, nodemask);
================================================================================
8.3.2.1 zonelist = node_zonelist(nid, gfp_mask);
================================================================================
8.3.2.2 page = dequeue_huge_page_node_exact(h, node)
================================================================================
8.4 map_commit = vma_commit_reservation(h, vma, addr)
================================================================================
8.4.1 return __vma_reservation_common(h, vma, addr, VMA_COMMIT_RESV);
================================================================================
8.4.1.1 ret = region_add(resv, idx, idx + 1, 1, NULL, NULL);
================================================================================


9. resv_map's file_region operations
================================================================================
9.1 region_add(), add a region
================================================================================
9.2 region_chg(), return number of huge pages are not represented
================================================================================
9.3 region_del()
================================================================================
9.4 region_abort(), decrease resv->adds_in_progress
================================================================================

10. nr_hugepages_store_common() -> __nr_hugepages_store_common()
================================================================================
10.1 set_max_huge_pages(h, count, nid, n_mask)
================================================================================
10.1.1 NODEMASK_ALLOC(nodemask_t, node_alloc_noretry, GFP_KERNEL);
================================================================================
10.1.2 nodes_clear(*node_alloc_noretry);
================================================================================
10.1.3 adjust_pool_surplus(h, nodes_allowed, -1)
================================================================================
10.1.4 alloc_pool_huge_page(h, nodes_allowed, ), alloc from buddy
================================================================================
10.1.5 try_to_free_low(h, min_count, nodes_allowed)
================================================================================
10.1.6 free_pool_huge_page(h, nodes_allowed, 0), return to buddy
================================================================================

11. init_hugetlbfs_fs(), fs_initcall()
================================================================================
11.1 hugetlbfs_inode_cachep = kmem_cache_create("hugetlbfs_inode_cache",)
================================================================================
11.2 register_filesystem(&hugetlbfs_fs_type)
================================================================================
11.3 mount_one_hugetlbfs(&hstates[default_hstate_idx])
================================================================================
11.3.1 fc = fs_context_for_mount(&hugetlbfs_fs_type, SB_KERNMOUNT) -> alloc_fs_context
================================================================================
11.3.1.1 init_fs_context = fc->fs_type->init_fs_context; = hugetlbfs_init_fs_context
================================================================================
11.3.1.2 init_fs_context(fc) -> hugetlbfs_init_fs_context()
================================================================================
11.3.1.2.1 ctx = kzalloc()
================================================================================
11.3.1.2.2 ctx->max_hpages = -1
================================================================================
11.3.1.2.3 ctx->min_hpages = -1
================================================================================
11.3.1.2.4 fc->fs_private = ctx
================================================================================
11.3.1.2.5 fc->ops = &hugetlbfs_fs_context_ops
================================================================================
11.3.2 mnt = fc_mount(fc) ->  vfs_get_tree()
================================================================================
11.3.2.1 fc->ops->get_tree() -> hugetlbfs_get_tree() -> hugetlbfs_fill_super
================================================================================

0. data struct
================================================================================

0.0 usage
================================================================================

[root@debug010000002015 ~]# tail /proc/meminfo
CmaFree:               0 kB
HugePages_Total:       0
HugePages_Free:        0
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       2048 kB
Hugetlb:               0 kB
[root@debug010000002015 ~]# cd /sys/kernel/mm/hugepages/hugepages-2048kB/
[root@debug010000002015 hugepages-2048kB]# echo 20 > nr_hugepages
[root@debug010000002015 hugepages-2048kB]# tail /proc/meminfo
CmaFree:               0 kB
HugePages_Total:      20
HugePages_Free:       20
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       2048 kB
Hugetlb:           40960 kB


Example code:
tools/testing/selftests/vm/map_hugetlb.c

mmap(MAP_HUGETLB)

0.1 global variables
================================================================================

minimum_order

default_hstate_idx
default_hstate  =  hstates[default_hstate_idx]


hstates[HUGE_MAX_HSTATE]
struct kobject *hugepages_kobj
struct kobject *hstate_kobjs[HUGE_MAX_HSTATE]

hugetlbfs_vfsmount[HUGE_MAX_HSTATE]

node_hstates[MAX_NUMNODES]

int num_fault_mutexes
struct mutex *hugetlb_fault_mutex_table 

0.2 struct hstate
================================================================================

    hstate
    +------------------------------------+
    |name[HSTATE_NAME_LEN]               |
    |    (char)                          |
    |next_nid_to_[alloc|free]            |  = first_memory_node
    |    (int)                           |
    |order                               |
    |    (int)                           |
    |mask                                |
    |    (unsigned long)                 |
    |                                    |
    |max_huge_pages                      |  = nr_huge_pages - surplus_huge_pages
    |                                    |
    |nr_huge_pages                       |  adjust in prep_new_huge_page()
    |free_huge_pages                     |  free includes surplus
    |resv_huge_pages                     |  gather_surplus_pages() & return_unused_surplus_pages()
    |surplus_huge_pages                  |  number of overcommitted
    |nr_overcommit_huge_pages            |  number of overcommit allowed
    |    (unsigned long)                 |
    |                                    |
    |nr_huge_pages_node[MAX_NUMNODES]    |
    |free_huge_pages_node[MAX_NUMNODES]  |
    |surplus_huge_pages_node[]           |
    |    (unsigned int)                  |
    |                                    |
    |hugepage_activelist                 |
    |hugepage_freelists[MAX_NUMNODES]    |
    |    (struct list_head)              |
    +------------------------------------+


                                                       |<-   overcommit  ->|
   |<--          free        -->|                      |                   |
   |             |<-- resv   -->|                      |<-- surplus-->|    |
   v             v              v                      v              v    v
   |----------------------------+-------------------------------------+....|
   ^                                                   ^              ^
   |                                                   |              |
   |<--                  persistent_huge_pages      -->|              |
   |                                                                  |
   |<--                      nr_huge_pages                         -->|
   |                                                                  |


0.1.1 struct hstate hstates[HUGE_MAX_HSTATE = 2]
================================================================================

0.3 struct node_hstate
================================================================================

    node_hstate
    +------------------------------------+
    |hugepages_kobj                      |
    |hstate_kobjs[HUGE_MAX_HSTATE]       |
    |    (struct kobject *)              |
    |                                    |
    +------------------------------------+

0.4 struct hugepage_subpool
================================================================================

created by hugepage_new_subpool() in hugetlbfs_fill_super().

    hugepage_subpool
    +------------------------------------+
    |hstate                              |
    |    (struct hstate *)               |
    |                                    |
    |max_hpages                          |
    |used_hpages                         |
    |                                    |
    |min_hpages                          |
    |rsv_hpages                          |
    |    (long)                          |
    |                                    |
    |                                    |
    +------------------------------------+


0.5 struct resv_map
================================================================================

    resv_map
    +------------------------------------+
    |adds_in_progress                    |
    |    (long)                          |    ordered by [from, to)
    |                                    |    file_region      file_region
    |regions                             |--->+-----------+--->+-----------+
    |    (struct list_head)              |    |from       |    |from       |
    |                                    |    |to         |    |to         |
    |                                    |    |           |    |           |
    |                                    |    +-----------+    +-----------+
    |                                    |
    |region_cache_count                  |  count in region_cache
    |    (long)                          |    file_region      file_region
    |region_cache                        |--->+-----------+--->+-----------+
    |    (struct list_head)              |    |           |    |           |
    |                                    |    +-----------+    +-----------+
    +------------------------------------+

0.6 inode -> super_block -> subpool
================================================================================

hugetlbfs_fill_super()

    inode              super_block       hugetlbfs_sb_info
    +-------------+    +------------+    +-----------------------+
    |i_sb     ----|--->|s_fs_info --|--->|hstate                 |
    |             |    |            |    |     (struct hstate*)  |
    |             |    |            |    |                       |
    |             |    +------------+    |spool                  |
    |             |                      |   (hugepage_subpool *)|
    |             |                      |                       |
    |             |                      |                       |
    |             |                      |                       |
    |             |                      |                       |
    |             |                      +-----------------------+
    +-------------+

0.7 vma_resv_map(), there are two cases
================================================================================

resv_map is probably created in hugetlbfs_get_inode().

if vma->vm_flags & VM_MAYSHARE

    inode
    +-------------+
    |i_mapping    |  = &i_data, for most cases, see comment in inode_resv_map
    |i_data       |  (address_space)
    |             |      resv_map
    | private_data| ---->+----------------+
    |             |      |                |
    +-------------+      +----------------+

else

    vma
    +-------------+
    |             |      resv_map
    |private_data | ---->+----------------+
    |             |      |                |
    +-------------+      +----------------+


0.8 fs_context
================================================================================

    fs_context
    +------------------------------------+
    |fs_type                             |  = &hugetlbfs_fs_type
    |    (file_system_type *)            |
    |ops                                 |  = &hugetlbfs_fs_context_ops
    |    (file_system_type *)            |
    |fs_private                          |
    |    (void *) = hugetlbfs_fs_context |
    |    +-------------------------------+
    |    |hstate                         |
    |    |    (struct hstate*)           |
    |    |max_hpages                     |
    |    |min_hpages                     |
    |    |    (long)                     |
    |    |                               |
    +----+-------------------------------+


0.8 hugetlb sysfs
================================================================================

/sys/kernel/mm/hugepages                            hugepages_kobj
/sys/kernel/mm/hugepages/hugepages-2048kB           hstate_kobjs[]
    nr_hugepages
    nr_overcommit_hugepages
    free_hugepages
    resv_hugepages
    surplus_hugepages

0.9 how pages are allocated from hugetlbfs
================================================================================

First prepare huge pages.

echo N > nr_hugepages

set_max_huge_pages()
    alloc_pool_huge_page()
        page = alloc_fresh_huge_page()
            alloc_buddy_huge_page()
            prep_new_huge_page()
        put_page(page)

Then at page fault.

hugetlb_fault()
    hugetlb_no_page()
        alloc_huge_page()
            page = dequeue_huge_page_vma()
            or
            page = alloc_buddy_huge_page_with_mpol()
