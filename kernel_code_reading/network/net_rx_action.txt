1. net_rx_action(), working thread for rx packet
================================================================================
1.1 sd = this_cpu_ptr(&softnet_data)
================================================================================
1.2 list_splice_init(&sd->poll_list, &list), take off from poll_list to list
================================================================================
1.3 n = list_first_entry(&list, struct napi_struct, poll_list)
================================================================================
1.4 napi_poll(n, &repoll) 
================================================================================
1.4.1 list_del_init(&n->poll_list), remove myself
================================================================================
1.4.2 have = netpoll_poll_lock(n)
================================================================================
1.4.3 weight = n->weight
================================================================================
1.4.4 n->poll(n, weight), registered by netif_napi_add()
================================================================================
1.4.4.1 ... netif_receive_skb(), driver hand over packet to kernel
================================================================================
1.5 list_splice_tail_init(&sd->poll_list, &list) 
================================================================================
1.6 list_splice_tail(&repoll, &list)
================================================================================
1.7 list_splice(&list, &sd->poll_list), move back to sd->poll_list
================================================================================

2. netif_rx()/netif_rx_ni(), receive a skb enqueue to backlog
================================================================================
2.1 netif_rx_internal(skb)
================================================================================
2.1.1 net_timestamp_check(netdev_tstamp_prequeue, skb);
================================================================================
2.1.2 enqueue_to_backlog(skb, get_cpu(), &qtail)
================================================================================
2.1.2.1 sd = &per_cpu(softnet_data, cpu)
================================================================================
2.1.2.1 qlen = skb_queue_len(&sd->input_pkt_queue)
================================================================================
2.1.2.2 __skb_queue_tail(&sd->input_pkt_queue, skb)
================================================================================
2.1.2.3 input_queue_tail_incr_save(sd, qtail)
================================================================================
2.2 do_softirq() -> call napi->poll() -> process_backlog()
================================================================================

3. process_backlog(napi, quota), napi->poll function
================================================================================
3.0 sd = container_of(napi, struct softnet_data, backlog)
================================================================================
3.1 skb = __skb_dequeue(&sd->process_queue) 
================================================================================
3.2 __netif_receive_skb(skb)
================================================================================
3.2.1 __netif_receive_skb_one_core(skb, true)
================================================================================
3.2.1.1 __netif_receive_skb_core(&skb, pfmemalloc, &pt_prev)
================================================================================
3.3 input_queue_head_incr(sd)
================================================================================
3.4 skb_queue_splice_tail_init(&sd->input_pkt_queue, &sd->process_queue), move skb from input_pkt_queue to process_queue
================================================================================

3. netif_receive_skb(skb) -> netif_receive_skb_internal(skb) -> __netif_receive_skb(skb)
================================================================================
3.1 __netif_receive_skb_one_core(skb, false) -> __netif_receive_skb_core(&skb, &pt_prev)
================================================================================
3.1.1 orig_dev = skb->dev
================================================================================
3.1.2 skb_reset_network_header(skb)
================================================================================
3.1.3 skb_reset_transport_header(skb)
================================================================================
3.1.4 skb_reset_mac_len(skb)
================================================================================
3.1.5 skb->skb_iif = skb->dev->ifindex
================================================================================
3.1.5 deliver_skb(skb, pt_prev, orig_dev), for each ptype_all / dev->ptype_all
================================================================================
3.1.6 rx_handler = rcu_dereference(skb->dev->rx_handler);
================================================================================
3.1.7 rx_handler(&skb), assigned by netdev_rx_handler_register()
================================================================================
3.1.8 type = skb->protocol
================================================================================
3.1.9 deliver_ptype_list_skb(skb, &pt_prev, orig_dev, type, &ptype_base[ntohs(type) & PTYPE_HASH_MASK]);
================================================================================
3.1.10 deliver_ptype_list_skb(skb, &pt_prev, orig_dev, type, &orig_dev->ptype_specific);
================================================================================
3.1.10.1 deliver_skb(skb, pt_prev, orig_dev), when ptype->type match
================================================================================

0. data structure
================================================================================

0.1 softnet_data, percpu variable
================================================================================
skb queue-ed by netif_rx_ni() to softnet_data->input_pkt_queue.
And then processed by process_backlog()

     softnet_data
     +---------------------------------------+
     |poll_list                              |  queued by __napi_schedule()
     |    (struct list_head)                 |  for rx
     |                                       |
     |processed                              |
     |time_squeeze                           |
     |received_rps                           |
     |dropped                                |
     |    (unsigned int)                     |
     |                                       |
     |completion_queue                       |
     |    (struct sk_buff)                   |
     |output_queue                           |
     |    (Qdisc*)                           |
     |output_queue_tailp                     |
     |    (Qdisc**)                          |
     |                                       |
     |process_queue                          |  moved in process_backlog()
     |input_pkt_queue                        |  enqueued in netif_rx_internal()
     |    (struct sk_buff_head)              |
     |                                       |
     |xmit                                   |
     |    +----------------------------------+
     |    |recursion                         |
     |    |    (u16)                         |
     |    |more                              |
     |    |    (u8)                          |
     |    +----------------------------------+
     |                                       |
     |backlog                                |  parameter to process_backlog()
     |    (struct napi_struct)               |
     |    +----------------------------------+
     |    |poll                              |  = process_backlog()
     |    |                                  |  netif_napi_add()
     |    |                                  |
     |    |poll_list                         |
     |    |    (struct list_head)            |
     |    |state                             |
     |    |    (unsigned long)               |
     |    |weight                            |
     |    |defer_hard_irqs_count             |
     |    |    (int)                         |
     |    |dev                               |
     |    |    (struct net_device*)          |
     |    |gro_bitmask                       |  = 0
     |    |    (unsigned long)               |
     |    |gro_hash[GRO_HASH_BUCKETS]        |
     |    |    (struct gro_list)             |
     |    |    +-----------------------------+
     |    |    |list                         |
     |    |    |    (struct list_head)       |
     |    |    |                             |
     |    |    |count                        |  = 0
     |    |    +-----------------------------+
     |    |skb                               |
     |    |    (struct sk_buff*)             |
     |    |rx_list                           |
     |    |    (struct list_head)            |
     |    |rx_count                          |
     |    |    (int)                         |
     |    |dev_list                          |
     |    |    (struct list_head)            |
     |    |napi_hash_node                    |
     |    |    (struct hlist_node)           |
     |    |napi_id                           |
     |    |    (unsigned int)                |
     |    |                                  |
     |    +----------------------------------+
     |                                       |
     +---------------------------------------+

0.1.1 how output_queue grow
================================================================================

Initialized state:

  softnet_data
  +-------------------------+
  |output_queue          ---|--> NULL
  |                      <--|---+
  +-------------------------+   |
  |output_queue_tailp    ---|---+
  |                         |
  +-------------------------+

After add one:

  softnet_data                    Qdisc
  +-------------------------+     +-------------+
  |output_queue          ---|---> |next_sched   |
  |                         |   +-|-->          |
  +-------------------------+   | +-------------+
  |output_queue_tailp    ---|---+
  |                         |
  +-------------------------+


After have two:

  softnet_data                    Qdisc               Qdisc
  +-------------------------+     +-------------+     +-------------+
  |output_queue          ---|---> |next_sched --|---> |next_sched   |
  |                         |     |             |   +-|-->          |
  +-------------------------+     +-------------+   | +-------------+
  |output_queue_tailp    ---|-----------------------+
  |                         |
  +-------------------------+

0.2 ptype_all ptype_base
================================================================================
; http://bbs.chinaunix.net/thread-1933943-1-1.html

  ptype_all(struct list_head), all with type ETH_P_ALL
  +---------+      +---------+      +---------+      
  |         | ---->|         | ---->|         | ---->
  +---------+      +---------+      +---------+      
  packet_type      packet_type      packet_type

  ptype_base(struct list_head)[16], a very raw hash list
                                    with various packet types
  +---------+      +---------+      +---------+ 
  |         | ---->|         | ---->|         | 
  +---------+      +---------+      +---------+ 
  |         |      ip_packet_type   arp_packet_type
  +---------+
  |         |
  +---------+
  |         |
  +---------+
  |         |
  +---------+
  |         |
  +---------+
  |         |
  +---------+

