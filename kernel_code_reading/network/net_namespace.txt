1. net_ns_init(), initialize the first namespace(init_net), ops(net_ns_ops) 
================================================================================
; this function is defined by pure_initcall(net_ns_init);
; #define pure_initcall(fn)		__define_initcall(fn, 0)

struct net init_net = {
	.dev_base_head = LIST_HEAD_INIT(init_net.dev_base_head),
};

static int __init net_ns_init(void)
{
	struct net_generic *ng;

#ifdef CONFIG_NET_NS
	net_cachep = kmem_cache_create("net_namespace", sizeof(struct net),
					SMP_CACHE_BYTES,
					SLAB_PANIC, NULL);

	/* Create workqueue for cleanup */
	netns_wq = create_singlethread_workqueue("netns");
	if (!netns_wq)
		panic("Could not create netns workq");
#endif

	ng = net_alloc_generic();
	if (!ng)
		panic("Could not allocate generic netns");

	rcu_assign_pointer(init_net.gen, ng);

	mutex_lock(&net_mutex);
	if (setup_net(&init_net, &init_user_ns))
		panic("Could not setup the initial network namespace");

	rtnl_lock();
	list_add_tail_rcu(&init_net.list, &net_namespace_list);
	rtnl_unlock();

	mutex_unlock(&net_mutex);

	register_pernet_subsys(&net_ns_ops);

	return 0;
}

1.1 setup_net(&init_net, &init_user_ns); assign user_ns, iterate on pernet_list
================================================================================
struct user_namespace init_user_ns = {
	.uid_map = {
		.nr_extents = 1,
		.extent[0] = {
			.first = 0,
			.lower_first = 0,
			.count = 4294967295U,
		},
	},
	.gid_map = {
		.nr_extents = 1,
		.extent[0] = {
			.first = 0,
			.lower_first = 0,
			.count = 4294967295U,
		},
	},
	.projid_map = {
		.nr_extents = 1,
		.extent[0] = {
			.first = 0,
			.lower_first = 0,
			.count = 4294967295U,
		},
	},
	.kref = {
		.refcount	= ATOMIC_INIT(3),
	},
	.owner = GLOBAL_ROOT_UID,
	.group = GLOBAL_ROOT_GID,
	.proc_inum = PROC_USER_INIT_INO,
};

static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)
{
	/* Must be called with net_mutex held */
	const struct pernet_operations *ops, *saved_ops;
	int error = 0;
	LIST_HEAD(net_exit_list);

	atomic_set(&net->count, 1);
	atomic_set(&net->passive, 1);
	net->dev_base_seq = 1;
	net->user_ns = user_ns;

#ifdef NETNS_REFCNT_DEBUG
	atomic_set(&net->use_count, 0);
#endif

	list_for_each_entry(ops, &pernet_list, list) {
		error = ops_init(ops, net);
		if (error < 0)
			goto out_undo;
	}
out:
	return error;

out_undo:
	/* Walk through the list backwards calling the exit functions
	 * for the pernet modules whose init functions did not fail.
	 */
	list_add(&net->exit_list, &net_exit_list);
	saved_ops = ops;
	list_for_each_entry_continue_reverse(ops, &pernet_list, list)
		ops_exit_list(ops, &net_exit_list);

	ops = saved_ops;
	list_for_each_entry_continue_reverse(ops, &pernet_list, list)
		ops_free_list(ops, &net_exit_list);

	rcu_barrier();
	goto out;
}

1.2 register_pernet_subsys(&net_ns_ops), wired, it is a subsys or an operation?
================================================================================
;see 3.1 for detailed explanation of this function
static struct pernet_operations __net_initdata net_ns_ops = {
	.init = net_ns_net_init,
	.exit = net_ns_net_exit,
};

1.2.1 net_ns_net_init(), ops: proc number
================================================================================
static __net_init int net_ns_net_init(struct net *net)
{
	return proc_alloc_inum(&net->proc_inum);
}

2. pernet operations 
================================================================================
There are two important list in net subsystem:
a. net_namespace_list: struct net {};
	one entity represents one network namespace
b. pernet_list: struct pernet_operations {};
	one entity represents the operation on a network namespace

Frontend API:
a. register_pernet_subsys()
b. register_pernet_device()

Backend API:
a. register_pernet_operations()

2.1 register_pernet_subsys(struct pernet_operations *ops)
================================================================================
int register_pernet_subsys(struct pernet_operations *ops)
{
	int error;
	mutex_lock(&net_mutex);
	error =  register_pernet_operations(first_device, ops);
	mutex_unlock(&net_mutex);
	return error;
}

2.1.1 register_pernet_operations()
================================================================================

2.2 register_pernet_device(struct pernet_operations *ops)
================================================================================
int register_pernet_device(struct pernet_operations *ops)
{
	int error;
	mutex_lock(&net_mutex);
	error = register_pernet_operations(&pernet_list, ops);
	if (!error && (first_device == &pernet_list))
		first_device = &ops->list;
	mutex_unlock(&net_mutex);
	return error;
}

2.2.1 register_pernet_operations()
================================================================================

2.3 register_pernet_operations(struct list_head *list, struct pernet_operations *ops)
================================================================================
static int register_pernet_operations(struct list_head *list,
				      struct pernet_operations *ops)
{
	int error;

	if (ops->id) {
again:
		error = ida_get_new_above(&net_generic_ids, 1, ops->id);
		if (error < 0) {
			if (error == -EAGAIN) {
				ida_pre_get(&net_generic_ids, GFP_KERNEL);
				goto again;
			}
			return error;
		}
		max_gen_ptrs = max_t(unsigned int, max_gen_ptrs, *ops->id);
	}
	error = __register_pernet_operations(list, ops);
	if (error) {
		rcu_barrier();
		if (ops->id)
			ida_remove(&net_generic_ids, *ops->id);
	}

	return error;
}

2.3.1 __register_pernet_operations()
================================================================================
; iterate on each network namespace
static int __register_pernet_operations(struct list_head *list,
					struct pernet_operations *ops)
{
	struct net *net;
	int error;
	LIST_HEAD(net_exit_list);

	list_add_tail(&ops->list, list);
	if (ops->init || (ops->id && ops->size)) {
		for_each_net(net) {
			error = ops_init(ops, net);
			if (error)
				goto out_undo;
			list_add_tail(&net->exit_list, &net_exit_list);
		}
	}
	return 0;

out_undo:
	/* If I have an error cleanup all namespaces I initialized */
	list_del(&ops->list);
	ops_exit_list(ops, &net_exit_list);
	ops_free_list(ops, &net_exit_list);
	return error;
}

2.3.1.1 ops_init(), allocate a space & record it in net->ng->ptr[id]
================================================================================
static int ops_init(const struct pernet_operations *ops, struct net *net)
{
	int err = -ENOMEM;
	void *data = NULL;

	if (ops->id && ops->size) {
		data = kzalloc(ops->size, GFP_KERNEL);
		if (!data)
			goto out;

		err = net_assign_generic(net, *ops->id, data);
		if (err)
			goto cleanup;
	}
	err = 0;
	if (ops->init)
		err = ops->init(net);
	if (!err)
		return 0;

cleanup:
	kfree(data);

out:
	return err;
}

0. data structure
================================================================================

0.1 net
================================================================================
init_net(struct net)
   +------------------------+
   |                        |
   |                        |
   +------------------------+
   |gen(struct net_generic) |------>+---------------+
   |                        |       |len            |
   +------------------------+       |rcu(rcu_head)  |         point to the data necessary for proper pernet_operations
   |                        |       |ptr(void *[])  |---------+---------------+
   |                        |       +---------------+         |               |
   |                        |                                 +---------------+
   +------------------------+        init_user_ns             |               |
   |user_ns(user_namespace) |--------+-------------------+    +---------------+
   |                        |        |uid_map            |    |               |
   +------------------------+        |gid_map            |    +---------------+
   |                        |        |projid_map         |
   |                        |        |                   |
   |                        |        |owner              |
   |                        |        |group              |
   |                        |        |                   |
   |                        |        |                   |
   +------------------------+        +-------------------+
   |loopback_dev            |
   |  (struct net_device*)  |
   +------------------------+
   |                        |
   |                        |
   +------------------------+





               Figure 0.1 Glance at the init_net

0.2 net_namespace_list/pernet_list
================================================================================

net_namespace_list, a list of network namespace
   +-------------+       +-------------+       +-------------+
   |net          | ----->|net          | ----->|net          |
   +-------------+       +-------------+       +-------------+
   init_net

pernet_list, a list of pernet_operations
   +-------------+       +-------------+      +-------------+      +-------------+
   |ops          | ----->|ops          |----->|ops          |----->|ops          |
   +-------------+       +-------------+      +-------------+      +-------------+
   net_ns_ops            netdev_net_ops       loopback_net_ops     default_device_ops
                         .netdev_init         .loopback_net_init   .default_device_exit
			 .netdev_exit

               Figure 0.2 net_namespace & pernet_list
