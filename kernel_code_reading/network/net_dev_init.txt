1. net_dev_init(), init net subsystem
================================================================================
; this function is defined like subsys_initcall(net_dev_init);
; #define subsys_initcall(fn)		__define_initcall(fn, 4)
static int __init net_dev_init(void)
{
	int i, rc = -ENOMEM;

	BUG_ON(!dev_boot_phase);

	if (dev_proc_init())
		goto out;

	if (netdev_kobject_init())
		goto out;

	INIT_LIST_HEAD(&ptype_all);
	for (i = 0; i < PTYPE_HASH_SIZE; i++)
		INIT_LIST_HEAD(&ptype_base[i]);

	if (register_pernet_subsys(&netdev_net_ops))
		goto out;

	/*
	 *	Initialise the packet receive queues.
	 */

	for_each_possible_cpu(i) {
		struct softnet_data *sd = &per_cpu(softnet_data, i);

		memset(sd, 0, sizeof(*sd));
		skb_queue_head_init(&sd->input_pkt_queue);
		skb_queue_head_init(&sd->process_queue);
		sd->completion_queue = NULL;
		INIT_LIST_HEAD(&sd->poll_list);
		sd->output_queue = NULL;
		sd->output_queue_tailp = &sd->output_queue;
#ifdef CONFIG_RPS
		sd->csd.func = rps_trigger_softirq;
		sd->csd.info = sd;
		sd->csd.flags = 0;
		sd->cpu = i;
#endif

		sd->backlog.poll = process_backlog;
		sd->backlog.weight = weight_p;
		sd->backlog.gro_list = NULL;
		sd->backlog.gro_count = 0;
	}

	dev_boot_phase = 0;

	/* The loopback device is special if any other network devices
	 * is present in a network namespace the loopback device must
	 * be present. Since we now dynamically allocate and free the
	 * loopback device ensure this invariant is maintained by
	 * keeping the loopback device as the first device on the
	 * list of network devices.  Ensuring the loopback devices
	 * is the first device that appears and the last network device
	 * that disappears.
	 */
	if (register_pernet_device(&loopback_net_ops))
		goto out;

	if (register_pernet_device(&default_device_ops))
		goto out;

	open_softirq(NET_TX_SOFTIRQ, net_tx_action);
	open_softirq(NET_RX_SOFTIRQ, net_rx_action);

	hotcpu_notifier(dev_cpu_callback, 0);
	dst_init();
	dev_mcast_init();
	rc = 0;
out:
	return rc;
}

1.1 dev_proc_init(), create proc file under /proc/net & /proc/pid/net/
================================================================================
static struct pernet_operations __net_initdata dev_proc_ops = {
	.init = dev_proc_net_init,
	.exit = dev_proc_net_exit,
};

static int __init dev_proc_init(void)
{
	return register_pernet_subsys(&dev_proc_ops);
}

1.1.1 register_pernet_subsys(&dev_proc_ops);
================================================================================

1.1.1.1 dev_proc_net_init(&dev_proc_ops), under /proc/pid/net
================================================================================
; one indication the net->proc_net is initialized in proc_net_init().
static int __net_init dev_proc_net_init(struct net *net)
{
	int rc = -ENOMEM;

	if (!proc_net_fops_create(net, "dev", S_IRUGO, &dev_seq_fops))
		goto out;
	if (!proc_net_fops_create(net, "softnet_stat", S_IRUGO, &softnet_seq_fops))
		goto out_dev;
	if (!proc_net_fops_create(net, "ptype", S_IRUGO, &ptype_seq_fops))
		goto out_softnet;

	if (wext_proc_init(net))
		goto out_ptype;
	rc = 0;
out:
	return rc;
out_ptype:
	proc_net_remove(net, "ptype");
out_softnet:
	proc_net_remove(net, "softnet_stat");
out_dev:
	proc_net_remove(net, "dev");
	goto out;
}

1.1.1.1.1 proc_net_fops_create()
================================================================================
struct proc_dir_entry *proc_net_fops_create(struct net *net,
	const char *name, umode_t mode, const struct file_operations *fops)
{
	return proc_create(name, mode, net->proc_net, fops);
}

1.2 netdev_kobject_init(), /sys/class/net/
================================================================================
int netdev_kobject_init(void)
{
	kobj_ns_type_register(&net_ns_type_operations);
	return class_register(&net_class);
}

1.2.1 kobj_ns_type_register(&net_ns_type_operations), register namespace ops of net
================================================================================
; there is an array for kobject namespace ops, 
; register one for network
struct kobj_ns_type_operations net_ns_type_operations = {
	.type = KOBJ_NS_TYPE_NET,
	.grab_current_ns = net_grab_current_ns,
	.netlink_ns = net_netlink_ns,
	.initial_ns = net_initial_ns,
	.drop_ns = net_drop_ns,
};

int kobj_ns_type_register(const struct kobj_ns_type_operations *ops)
{
	enum kobj_ns_type type = ops->type;
	int error;

	spin_lock(&kobj_ns_type_lock);

	error = -EINVAL;
	if (type >= KOBJ_NS_TYPES)
		goto out;

	error = -EINVAL;
	if (type <= KOBJ_NS_TYPE_NONE)
		goto out;

	error = -EBUSY;
	if (kobj_ns_ops_tbl[type])
		goto out;

	error = 0;
	kobj_ns_ops_tbl[type] = ops;

out:
	spin_unlock(&kobj_ns_type_lock);
	return error;
}

1.2.2 class_register(&net_class), register a class for net, /sys/class/net
================================================================================
static struct class net_class = {
	.name = "net",
	.dev_release = netdev_release,
	.dev_groups = net_class_groups,
	.dev_uevent = netdev_uevent,
	.ns_type = &net_ns_type_operations,
	.namespace = net_namespace,
};

1.3 register_pernet_subsys(&netdev_net_ops)
================================================================================
static struct pernet_operations __net_initdata netdev_net_ops = {
	.init = netdev_init,
	.exit = netdev_exit,
};

1.3.1 netdev_init(), ops: netdev_init, init hash talbe of dev name/index
================================================================================
static int __net_init netdev_init(struct net *net)
{
	if (net != &init_net)
		INIT_LIST_HEAD(&net->dev_base_head);

	net->dev_name_head = netdev_create_hash();
	if (net->dev_name_head == NULL)
		goto err_name;

	net->dev_index_head = netdev_create_hash();
	if (net->dev_index_head == NULL)
		goto err_idx;

	return 0;

err_idx:
	kfree(net->dev_name_head);
err_name:
	return -ENOMEM;
}

1.3.1.1 netdev_create_hash()
================================================================================
static struct hlist_head *netdev_create_hash(void)
{
	int i;
	struct hlist_head *hash;

	hash = kmalloc(sizeof(*hash) * NETDEV_HASHENTRIES, GFP_KERNEL);
	if (hash != NULL)
		for (i = 0; i < NETDEV_HASHENTRIES; i++)
			INIT_HLIST_HEAD(&hash[i]);

	return hash;
}


1.4 register_pernet_device(&loopback_net_ops)
================================================================================
struct pernet_operations __net_initdata loopback_net_ops = {
       .init = loopback_net_init,
};

1.5 register_pernet_device(&default_device_ops)
================================================================================
static struct pernet_operations __net_initdata default_device_ops = {
	.exit = default_device_exit,
	.exit_batch = default_device_exit_batch,
};

1.6 open_softirq(NET_TX_SOFTIRQ, net_tx_action);
================================================================================
void open_softirq(int nr, void (*action)(struct softirq_action *))
{
	softirq_vec[nr].action = action;
}

1.7 open_softirq(NET_RX_SOFTIRQ, net_rx_action);
================================================================================

1.8 hotcpu_notifier(dev_cpu_callback, 0)
================================================================================

1.9 dst_init(), register final notification call
================================================================================
static struct notifier_block dst_dev_notifier = {
	.notifier_call	= dst_dev_event,
	.priority = -10, /* must be called after other network notifiers */
};

void __init dst_init(void)
{
	register_netdevice_notifier(&dst_dev_notifier);
}

1.9.1 register_netdevice_notifier()
================================================================================
int register_netdevice_notifier(struct notifier_block *nb)
{
	struct net_device *dev;
	struct net_device *last;
	struct net *net;
	int err;

	rtnl_lock();
	err = raw_notifier_chain_register(&netdev_chain, nb);
	if (err)
		goto unlock;
	if (dev_boot_phase)
		goto unlock;
	for_each_net(net) {
		for_each_netdev(net, dev) {
			err = nb->notifier_call(nb, NETDEV_REGISTER, dev);
			err = notifier_to_errno(err);
			if (err)
				goto rollback;

			if (!(dev->flags & IFF_UP))
				continue;

			nb->notifier_call(nb, NETDEV_UP, dev);
		}
	}

unlock:
	rtnl_unlock();
	return err;

rollback:
	last = dev;
	for_each_net(net) {
		for_each_netdev(net, dev) {
			if (dev == last)
				goto outroll;

			if (dev->flags & IFF_UP) {
				nb->notifier_call(nb, NETDEV_GOING_DOWN, dev);
				nb->notifier_call(nb, NETDEV_DOWN, dev);
			}
			nb->notifier_call(nb, NETDEV_UNREGISTER, dev);
		}
	}

outroll:
	raw_notifier_chain_unregister(&netdev_chain, nb);
	goto unlock;
}

1.9.1.1 dst_dev_event()
================================================================================
static int dst_dev_event(struct notifier_block *this, unsigned long event,
			 void *ptr)
{
	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
	struct dst_entry *dst, *last = NULL;

	switch (event) {
	case NETDEV_UNREGISTER_FINAL:
	case NETDEV_DOWN:
		mutex_lock(&dst_gc_mutex);
		for (dst = dst_busy_list; dst; dst = dst->next) {
			last = dst;
			dst_ifdown(dst, dev, event != NETDEV_DOWN);
		}

		spin_lock_bh(&dst_garbage.lock);
		dst = dst_garbage.list;
		dst_garbage.list = NULL;
		spin_unlock_bh(&dst_garbage.lock);

		if (last)
			last->next = dst;
		else
			dst_busy_list = dst;
		for (; dst; dst = dst->next)
			dst_ifdown(dst, dev, event != NETDEV_DOWN);
		mutex_unlock(&dst_gc_mutex);
		break;
	}
	return NOTIFY_DONE;
}

0. data structure
================================================================================

0.1 net_device
================================================================================

   net_device
   +---------------------------------------+
   |name[IFNAMSIZ]                         |
   |   (char)                              |
   |name_node                              |
   |   (struct netdev_name_node*)          |
   |ifalias                                |
   |   (struct dev_ifalias*)               |
   +---------------------------------------+
   |mem_end                                |
   |mem_start                              |
   |base_addr                              |
   |   (unsigned long)                     |
   |irq                                    |
   |   (int)                               |
   +---------------------------------------+
   |state                                  |
   |   (unsigned long)                     |
   |dev_list                               |
   |napi_list                              |
   |unreg_list                             |
   |close_list                             |
   |ptype_all                              |
   |ptype_specific                         |
   |   (struct list_head)                  |
   |adj_list                               |
   |   +-----------------------------------+
   |   |upper                              |
   |   |lower                              |
   |   |    (struct list_head)             |
   |   +-----------------------------------+
   |                                       |
   |features                               |
   |hw_features                            |
   |wanted_features                        |
   |vlan_features                          |
   |hw_enc_features                        |
   |mpls_features                          |
   |gso_partial_features                   |
   |   (netdev_features_t)                 |
   |                                       |
   |ifindex                                |
   |group                                  |
   |   (int)                               |
   |                                       |
   |stats                                  |
   |   (struct net_device_stats)           |
   |                                       |
   |rx_dropped                             |
   |tx_dropped                             |
   |rx_nohandler                           |
   |   (atomic_long_t)                     |
   |carrier_up_count                       |
   |carrier_down_count                     |
   |   (atomic_t)                          |
   |                                       |
   |netdev_ops                             |
   |   (struct net_device_ops*)            |
   |ethtool_ops                            |
   |   (struct ethtool_ops*)               |
   |header_ops                             |
   |   (struct header_ops*)                |
   |                                       |
   |                                       |
   |                                       |
   |mtu/min_mtu/max_mtu                    |
   |   (unsigned int)                      |
   |type                                   |
   |hard_header_len                        |
   |min_header_len                         |
   |name_assign_type                       |
   |needed_headroom/needed_tailroom        |
   |   (short/char)                        |
   |                                       |
   |perm_addr[MAX_ADDR_LEN]                |
   |addr_assign_type                       |
   |addr_len                               |
   |upper_level/lower_level                |
   |   (char)                              |
   |neigh_priv_len                         |
   |dev_id                                 |
   |dev_port                               |
   |   (short)                             |
   |                                       |
   |ip_ptr                                 |
   |   (struct in_device*)                 |
   |ip6_ptr                                |
   |   (struct inet6_dev*)                 |
   |                                       |  // receive path
   |dev_addr                               |
   |   (char *)                            |
   |_rx                                    |
   |   (struct netdev_rx_queue*)           |
   |num_rx_queues/real_num_rx_queues       |
   |   (unsigned int)                      |
   |rx_handler                             |
   |   (rx_handler_func_t)                 |
   |rx_handler_data                        |
   |   (void *)                            |
   |ingress_queue                          |
   |   (struct netdev_queue*)              |
   |broadcast[MAX_ADDR_LEN]                |
   |   (unsigned char)                     |
   |                                       |
   |                                       |  // transmit path
   |_tx                                    |
   |   (struct netdev_queue*)              |
   |num_tx_queues/real_num_tx_queues       |
   |   (unsigned int)                      |
   |qdisc                                  |  = &noop_qdisc
   |   (struct Qdisc*)                     |
   |tx_queue_len                           |
   |   (unsigned int)                      |
   |                                       |
   |dev                                    |
   |   (struct device)                     |
   |phydev                                 |
   |   (struct phy_device*)                |
   |                                       |
   |                                       |
   |                                       |
   |                                       |
   |                                       |
   +---------------------------------------+

0.2 netdev_queue
================================================================================

   netdev_queue
   +---------------------------------------+
   |dev                                    |
   |    (struct net_device*)               |
   |qdisc                                  |
   |qdisc_sleeping                         |
   |    (struct Qdisc*)                    |
   |tx_maxrate                             |
   |trans_timeout                          |
   |    (unsigned long)                    |
   |sb_dev                                 |
   |    (struct net_device*)               |
   |trans_start                            |
   |    (unsigned long)                    |
   |state                                  |
   |    (unsigned long)                    |
   |                                       |
   |_xmit_lock                             |
   |    (spinlock_t)                       |
   |                                       |
   |                                       |
   |                                       |
   +---------------------------------------+

0.3 Qdisc
================================================================================

   Qdisc
   +---------------------------------------+
   |enqueue                                |
   |dequeue                                |
   |    ()                                 |
   |ops                                    |
   |    (struct Qdisc_ops*)                |
   |stab                                   |
   |    (struct qdisc_size_table*)         |
   |hash                                   |
   |    (struct hlist_node)                |
   |handle                                 |
   |parent                                 |
   |    (u32)                              |
   |dev_queue                              |
   |    (struct netdev_queue*)             |
   |q                                      |
   |    (struct qdisc_skb_head)            |
   |                                       |
   |                                       |
   |                                       |
   |                                       |
   +---------------------------------------+

0.4 net_device / netdev_queue / Qdisc
================================================================================

   net_device
   +---------------------------------------+<-----+
   |_tx                                    |      |
   |  (struct netdev_queue*)               |      |
   |  +------------------------------------+<--+  |
   |  |dev                             ----|------+
   |  |    (struct net_device*)            |   |
   |  |qdisc                               |   |
   |  |    (struct Qdisc*)                 |   |
   |  |    +-------------------------------+   |
   |  |    |dev_queue                  ----|---+
   |  |    |    (struct netdev_queue)      |
   |  |    |                               |
   +--+----+-------------------------------+
