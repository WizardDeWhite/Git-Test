0.
================================================================================

0.1 Packet transfer files
================================================================================

   net_rx_tx_action.txt               rx/tx softirq
   netif_receive_skb.txt              ingress path
   sch_generic.txt                    egress path

0.1.1 ingress path
================================================================================
0.1.1.1 net_rx_action()
================================================================================
net_rx_action:

When an interrupt is triggered by a NIC, probably a packet is received, driver
will add dev's napi_struct to softnet_data(per cpu)'s poll_list and raise
NET_RX_SOFTIRQ.

Then net_rx_action will handle each napi_struct structure on its local
poll_list and finally invoke the napi_struct->poll function, which is set in
driver.

0.1.1.2 netif_receive_skb()
================================================================================
netif_receive_skb:

In the napi_struct->poll function, driver will prepare the skb and then call
netif_receive_skb to hand over the packet to kernel. Then kernel will do some
check and process it according to their packet type.

0.1.2 egress path
================================================================================
0.1.2.1 net_tx_action
================================================================================
net_tx_action:

Do the real release of skb on softnet_data->completion_queue(struct sk_buff).

Remove the qdisc list on softnet_data->output_queue(struct Qdisc*), dequeue
qdisc one by one on this list, then run qdisc_run() on an individual qdisc.
qdisc_restart() will pick up a proper queue, then do the real transmit by
dev_hard_start_xmit().

0.1.2.2 netif_wake_queue/netif_tx_wake_all_queues
================================================================================
Then the next question is who raise the NET_TX_SOFTIRQ and wake up
net_tx_action?

This is a little tricky. I search the symbol, NET_TX_SOFTIRQ, all of them are
in net/core/dev.c. I feel confused about this. Then I am asking who insert a
qdisc on softnet_data->output_queue? That's the magic of output_queue_tailp.
Finally, __netif_reschedule() would be the only place to insert on qdisc in
the output_queue.

Then I believe the magic locates in:

    netif_wake_queue()
    netif_tx_wake_all_queues()
         netif_tx_wake_queue()  <-- call __netif_schedule() here

Device driver would call these three functions to schedule a qdisc to system
and trigger the NET_TX_SOFTIRQ.

0.1.2.3 dev_queue_xmit()
================================================================================
Hope I am correct in the above, I forget the meaning of following part:

---------------
One skb is queued to softnet_data->output_queue for transmission in
dev_queue_xmit(). This will raise the NET_TX_SOFTIRQ to process the
output_queue one by one.

Finally it will hand over skb to the right dev/driver.
---------------

This is a note before, I guess it is not correct. dev_queue_xmit() will hand
over the skb to a device directly, NET_TX_SOFTIRQ is not involved.

0.1.3 netdev up flow
================================================================================

net_device_ops->ndo_open()      prepare and bring up the device
   netif_carrier_on()
      linkwatch_fire_event()
      ...
      linkwatch_do_dev()
         dev_activate()         create qdisc for each netdev_queue

1. net_namespace_list/pernet_list
================================================================================

net_namespace_list, a list of network namespace
   +-------------+       +-------------+       +-------------+
   |net          | ----->|net          | ----->|net          |
   +-------------+       +-------------+       +-------------+
   init_net

pernet_list, a list of pernet_operations
   +-------------+       +-------------+      +-------------+      +-------------+
   |ops          | ----->|ops          |----->|ops          |----->|ops          |
   +-------------+       +-------------+      +-------------+      +-------------+
   net_ns_ops            netdev_net_ops       loopback_net_ops     default_device_ops
                         .netdev_init         .loopback_net_init   .default_device_exit
			 .netdev_exit

               Figure 0.2 net_namespace & pernet_list

1.1 net
================================================================================
init_net(struct net)
   +------------------------+
   |                        |
   |                        |
   +------------------------+
   |gen(struct net_generic) |------>+---------------+
   |                        |       |len            |
   +------------------------+       |rcu(rcu_head)  |         point to the data necessary for proper pernet_operations
   |                        |       |ptr(void *[])  |---------+---------------+
   |                        |       +---------------+         |               |
   |                        |                                 +---------------+
   +------------------------+        init_user_ns             |               |
   |user_ns(user_namespace) |--------+-------------------+    +---------------+
   |                        |        |uid_map            |    |               |
   +------------------------+        |gid_map            |    +---------------+
   |                        |        |projid_map         |
   |                        |        |                   |
   |                        |        |owner              |
   |                        |        |group              |
   |                        |        |                   |
   |                        |        |                   |
   +------------------------+        +-------------------+
   |loopback_dev            |
   |  (struct net_device*)  |
   +------------------------+
   |dev_base_head           | list or hash list link the netdev
   |  (struct list_head)    | in this namespace
   |dev_name_head           |
   |  (hlist_head*)         |
   |dev_index_head          |
   |  (hlist_head*)         |
   +------------------------+
   |                        |
   |                        |
   +------------------------+


               Figure 0.1 Glance at the init_net

2. protocol list
================================================================================
proto_list 
   ------> netlink_proto ------> tcp_prot ------> udp_prot ------> ping_prot

3. net_proto_family array
================================================================================
net_families
   ------> netlink_family_ops ------> inet_family_ops ------> inet6_family_ops

4. qdisc_base, 
================================================================================
qdisc_base
   ------> pfifo_fast_ops ------> pfifo_qdisc_ops ------> ...

5. softnet_data, percpu variable
================================================================================

6. dev_queue_xmit(skb) -> __dev_queue_xmit(skb, NULL), queue a buffer for transmission to netdev
================================================================================
6.1 dev = skb->dev
================================================================================
6.2 skb_reset_mac_header(skb)
================================================================================
6.3 skb_update_prio(skb)
================================================================================
6.4 qdisc_pkt_len_init(skb), calculate qdisc->pkt_len
================================================================================
6.5 skb_dst_drop(skb)
================================================================================
6.5 skb_dst_force(skb)
================================================================================
6.6 txq = netdev_core_pick_tx(dev, skb, sb_dev)
================================================================================
6.6.1 skb_set_queue_mapping(skb, queue_index)
================================================================================
6.6.2 return netdev_get_tx_queue(dev, queue_index)
================================================================================
6.6.2.1 return &dev->_tx[index]
================================================================================
6.7 q = rcu_dereference(txq->qdisc)
================================================================================
6.8 __dev_xmit_skb(skb, q, dev, txq), if q->enqueue
================================================================================
6.9 skb = validate_xmit_skb(skb, dev, &gain)
================================================================================
6.10 skb = dev_hard_start_xmit(skb, dev, txq, &rc)
================================================================================

7. netif_rx_ni(), receive a skb from a net_device
================================================================================
7.1 netif_rx_internal(skb)
================================================================================
7.1.1 net_timestamp_check(netdev_tstamp_prequeue, skb);
================================================================================
7.1.2 enqueue_to_backlog(skb, get_cpu(), &qtail)
================================================================================
7.1.2.1 sd = &per_cpu(softnet_data, cpu)
================================================================================
7.1.2.1 qlen = skb_queue_len(&sd->input_pkt_queue)
================================================================================
7.1.2.2 __skb_queue_tail(&sd->input_pkt_queue, skb)
================================================================================
7.1.2.3 input_queue_tail_incr_save(sd, qtail)
================================================================================
7.2 do_softirq()
================================================================================

8. process_backlog(napi, quota), napi->poll function
================================================================================
8.0 sd = container_of(napi, struct softnet_data, backlog)
================================================================================
8.1 skb = __skb_dequeue(&sd->process_queue) 
================================================================================
8.2 __netif_receive_skb(skb)
================================================================================
8.2.1 __netif_receive_skb_one_core(skb, true)
================================================================================
8.2.1.1 __netif_receive_skb_core(&skb, pfmemalloc, &pt_prev)
================================================================================
8.3 input_queue_head_incr(sd)
================================================================================
8.4 skb_queue_splice_tail_init(&sd->input_pkt_queue, &sd->process_queue), move skb from input_pkt_queue to process_queue
================================================================================

9. __netif_receive_skb_core(pskb, pfmemalloc, ppt_prev), core for pkt receive
================================================================================
9.1 orig_dev = skb->dev
================================================================================
9.2 skb_reset_network_header(skb)
================================================================================
9.3 skb_reset_transport_header(skb)
================================================================================
9.4 skb_reset_mac_len(skb)
================================================================================
9.5 deliver_skb(skb, pt_prev, orig_dev), for each ptype_all / dev->ptype_all
================================================================================

0. Data Struct
================================================================================

0.1 softnet_data
================================================================================
skb queue-ed by netif_rx_ni() to softnet_data->input_pkt_queue.
And then processed by process_backlog()

     softnet_data
     +---------------------------------------+
     |poll_list                              |
     |    (struct list_head)                 |
     |process_queue                          |
     |input_pkt_queue                        |
     |    (struct sk_buff_head)              |
     |                                       |
     |processed                              |
     |time_squeeze                           |
     |received_rps                           |
     |dropped                                |
     |    (unsigned int)                     |
     |                                       |
     |output_queue                           |
     |    (Qdisc*)                           |
     |output_queue_tailp                     |
     |    (Qdisc**)                          |
     |completion_queue                       |
     |    (struct sk_buff)                   |
     |                                       |
     |xmit                                   |
     |    +----------------------------------+
     |    |recursion                         |
     |    |    (u16)                         |
     |    |more                              |
     |    |    (u8)                          |
     |    +----------------------------------+
     |                                       |
     |backlog                                |  parameter to process_backlog()
     |    (struct napi_struct)               |
     |    +----------------------------------+
     |    |poll                              |  = process_backlog()
     |    |                                  |
     |    +----------------------------------+
     |                                       |
     +---------------------------------------+
