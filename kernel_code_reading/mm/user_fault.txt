1. usage
================================================================================
An example in 
http://man7.org/linux/man-pages/man2/userfaultfd.2.html

    // open userfaultfd
    ufd = syscall(__NR_userfaultfd, O_CLOEXEC);

    // register a fault range
    reg_struct.range.start = (uintptr_t)testarea;
    reg_struct.range.len = pagesize;
    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;
    ioctl(ufd, UFFDIO_REGISTER, &reg_struct)

    // get fault event
    poll(ufd)
    read(ufd, &msg, sizeof(msg));

    // fill the faulted page
    uffdio_copy.src = (unsigned long) page;
    uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
                                       ~(page_size - 1);
    uffdio_copy.len = page_size;
    uffdio_copy.mode = 0;
    uffdio_copy.copy = 0;
    ioctl(uffd, UFFDIO_COPY, &uffdio_copy)

2.  SYSCALL_DEFINE1(userfaultfd, int, flags)
================================================================================
2.1 anon_inode_getfd(userfaultfd_fops)
================================================================================
static const struct file_operations userfaultfd_fops = {
#ifdef CONFIG_PROC_FS
	.show_fdinfo	= userfaultfd_show_fdinfo,
#endif
	.release	= userfaultfd_release,
	.poll		= userfaultfd_poll,
	.read		= userfaultfd_read,
	.unlocked_ioctl = userfaultfd_ioctl,
	.compat_ioctl	= userfaultfd_ioctl,
	.llseek		= noop_llseek,
};

2.1.1 userfaultfd_poll
================================================================================
2.1.1.1 return EPOLLIN when there is pending wq
================================================================================
2.1.2 userfaultfd_read
================================================================================
2.1.2.1 userfaultfd_ctx_read
================================================================================
2.1.2.1.1 find_userfault(ctx)
================================================================================
2.1.2.1.2 find_userfault_evt(ctx)
================================================================================

2.1.3 userfaultfd_ioctl
================================================================================
2.1.3.1 UFFDIO_API
================================================================================
2.1.3.2 UFFDIO_REGISTER/UNREGISTER
================================================================================
2.1.3.3 UFFDIO_COPY
================================================================================
2.1.3.4 UFFDIO_ZEROPAGE
================================================================================

3. userfaultfd_register, UFFDIO_REGISTER
================================================================================

3.1 validate_range(mm, start, len)
================================================================================
3.2 vma = find_vma_prev(mm, start, &prev)
================================================================================
3.3 vma_can_userfault()
================================================================================
3.4 vma_merge()
================================================================================

4. handle_userfault(), tell the polling thread one userfault happen
================================================================================

4.1 init_waitqueue_func_entry(&uwq.wq, userfaultfd_wake_function)
================================================================================
4.2 __add_wait_queue(&ctx->fault_pending_wqh, &uwq.wq);
================================================================================
4.3 wake_up_poll(&ctx->fd_wqh, EPOLLIN), wake poll thread up
================================================================================
4.4 READ_ONCE(uwq.waken), wait untill uwq.waken is set
================================================================================

5. userfaultfd_copy(), UFFDIO_COPY
================================================================================

5.1 validate_range
================================================================================
5.2 mmget_not_zero(mm)
================================================================================
5.2.1 atomic_inc_not_zero(mm->mm_users)
================================================================================

5.3 mcopy_atomic(ctx->mm, dst, src, len, mmap_changing), core of UFFDIO_COPY
================================================================================
5.3.1 find_vma
================================================================================

5.3.2 __mcopy_atomic_hugetlb(), handle huge page
================================================================================
5.3.2.1 huge_pte_alloc(dst_mm, dst_addr, size)
================================================================================
5.3.2.2 huge_ptep_get(dst_pte)
================================================================================
5.3.2.3 hugetlb_mcopy_atomic_pte()
================================================================================
5.3.2.4 copy_huge_page_from_user()
================================================================================

5.3.3 anon_vma_prepare(dst_vma), alloc/find anon_vma for dst_vma
================================================================================
5.3.4 mm_alloc_pmd(dst_mm, dst_addr)
================================================================================
5.3.5 pmd_read_atomic
================================================================================
5.3.6 __pte_alloc(dst_mm, dst_pmd)
================================================================================
5.3.7 mfill_atomic_pte(dst_mm, dst_pmd, dst_vma, dst_addr, src_addr, &page, zeropage)
================================================================================
5.3.7.1 mcopy_atomic_pte
================================================================================
5.3.7.2 mfill_zeropage_pte
================================================================================
5.3.7.3 shmem_mcopy_atomic_pte
================================================================================
5.3.7.4 shmem_mfill_zeropage_pte
================================================================================
5.3.8 copy_from_user()
================================================================================

5.4 put_user(ret, &user_uffdio_copy->copy)
================================================================================
5.5 wake_userfault(ctx, &range)
================================================================================
5.5.1 __wake_userfault(ctx, &range), wake all in the range and autoremove
================================================================================

6. mfill_atomic_pte
================================================================================

6.1. mcopy_atomic_pte
================================================================================
6.1.1 page = alloc_page_vma, copy content to this page and write it to pte
================================================================================
6.1.2 kmap_atomic
================================================================================
6.1.3 copy_from_user()
================================================================================
6.1.4 kunmap_atomic
================================================================================
6.1.5 pte_offset_map_lock
================================================================================
6.1.6 page_add_new_anon_rmap(page, dst_vma, dst_addr, false)
================================================================================
6.1.7 lru_cache_add_active_or_unevictable(page, dst_vma)
================================================================================
6.1.8 set_pte_at
================================================================================
6.2. mfill_zeropage_pte
================================================================================
6.2.1 pte_offset_map_lock
================================================================================
6.2.2 set_pte_at
================================================================================
6.3. shmem_mcopy_atomic_pte
================================================================================
6.3.1 shmem_mfill_atomic_pte(dst_mm, dst_pmd, dst_vma, dst_addr, src_addr, false)
================================================================================
6.3.1.1 page = shmem_alloc_page
================================================================================
6.3.1.2 kmap_atomic
================================================================================
6.3.1.3 copy_from_user
================================================================================
6.3.1.4 kunmap_atomic
================================================================================
6.3.1.5 pte_offset_map_lock
================================================================================
6.3.1.6 lru_cache_add_anon(page)
================================================================================
6.3.1.7 page_add_file_rmap(page)
================================================================================
6.3.1.8 set_pte_at
================================================================================
6.4 shmem_mfill_zeropage_pte
================================================================================
6.4.1 shmem_mfill_atomic_pte(dst_mm, dst_pmd, dst_vma, dst_addr, src_addr, true)
================================================================================

7. hugetlb_mcopy_atomic_pte()
================================================================================

7.1 page = alloc_huge_page()
================================================================================
7.1.1 page = dequeue_huge_page_vma()
================================================================================
7.2 copy_huge_page_from_user()
================================================================================
7.3 huge_add_to_page_cache()
================================================================================
7.4 huge_pte_lockptr()
================================================================================
7.5 page_dup_rmap()
================================================================================
7.5 hugepage_add_new_anon_rmap()
================================================================================
7.6 set_huge_pte_at()
================================================================================

0. data struct
================================================================================

0.1 userfaultfd_ctx
================================================================================
   
    userfaultfd_ctx
    +---------------------------+
    |flags                      |
    |features                   |
    |    (unsigned long)        |
    +---------------------------+
    |mm                         |
    |    (struct mm_struct*)    |
    +---------------------------+
    |mmap_changing              |
    |    (bool)                 |
    +---------------------------+
    |refcount                   |
    |    (refcount_t)           |
    +---------------------------+
    |fault_pending_wqh          |
    |fault_wqh                  |
    |fd_wqh                     |
    |event_wqh                  |
    |    (wait_queue_head_t)    |
    |                           |
    |                           |
    +---------------------------+

0.1 uffdio_copy
================================================================================
   
    uffdio_copy
    +---------------------------+
    |dst, src                   |
    |len                        |
    |    (__u64)                |
    +---------------------------+
    |mode                       |  UFFDIO_COPY_MODE_DONTWAKE
    |    (__u64)                |
    |                           |
    +---------------------------+

