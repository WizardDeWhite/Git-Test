1. usage
================================================================================
An example in 
http://man7.org/linux/man-pages/man2/userfaultfd.2.html

    // open userfaultfd
    ufd = syscall(__NR_userfaultfd, O_CLOEXEC);

    // register a fault range
    reg_struct.range.start = (uintptr_t)testarea;
    reg_struct.range.len = pagesize;
    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;
    ioctl(ufd, UFFDIO_REGISTER, &reg_struct)

    // get fault event
    poll(ufd)
    read(ufd, &msg, sizeof(msg));

    // fill the faulted page
    uffdio_copy.src = (unsigned long) page;
    uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
                                       ~(page_size - 1);
    uffdio_copy.len = page_size;
    uffdio_copy.mode = 0;
    uffdio_copy.copy = 0;
    ioctl(uffd, UFFDIO_COPY, &uffdio_copy)

2.  SYSCALL_DEFINE1(userfaultfd, int, flags)
================================================================================
2.1 anon_inode_getfd(userfaultfd_fops)
================================================================================
static const struct file_operations userfaultfd_fops = {
#ifdef CONFIG_PROC_FS
	.show_fdinfo	= userfaultfd_show_fdinfo,
#endif
	.release	= userfaultfd_release,
	.poll		= userfaultfd_poll,
	.read		= userfaultfd_read,
	.unlocked_ioctl = userfaultfd_ioctl,
	.compat_ioctl	= userfaultfd_ioctl,
	.llseek		= noop_llseek,
};


3. userfaultfd_register, UFFDIO_REGISTER
================================================================================

3.1 validate_range(mm, start, len)
================================================================================

3.2 vma = find_vma_prev(mm, start, &prev)
================================================================================

3.3 vma_can_userfault()
================================================================================

3.4 vma_merge()
================================================================================

4. userfaultfd_copy(), UFFDIO_COPY
================================================================================

4.1 validate_range
================================================================================

4.2 mmget_not_zero(mm)
================================================================================

4.2.1 atomic_inc_not_zero(mm->mm_users)
================================================================================

4.3 mcopy_atomic(ctx->mm, dst, src, len, mmap_changing)
================================================================================

4.3.1 find_vma
================================================================================

4.3.2 __mcopy_atomic_hugetlb(), handle huge page
================================================================================

4.3.2.1 huge_pte_alloc(dst_mm, dst_addr, size)
================================================================================

4.3.2.2 huge_ptep_get(dst_pte)
================================================================================

4.3.2.3 hugetlb_mcopy_atomic_pte()
================================================================================

4.3.2.4 copy_huge_page_from_user()
================================================================================

4.3.3 anon_vma_prepare(dst_vma), alloc/find anon_vma for dst_vma
================================================================================

4.3.4 mm_alloc_pmd(dst_mm, dst_addr)
================================================================================

4.3.5 pmd_read_atomic
================================================================================

4.3.6 __pte_alloc(dst_mm, dst_pmd)
================================================================================

4.3.7 mfill_atomic_pte(dst_mm, dst_pmd, dst_vma, dst_addr, src_addr, &page, zeropage)
================================================================================

4.3.7.1 mcopy_atomic_pte
================================================================================

4.3.7.2 mfill_zeropage_pte
================================================================================

4.3.7.3 shmem_mcopy_atomic_pte
================================================================================

4.3.7.4 shmem_mfill_zeropage_pte
================================================================================

4.4 put_user(ret, &user_uffdio_copy->copy)
================================================================================

4.5 wake_userfault(ctx, &range)
================================================================================

5. mfill_atomic_pte
================================================================================

5.1. mcopy_atomic_pte
================================================================================

5.1.1 page = alloc_page_vma, copy content to this page and write it to pte
================================================================================

5.1.2 kmap_atomic
================================================================================

5.1.3 copy_from_user()
================================================================================

5.1.4 kunmap_atomic
================================================================================

5.1.5 pte_offset_map_lock
================================================================================

5.1.6 page_add_new_anon_rmap(page, dst_vma, dst_addr, false)
================================================================================

5.1.7 lru_cache_add_active_or_unevictable(page, dst_vma)
================================================================================

5.1.8 set_pte_at
================================================================================

5.2. mfill_zeropage_pte
================================================================================

5.2.1 pte_offset_map_lock
================================================================================

5.2.2 set_pte_at
================================================================================

5.3. shmem_mcopy_atomic_pte
================================================================================

5.3.1 shmem_mfill_atomic_pte(dst_mm, dst_pmd, dst_vma, dst_addr, src_addr, false)
================================================================================

5.3.1.1 page = shmem_alloc_page
================================================================================

5.3.1.2 kmap_atomic
================================================================================

5.3.1.3 copy_from_user
================================================================================

5.3.1.4 kunmap_atomic
================================================================================

5.3.1.5 pte_offset_map_lock
================================================================================

5.3.1.6 lru_cache_add_anon(page)
================================================================================

5.3.1.7 page_add_file_rmap(page)
================================================================================

5.3.1.8 set_pte_at
================================================================================

5.4 shmem_mfill_zeropage_pte
================================================================================

5.4.1 shmem_mfill_atomic_pte(dst_mm, dst_pmd, dst_vma, dst_addr, src_addr, true)
================================================================================

6. hugetlb_mcopy_atomic_pte()
================================================================================

6.1 page = alloc_huge_page()
================================================================================

6.1.1 page = dequeue_huge_page_vma()
================================================================================

6.2 copy_huge_page_from_user()
================================================================================

6.3 huge_add_to_page_cache()
================================================================================

6.4 huge_pte_lockptr()
================================================================================

6.5 page_dup_rmap()
================================================================================

6.5 hugepage_add_new_anon_rmap()
================================================================================

6.6 set_huge_pte_at()
================================================================================

7. handle_userfault(), tell the polling thread one userfault happen
================================================================================

0. data struct
================================================================================

0.1 userfaultfd_ctx
================================================================================
   
    userfaultfd_ctx
    +---------------------------+
    |flags                      |
    |features                   |
    |    (unsigned long)        |
    +---------------------------+
    |mm                         |
    |    (struct mm_struct*)    |
    +---------------------------+
    |mmap_changing              |
    |    (bool)                 |
    +---------------------------+
    |refcount                   |
    |    (refcount_t)           |
    +---------------------------+
    |fault_pending_wqh          |
    |fault_wqh                  |
    |fd_wqh                     |
    |event_wqh                  |
    |    (wait_queue_head_t)    |
    |                           |
    |                           |
    +---------------------------+

0.1 uffdio_copy
================================================================================
   
    uffdio_copy
    +---------------------------+
    |dst, src                   |
    |len                        |
    |    (__u64)                |
    +---------------------------+
    |mode                       |  UFFDIO_COPY_MODE_DONTWAKE
    |    (__u64)                |
    |                           |
    +---------------------------+

