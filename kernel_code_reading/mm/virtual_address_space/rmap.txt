1. page_add_new_anon_rmap(page, vma, address, compound), new anonymous page
================================================================================
1.1 __SetPageSwapBacked(page)
================================================================================
1.2 atomic_set(compound_mapcount_ptr(page), 0), compound page
================================================================================
1.3 atomic_set(&page->_mapcount, 0), normal page
================================================================================
1.4 __page_set_anon_rmap(page, vma, address, 1)
================================================================================
1.4.1 page->mapping = anon_vma + PAGE_MAPPING_ANON
================================================================================
1.4.2 page->index = linear_page_index(vma, address);
================================================================================
1.4.2.1 (address - vma->vm_start) >> PAGE_SHIFT + vma->vm_pgoff
================================================================================

2. page_add_anon_rmap(page, vma, address, compound), anonymous page
================================================================================
2.1 do_page_add_anon_rmap(page, vma, address, flags), anonymous page
================================================================================
2.2 first = atomic_inc_and_test(compound_mapcount_ptr(page)), compound page
================================================================================
2.3 first = atomic_inc_and_test(&page->_mapcount), normal page
================================================================================
2.4 __page_set_anon_rmap(page, vma, address, )
================================================================================
2.5 __page_check_anon_rmap(page, vma, address);
================================================================================


3. page_remove_rmap(page, compound)
================================================================================
3.1 page_remove_file_rmap(page, compound), file backed page
================================================================================
3.2 page_remove_anon_compound_rmap(), compound anonymous page
================================================================================
3.2.1 atomic_add_negative(-1, compound_mapcount_ptr(page))
================================================================================
3.3 atomic_add_negative(-1, &page->_mapcount)
================================================================================

4. rmap_walk_anon(page, rwc, true/false)
================================================================================
4.1 anon_vma = page_anon_vma(page), get anon_vma from page->mapping
================================================================================
4.1.1 page = compound_head(page);
================================================================================
4.1.2 return __page_rmapping(page)
================================================================================
4.2 pgoff_start = page_to_pgoff(page);
================================================================================
4.2.1 return page_to_index(page)
================================================================================
4.3 pgoff_end = pgoff_start + hpage_nr_pages(page) - 1;
================================================================================
4.4 anon_vma_interval_tree_foreach(avc, &anon_vma->rb_root, pgoff_start, pgoff_end)
================================================================================
4.5 vma = avc->vma
================================================================================
4.6 address = vma_address(page, vma)
================================================================================
4.5 rwc->rmap_one(page, vma, address, rwc->arg) -> do the real work
================================================================================

5. page_vma_mapped_walk(pvmw), return true if page is mapped in the vma 
================================================================================
5.1 if PageHuge(pvmw->page)
================================================================================
5.2 pvmw->pte = huge_pte_off(mm, pvmw->address, page_size(page))
================================================================================
5.3 check_pte(pvmw), now check the huge pte
================================================================================
5.4 if pmd_trans_huge(pmde), huge pmd
================================================================================
5.5 
================================================================================
5.6 map_pte(pvmw), lock pte
================================================================================
5.6.1 pvmw->ptl = pte_lockptr(pvmw->vma->vm_mm, pvmw->pmd);
================================================================================
5.6.2 spin_lock(pvmw->ptl);
================================================================================
5.7 check_pte(pvmw)
================================================================================
5.7.1 pfn = pte_pfn(*pvmw->pte);
================================================================================
5.7.2 return pfn_in_hpage(pvmw->page, pfn);
================================================================================

6. page_referenced_one(page, vma, address, arg)
================================================================================
6.1 pvmw = {.page = page, .vma = vma, .address = address}
================================================================================
6.2 page_vma_mapped_walk(&pvmw)
================================================================================
6.3 pra->mapcount--, for THP may count for several map
================================================================================
6.4 pra->referenced++, several mapped count for 1
================================================================================
6.5 if (!pra->mapcount) return false
================================================================================

7. page_referenced(page, is_locked, memcg, vm_flags), return # of pte ref page
================================================================================
7.1 page_referenced_arg = {.mapcount = total_mapcount(page)}
================================================================================

8. try_to_unmap_one(page, vma, address, arg)
================================================================================
8.1 split_huge_pmd_address(vma, address, flags)
================================================================================

9. anon_vma handling
================================================================================

9.1 anon_vma_chain_link(vma, avc, anon_vma)
================================================================================
9.1.1 list_add(&avc->same_vma, &vma->anon_vma_chain), link avc to vma->anon_vma_chain
================================================================================
9.1.2 anon_vma_interval_tree_insert(avc, &anon_vma->rb_root), insert avc to anon_vma tree
================================================================================

9.2 do_anonymous_page(vmf), for the solo process, len(vma->anon_vma_chain) = 1
================================================================================
9.2.1 return 0, if (vma->anon_vma), return immediately when has already got anon_vma
================================================================================
9.2.2 __anon_vma_prepare(vma)
================================================================================
9.2.2.1 avc = anon_vma_chain_alloc()
================================================================================
9.2.2.2 anon_vma = find_mergeable_anon_vma(vma)
================================================================================
9.2.2.3 anon_vma = anon_vma_alloc()
================================================================================
9.2.2.3.1 anon_vma = kmem_cache_alloc()
================================================================================
9.2.2.3.2 anon_vma->degree = 1
================================================================================
9.2.2.3.3 anon_vma->parent = anon_vma->root = anon_vma, init to self
================================================================================
9.2.2.4 vma->anon_vma = anon_vma
================================================================================
9.2.2.5 anon_vma_chain_link(vma, avc, anon_vma)
================================================================================

9.3 copy_vma()
================================================================================
9.3.1 new_vma = vm_area_dup(vma)
================================================================================
9.3.2 anon_vma_clone(new_vma, vma)
================================================================================
9.3.3 list_for_each_entry_reverse(pavc, &vma->anon_vma_chain, same_vma)
================================================================================
9.3.4 avc = anon_vma_chain_alloc()
================================================================================
9.3.5 anon_vma = pavc->anon_vma
================================================================================
9.3.6 anon_vma_chain_link(new_vma, avc, anon_vma)
================================================================================
9.3.6.1 list_add(&avc->same_vma, &new_vma->anon_vma_chain)
================================================================================
9.3.6.2 anon_vma_interval_tree_insert(avc, &anon_vma->rb_root)
================================================================================

9.4 anon_vma_fork(vma, pvma)
================================================================================
9.4.1 anon_vma_clone(vma, pvma)
================================================================================
9.4.2 anon_vma = anon_vma_alloc()
================================================================================
9.4.3 avc = anon_vma_chain_alloc()
================================================================================
9.4.4 anon_vma->root = pvma->anon_vma->root
================================================================================
9.4.5 anon_vma->parent = pvma->anon_vma
================================================================================
9.4.6 vma->anon_vma = anon_vma
================================================================================
9.4.7 anon_vma_chain_link(vma, avc, anon_vma)
================================================================================

10. anon_vma_interval_tree
================================================================================

20. total_mapcount(page), THP not configured
================================================================================
20.1 page_mapcount(page)
================================================================================
20.1.1 atomic_read(&page->_mapcount) + 1, non-compound page
================================================================================
20.1.2 __page_mapcount(page), compound page
================================================================================
20.1.2.1 ret = atomic_read(&page->_mapcount) + 1
================================================================================
20.1.2.2 if (!PageAnon() && !PageHuge) return ret,  file THP
================================================================================
20.1.2.3 ret += atomic_read(compound_mapcount_ptr(page)) + 1
================================================================================
20.1.2.4 if (PageDoubleMap(page)) ret--
================================================================================
20.1.2.5 return ret, THP and HugePage except file THP
================================================================================

20. total_mapcount(page), THP configured
================================================================================
20.0 VM_BUG_ON_PAGE(PageTail(page), page), page must not be Tail Page
================================================================================
20.1 atomic_read(&page->mapcount) + 1, non-compound page
================================================================================
20.2 ret = compound = compound_mapcount(page)
================================================================================
20.3 if (PageHuge(page)) return compound, HugePage
================================================================================
20.4 ret += atomic_read(&page[i]._mapcount) + 1
================================================================================
20.5 if (!PageAnon(page)) return ret - compound * HPAGE_PMD_NR, file THP
================================================================================
20.6 if (PageDoubleMap(page)) ret -= HPAGE_PMD_NR
================================================================================
20.7 return ret, anonymous THP
================================================================================

0. data structure
================================================================================

0.1 page->_mapcount
================================================================================

0.2 page->mapping, page->index
================================================================================

0.3 avc whole picture
================================================================================

     +----------------------------------------------------------------------+
     |                                                                      |
     |       rb_root              rb      same_vma   anon_vma_chain         |
     |       .......................      *************************         |
     v       .                     .      *                       *         |
     av      v                 avc v      v                vma    v         |
     +-----------+             +-------------+             +-------------+  |
     |           |             |             |             |             |  |
     |           |<------------|anon_vma  vma|------------>|     anon_vma|--+
     +-----------+             +-------------+             +-------------+
             ^                     ^      ^                       ^
             .                     .      *                       *
             .......................      *************************


0.3 anon_vma_interval_tree
================================================================================
; used by rmap_walk_anon().
; And the tree is ordered by vma->vm_pgoff. For anon_vma, vm_pgoff is set to
; (addr >> PAGE_SHIFT). See do_mmap(), MAP_PRIVATE section. This means the
; anon_vma_interval_tree is ordered by page's virtual address in the
; particular process.

                        anon_vma
                     +--------------+
                     |rb            |
                     +--------------+
                             |
                             |
		     avc     v
                     +--------------+
                     |vma           |
                     |    vm_pgoff  |
                     +--------------+
                           /   \
                      /               \
        avc     /                      avc     \
        +--------------+               +--------------+
        |vma           |               |vma           |
        |    vm_pgoff  |               |    vm_pgoff  |
        +--------------+               +--------------+

0.4 anon_vma_chain
================================================================================

0.5 total_mapcount
================================================================================

Non-Compound Page

    page
    +--------------------+
    |_mapcount           |
    |                    |
    +--------------------+

Compound Page w/o THP configured

    page                        file THP               anon THP and HugePage
    +--------------------+
    |_mapcount           |      page[0]._mapcount      page[0]._mapcount        = 0 if HugePage
    |                    |                             + compound_mapcount
    +--------------------+
    |_mapcount           |
    |compound_mapcount   |
    +--------------------+

Compound Page w THP configured

    page                        Huge Page              anon THP                  file THP
    +--------------------+
    |_mapcount           |      compound_mapcount      compound_mapcount         compound_mapcount
    |                    |                             + page[0]._mapcount       + page[0]._mapcount
    +--------------------+                             + page[1]._mapcount       + page[1]._mapcount
    |_mapcount           |                             - HPAGE_PMD_NR            - compound_mapcount * HPAGE_PMD_NR
    |compound_mapcount   |
    +--------------------+
