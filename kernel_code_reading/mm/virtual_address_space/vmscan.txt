1. kswapd_init()
================================================================================
static int __init kswapd_init(void)
{
	int nid, ret;

	swap_setup();
	for_each_node_state(nid, N_MEMORY)
 		kswapd_run(nid);
	ret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,
					"mm/vmscan:online", kswapd_cpu_online,
					NULL);
	WARN_ON(ret < 0);
	return 0;
}

1.1 kswapd_run(), for each numa node
================================================================================
int kswapd_run(int nid)
{
	pg_data_t *pgdat = NODE_DATA(nid);
	int ret = 0;

	if (pgdat->kswapd)
		return 0;

	pgdat->kswapd = kthread_run(kswapd, pgdat, "kswapd%d", nid);
	if (IS_ERR(pgdat->kswapd)) {
		/* failure at boot is fatal */
		BUG_ON(system_state < SYSTEM_RUNNING);
		pr_err("Failed to start kswapd on node %d\n", nid);
		ret = PTR_ERR(pgdat->kswapd);
		pgdat->kswapd = NULL;
	}
	return ret;
}

1.2 kswapd_cpu_online(), set kswapd cpu affinity
================================================================================

2. kswapd()
================================================================================
2.1 set_cpus_allowed_ptr()
================================================================================
2.2 set_freezable()
================================================================================
2.3 kswapd_try_to_sleep()
================================================================================
2.3.1 prepare_to_wait(, TASK_INTERRUPTIBLE)
================================================================================
2.3.2 prepare_kswapd_sleep(pgdat, reclaim_order, classzone_idx), return true if kswapd is ready to sleep
================================================================================
2.3.2.1 pgdat_balanced(pgdat, reclaim_order, classzone_idx)
================================================================================
2.3.2.2 clear_pgdat_congested(pgdat)
================================================================================
2.3.3 reset_isolation_suitable(pgtad)
================================================================================
2.3.3.1 __reset_isolation_suitable(zone), clear migrate_skip and calculate zon->compact_*
================================================================================
2.3.3.1.1 __reset_isolation_pfn(zone, pfn, check_source, check_target);
================================================================================
2.3.4 wakeup_kcompactd(pgdat, alloc_order, classzone_idx)
================================================================================
2.3.4.1 wake_up_interruptible(&pgdat->kcompactd_wait)
================================================================================
2.3.5 schedule_timeout(HZ/10), sleep till timeout
================================================================================
2.3.6 finish_wait()
================================================================================
2.3.7 prepare_to_wait()
================================================================================
2.3.8 prepare_kswapd_sleep(), real sleep till woken up by others
================================================================================
2.4 balance_pgdat()
================================================================================
2.4.1 age_active_anon(pgdat, sc), balance active/inactive lru
================================================================================
2.4.1.1 inactive_is_low(lruvec, LRU_INACTIVE_ANON)
================================================================================
2.4.1.2 shrink_active_list(SWAP_CLUSTER_MAX, lruvec, sc, LRU_ACTIVE_ANON)
================================================================================
2.4.2 mem_cgroup_soft_limit_reclaim()
================================================================================
2.4.3 kswapd_shrink_node(pgdat, &sc)
================================================================================
2.4.3.1 shrink_node(pgdat, sc)
================================================================================
2.4.3.2 return sc->nr_scanned >= sc->nr_to_reclaim
================================================================================
2.4.4 allow_direct_reclaim(pgdat)
================================================================================
2.4.5 wake_up_all(&pgdat->pfmemalloc_wait)
================================================================================

3. pgdat_balanced(pgdat, order, classzone_idx), more free_pages than WMHIGH
================================================================================
3.1 mark = high_wmark_pages(zone)
================================================================================
3.2 zone_watermark_ok_safe(zone, order, mark, classzone_idx)
================================================================================
3.2.1 free_pages = zone_page_state(zone, NR_FREE_PAGES)
================================================================================
3.2.2 free_pages = zone_page_state_snapshot(zone, NR_FREE_PAGES)
================================================================================
3.2.3 __zone_watermark_ok(zone, order, mark, classzone_idx, alloc_flags, free_pages)
================================================================================

4. shrink_node(pgdat, sc)
================================================================================
4.1 target_lruvec = mem_cgroup_lruvec(sc->target_mem_cgroup, pgdat)
================================================================================
4.2 memset(&sc->nr, 0, sizeof())
================================================================================
4.3 shrink_node_memcgs(pgdat, sc)
================================================================================
4.3.1 shrink_lruvec(lruvec, sc)
================================================================================
4.3.1.1 get_scan_count(lruvec, sc, nr)
================================================================================
4.3.1.2 while (nr[LRU_INACTIVE_ANON] || nr[LRU_ACTIVE_FILE] || nr[LRU_INACTIVE_FILE]) 
================================================================================
4.3.1.3 shrink_list(lru, nr_to_scan, lruvec, sc), do reclaim
================================================================================
4.3.2 shrink_slab()
================================================================================
4.4 vmpressure(), account vm pressure
================================================================================
4.5 should_continue_reclaim()
================================================================================
4.5.1 compaction_suitable(zone, order, 0, idx)
================================================================================
4.5.2 pages_for_compaction = compact_gap(sc->order)
================================================================================
4.5.2.1 return 2UL << order;
================================================================================
4.5.3 return inactive_lru_pages > pages_for_compaction
================================================================================

5. shrink_list(lru, nr_to_scan, lruvec, sc), do reclaim
================================================================================
5.1 shrink_active_list()
================================================================================
5.1.1 spin_lock_irq(&pgdat->lru_lock)
================================================================================
5.1.2 isolate_lru_pages(, &l_hold, &nr_scanned, sc, lru)
================================================================================
5.1.2.1 __isolate_lru_page(page, mode), remove page from its LRU
================================================================================
5.1.2.1.1 ClearPageLRU(page)
================================================================================
5.1.2.2 list_move(&page->lru, dst)
================================================================================
5.1.3 spin_unlock_irq(&pgdat->lru_lock)
================================================================================
5.1.4 page = lru_to_page(&l_hold)
================================================================================
5.1.5 list_del(&page->lru)
================================================================================
5.1.6 list_add(&page->lru, &l_inactive)
================================================================================
5.1.7 spin_lock_irq(&pgdat->lru_lock)
================================================================================
5.1.8 move_pages_to_lru(lruvec, &l_active)
================================================================================
5.1.8.1 putback_lru_page(page), if !page_evictable()
================================================================================
5.1.8.1.1 lru_cache_add(page)
================================================================================
5.1.8.2 SetPageLRU(page)
================================================================================
5.1.8.3 lru = page_lru(page)
================================================================================
5.1.8.4 list_move(&page->lru, &lruvec->lists[lru])
================================================================================
5.1.8.5 if put_page_testzero()
================================================================================
5.1.8.6 del_page_from_lru_list(page, lruvec, lru)
================================================================================
5.1.9 move_pages_to_lru(lruvec, &l_inactive)
================================================================================
5.1.10 list_splice(&l_inactive, &l_active)
================================================================================
5.1.11 spin_unlock_irq(&pgdat->lru_lock)
================================================================================
5.1.12 free_unref_page_list(&l_active)
================================================================================
5.2 shrink_inactive_list(), return the # of reclaimed pages
================================================================================
5.2.1 too_many_isolated(pgdat, file, sc)
================================================================================
5.2.2 lru_add_drain()
================================================================================
5.2.3 isolate_lru_pages()
================================================================================
5.2.4 shrink_page_list(), return # of reclaimed pages
================================================================================
5.2.5 move_pages_to_lru()
================================================================================
5.2.6 free_unref_page_list()
================================================================================

0. data structure
================================================================================

0.1 pageblock_flags
================================================================================
The data stored here is enum migratetype.

   mem_section->usage->pageblock_flags[usemap_size()]
   NR_PAGEBLOCK_BITS = 4
   +----------------------------+
   |                            |
   |                            |
   +----------------------------+

0.2 pgdat
================================================================================

   pgdat
   +-------------------------------+
   |kswapd_order                   |
   |kswapd_classzone_idx           |
   |                               |
   +-------------------------------+
   |node_zones                     |
   |    (struct zone)              |
   |    +--------------------------+
   |    |compact_init_migrate_pfn  |
   |    |compact_cached_migrate_pfn|
   |    |                          |
   |    |compact_init_free_pfn     |
   |    |compact_cached_free_pfn   |
   |    |                          |
   |    |_watermark[NR_WMARK]      |  WMARK_MIN|LOW|HIGH
   |    |watermark_boost           |  init to 0 or set in boost_watermark()
   |    |                          |
   |    |lowmem_reserve[MAX_ZONES] |
   |    |                          |
   +----+--------------------------+
   |                               |
   |                               |
   +-------------------------------+


0.3 __setup_per_zone_wmarks()
================================================================================

0.3.1 WMARK_MIN
================================================================================
lowmem_pages = sum(zone_managed_pages)
_watermark[WMARK_MIN] = pages_min * (zone_managed_pages / lowmem_pages)

=>

sum(_watermark[WMARK_MIN]) = pages_min

The summation of all WMARK_MIN is pages_min.


0.3.2 WMARK_LOW|HIGH
================================================================================

     +-------------+
     |             |
     .             .
     |             |
     |             |
     +-------------+ WMARK_HIGH -+-
     |             |             ^
     |             |             d
     |             |             v
     +-------------+ WMARK_LOW  -+-
     |             |             ^
     |             |             d
     |             |             v
     +-------------+ WMARK_MIN  -+-
     |             |
     |             |
     |             |
     +-------------+

The distance between HIGH and LOW is the same as LOW and MIN, which is d here.

d = (MIN / 4) or (part of zone_managed_pages) 


0.4 setup_per_zone_lowmem_reserve()
================================================================================
    Zone0              Zone1              Zone2

    lowmem_reserve[]   lowmem_reserve[]   lowmem_reserve[]
    +-------------+    +-------------+    +-------------+
    |for 1 & 2    |    |for 2        |    |0            |
    +-------------+    +-------------+    +-------------+
    |for 1        |    |0            |    |0            |
    +-------------+    +-------------+    +-------------+
    |0            |    |0            |    |0            |
    +-------------+    +-------------+    +-------------+

For example:

Zone1.lowmem_reserve[2] = zone_managed_pages(Zone2) / ratio

Zone0.lowmem_reserve[2] = zone_managed_pages(Zone1 + Zone2) / ratio

0.5 scan_control
================================================================================

   scan_control
   +-------------------------------+
   |nodemask                       |
   |    (nodemask_t*)              |
   |target_mem_cgroup              |
   |    (mem_cgroup *)             |
   +-------------------------------+
   |may_deactivate:2               |
   |force_deactivate:2             |
   |skipped_deactivate:2           |
   |may_writepage:1                |
   |may_unmap:1                    |
   |may_swap:1                     |
   |memcg_low_reclaim:1            |
   |memcg_low_skipped:1            |
   |hibernation_mode:1             |
   |compaction_ready:1             |
   |cache_trim_mode:1              |
   |file_is_tiny:1                 |
   |                               |
   +-------------------------------+
   |order                          |
   |priorit                        |
   |reclaim_idx                    |
   |    (s8)                       |
   |nr_scanned                     |
   |nr_reclaimed                   |
   |nr_to_reclaim                  |
   |    (unsigned long)            |
   |nr                             |
   |    +--------------------------+
   |    |dirty                     |
   |    |unqueued_dirty            |
   |    |congested                 |
   |    |writeback                 |
   |    |immediate                 |
   |    |file_taken                |
   |    |taken                     |
   |    +--------------------------+
   |reclaim_state                  |
   |    (struct reclaim_state)     |
   |    +--------------------------+
   |    |reclaimed_slab            |
   |    +--------------------------+
   |                               |
   |                               |
   +-------------------------------+
