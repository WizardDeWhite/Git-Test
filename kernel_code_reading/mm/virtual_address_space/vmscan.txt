1. kswapd_init()
================================================================================
static int __init kswapd_init(void)
{
	int nid, ret;

	swap_setup();
	for_each_node_state(nid, N_MEMORY)
 		kswapd_run(nid);
	ret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,
					"mm/vmscan:online", kswapd_cpu_online,
					NULL);
	WARN_ON(ret < 0);
	return 0;
}

1.1 kswapd_run(), for each numa node
================================================================================
int kswapd_run(int nid)
{
	pg_data_t *pgdat = NODE_DATA(nid);
	int ret = 0;

	if (pgdat->kswapd)
		return 0;

	pgdat->kswapd = kthread_run(kswapd, pgdat, "kswapd%d", nid);
	if (IS_ERR(pgdat->kswapd)) {
		/* failure at boot is fatal */
		BUG_ON(system_state < SYSTEM_RUNNING);
		pr_err("Failed to start kswapd on node %d\n", nid);
		ret = PTR_ERR(pgdat->kswapd);
		pgdat->kswapd = NULL;
	}
	return ret;
}

1.2 kswapd_cpu_online(), set kswapd cpu affinity
================================================================================

2. kswapd()
================================================================================
2.1 set_cpus_allowed_ptr()
================================================================================
2.2 set_freezable()
================================================================================
2.3 kswapd_try_to_sleep()
================================================================================
2.4 balance_pgdat()
================================================================================

3. kswapd_try_to_sleep(pgdat, alloc_order, reclaim_order, classzone_idx)
================================================================================
3.1 prepare_to_wait(, TASK_INTERRUPTIBLE)
================================================================================
3.2 prepare_kswapd_sleep(), return true if kswapd is ready to sleep
================================================================================
3.3 reset_isolation_suitable(pgtad)
================================================================================
3.3.1 __reset_isolation_suitable(zone), clear migrate_skip and calculate zon->compact_*
================================================================================
3.3.1.1 __reset_isolation_pfn(zone, pfn, check_source, check_target);
================================================================================
3.4 wakeup_kcompactd(pgdat, alloc_order, classzone_idx)
================================================================================
3.4.1 wake_up_interruptible(&pgdat->kcompactd_wait)
================================================================================
3.5 schedule_timeout(HZ/10), sleep till timeout
================================================================================
3.6 finish_wait()
================================================================================
3.7 prepare_to_wait()
================================================================================
3.8 prepare_kswapd_sleep(), real sleep till woken up by others
================================================================================

4. balance_pgdat(pgdat, order, classzone_idx), reclaim pages
================================================================================

0. data structure
================================================================================

0.1 pageblock_flags
================================================================================
The data stored here is enum migratetype.

   mem_section->usage->pageblock_flags[usemap_size()]
   NR_PAGEBLOCK_BITS = 4
   +----------------------------+
   |                            |
   |                            |
   +----------------------------+

