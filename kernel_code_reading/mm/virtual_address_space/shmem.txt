1. shmem_get_inode(sb, dir, mode, dev, flags)
================================================================================
vma->vm_ops = &shmem_vm_ops;
inode->i_mapping->a_ops = &shmem_aops;
inode->i_fop = &shmem_file_operations;
inode->i_op = &shmem_inode_operations;
inode->i_op = &shmem_dir_inode_operations;

2. how a shared anonymous vma link to shmem
================================================================================

mmap(0, len, prot, MAP_SHARED, fd, offset)
do_mmap()
    addr = get_unmapped_area(file, addr, len, pgoff, flags);
        get_area = shmem_get_unmapped_area; if (flags & MAP_SHARED)
        addr = get_area(file, addr, len, pgoff, flags);
        return addr
    vm_flags |= VM_SHARED | VM_MAYSHARE;
    mmap_region()
        shmem_zero_setup(vma)
            file = shmem_kernel_file_setup("dev/zero", size, vma->vm_flags);
                inode = shmem_get_inode()
                    inode->i_mapping->a_ops = &shmem_aops;
                    inode->i_op = &shmem_inode_operations;
                    inode->i_fop = &shmem_file_operations;
            vma->vm_file = file;
            vma->vm_ops = &shmem_vm_ops;

3. shmem_zero_setup(vma), called by mmap
================================================================================
3.1 file = shmem_kernel_file_setup("dev/zero", size, vma->vm_flags);
================================================================================
3.1.1 inode = shmem_get_inode()
================================================================================
3.1.1.1 inode->i_mapping->a_ops = &shmem_aops;
================================================================================
3.1.1.2 inode->i_op = &shmem_inode_operations;
================================================================================
3.1.1.3 inode->i_fop = &shmem_file_operations;
================================================================================
3.1.2 file = alloc_file_pseudo(inode, mnt, name, O_RDWR, &shmem_file_operations)
================================================================================
3.2 vma->vm_file = file;
================================================================================
3.3 vma->vm_ops = &shmem_vm_ops;
================================================================================

4. shmem_fault, fault in a shared anonymous page
================================================================================
4.1 err = shmem_getpage_gfp(inode, vmf->pgoff, &vmf->page, sgp, gfp, vma, vmf, &ret);
================================================================================
4.1.1 mapping = inode->i_mapping;
================================================================================
4.1.2 info = SHMEM_I(inode)
================================================================================
4.1.3 sbinfo = SHMEM_SB(inode->i_sb)
================================================================================
4.1.4 page = find_lock_entry(mapping, pgoff)
================================================================================
4.1.4.1 page = find_get_entry(mapping, pgoff)
================================================================================
4.1.4.2 lock_page(page)
================================================================================
4.1.5 shmem_swapin_page(inode, pgoff, &page, ), if in swap
================================================================================
4.1.6 page = shmem_alloc_and_acct_page(gfp, inode, pgoff, true/false), alloc new
================================================================================
4.1.6.1 page = shmem_alloc_page(gfp, info, index)
================================================================================
4.1.6.2 __SetPageLocked(page)
================================================================================
4.1.6.3 __SetPageSwapBacked(page)
================================================================================
4.1.7 shmem_add_to_page_cache(page, inode->i_mapping, ), add to shmem cache
================================================================================
4.1.7.1 page->mapping = mapping
================================================================================
4.1.8 lru_cache_add_anon(page)
================================================================================

5. shmem_swapin_page(inode, pgoff, &page, ), if in swap
================================================================================
5.1 swap = radix_to_swp_entry(*pagep)
================================================================================
5.2 page = lookup_swap_cache(swap, NULL, 0), try swap cache
================================================================================
5.3 page = shmem_swapin(swap, gfn, info, ), read from disk
================================================================================
5.3.1 page = swap_cluster_readahead(swap, gfp, &vmf) -> read_swap_cache_async()
================================================================================
5.3.1.1 new_page = alloc_page_vma()
================================================================================
5.3.1.2 swapcache_prepare(swap), mark SWAP_HAS_CACHE
================================================================================
5.3.1.3 __SetPageLocked(new_page);
================================================================================
5.3.1.4 __SetPageSwapBacked(new_page);
================================================================================
5.3.1.5 add_to_swap_cache(new_page, entry, gfp_mask & GFP_KERNEL);
================================================================================
5.3.1.6 lru_cache_add_anon(new_page)
================================================================================
5.4 shmem_add_to_page_cache(page, inode->i_mapping), add to shmem cache
================================================================================
5.5 delete_from_swap_cache(page), remove from swap cache
================================================================================
5.5.1 put_swap_page(page, entry)
================================================================================
5.6 swap_free(swap)
================================================================================

6. shmem_writepage(), called by pageout by mapping->a_ops->writepage(page, )
================================================================================
6.1 mapping = page->mapping 
================================================================================
6.2 index = page->index
================================================================================
6.2 inode = mapping->host
================================================================================
6.3 swap = get_swap_page(page), with SWAP_HAS_CACHE set
================================================================================
6.4 list_add(&info->swaplist, &shmem_swaplist), add to shmem_swaplist
================================================================================
6.5 add_to_swap_cache(page, swap, )
================================================================================
6.6 swap_shmem_alloc()
================================================================================
6.6.1 __swap_duplicate(entry, SWAP_MAP_SHMEM);
================================================================================
6.7 shmem_delete_from_page_cache(page, swp_to_radix_entry(swap));
================================================================================
6.7.1 shmem_replace_entry(mapping, page->index, page, radswap), replace with swap entry
================================================================================
6.7.2 put_page(page)
================================================================================
6.8 swap_writepage(page, wbc);
================================================================================

0. Note
================================================================================
Mel Gorman's note
https://www.kernel.org/doc/gorman/html/understand/understand015.html

An example on Sys V shmem
http://www.cs.kent.edu/~ruttan/sysprog/lectures/shmem/shared-mem-with-semaphore.c


0. data struct
================================================================================
0.1 shmem_vm_ops
================================================================================
static const struct vm_operations_struct shmem_vm_ops = {
	.fault		= shmem_fault,
	.map_pages	= filemap_map_pages,
#ifdef CONFIG_NUMA
	.set_policy     = shmem_set_policy,
	.get_policy     = shmem_get_policy,
#endif
};
0.2 shmem_vm_ops
================================================================================
static const struct file_operations shmem_file_operations = {
	.mmap		= shmem_mmap,
	.get_unmapped_area = shmem_get_unmapped_area,
#ifdef CONFIG_TMPFS
	.llseek		= shmem_file_llseek,
	.read_iter	= shmem_file_read_iter,
	.write_iter	= generic_file_write_iter,
	.fsync		= noop_fsync,
	.splice_read	= generic_file_splice_read,
	.splice_write	= iter_file_splice_write,
	.fallocate	= shmem_fallocate,
#endif
};

0.3 shmem_inode_info
================================================================================

0.4 the process of how shmem pageout
================================================================================

   shrink_page_list()
       try_to_unmap(page, 0)
           try_to_unmap_one(page, vma, 0)
	       page_remove_rmap()
       pageout(page, mapping, sync_writeback) if PageDirty(page)
           SetPageReclaim(page)
           mapping->a_ops->writepage(page, &wbc) = shmem_writepage()
           get_swap_page(page)                                   --- set SWAP_HAS_CACHE
           add_to_swap_cache(page, swap, )
               page_ref_add(page, nr)
               SetPageSwapCache(page)                            --- set PageSwapCache
           swap_shmem_alloc(swap)                                --- set SWAP_MAP_SHMEM
           shmem_delete_from_page_cache(page, swp_to_radix_entry(swap))
               page->mapping = NULL
           swap_writepage(page, wbc)
       try_to_free_swap(page) or __remove_mapping()
           __delete_from_swap_cache(page, entry)
               xas_store(&xas, NULL);
               ClearPageSwapCache(page)                          --- clear PageSwapCache
           put_swap_page(page, entry)                            --- clear SWAP_HAS_CACHE
           page_ref_sub(page, nr)


   shmem_fault
       err = shmem_getpage_gfp(inode, vmf->pgoff, &vmf->page, sgp, gfp, vma, vmf, &ret);
           mapping = inode->i_mapping;
           info = SHMEM_I(inode)
           sbinfo = SHMEM_SB(inode->i_sb)
           page = find_lock_entry(mapping, pgoff)
               page = find_get_entry(mapping, pgoff)
               lock_page(page)
           shmem_swapin_page(inode, pgoff, &page, ), if in swap
               swap = radix_to_swp_entry(*pagep)
               page = lookup_swap_cache(swap, NULL, 0), try swap cache
               page = shmem_swapin(swap, gfn, info, ), read from disk
                   page = swap_cluster_readahead(swap, gfp, &vmf)
                       __read_swap_cache_async()
                           new_page = alloc_page_vma()
                           swapcache_prepare(swap),                      --- set SWAP_HAS_CACHE
                           __SetPageLocked(new_page);
                           __SetPageSwapBacked(new_page);
                           add_to_swap_cache(new_page, entry, gfp_mask & GFP_KERNEL);
                               page_ref_add(page, nr);
                               SetPageSwapCache(page)                    --- set PageSwapCache
                           lru_cache_add_anon(new_page)
               shmem_add_to_page_cache(page, inode->i_mapping), add to shmem cache
               delete_from_swap_cache(page), remove from swap cache
                   ClearPageSwapCache(page)                              --- clear PageSwapCache
                   put_swap_page(page, entry)
                       __swap_entry_free_locked(, , SWAP_HAS_CACHE)      --- clear SWAP_HAS_CACHE
               swap_free(swap)
                   __swap_entry_free(p, swap)
                       usage = __swap_entry_free_locked(p, offset, 1)    --- clear SWAP_MAP_SHMEM
                       free_swap_slot(entry), if (!usage)
           page = shmem_alloc_and_acct_page(gfp, inode, pgoff, true/false), alloc new
               page = shmem_alloc_page(gfp, info, index)
               __SetPageLocked(page)
               __SetPageSwapBacked(page)
           shmem_add_to_page_cache(page, inode->i_mapping, ), add to shmem cache
               page->mapping = mapping
           lru_cache_add_anon(page)

