1. swapfile_init()
================================================================================
1.1 swap_avail_heads = kmalloc_array(nr_node_ids, )
================================================================================
1.2 plist_head_init(&swap_avail_heads[nid])
================================================================================


2. swapon, SYSCALL_DEFINE2
================================================================================
2.1 p = alloc_swap_info()
================================================================================
2.2 INIT_WORK(&p->discard_work, swap_discard_work)
================================================================================
2.3 swap_file = file_open_name(name, )
================================================================================
2.4 p->swap_file = swap_file
================================================================================
2.5 mapping = swap_file->f_mapping
================================================================================
2.6 inode = mappint->host
================================================================================
2.7 claim_swapfile(p, inode)
================================================================================
2.7.1 setup p->bdev and lock inode
================================================================================
2.8 page = read_mapping_page(mapping, 0, swap_file), read head into page
================================================================================
2.8.1 read_cache_page(mapping, 0, NULL, swap_file), read into page cache
================================================================================
2.8.1.1 a long way to add page into address_space, set page->[mapping|index]
================================================================================
2.9 swap_header = kmap(page), swap_header points to virtual address of page
================================================================================
2.10 maxpages = read_swap_header(p, swap_header, inode), parse swap_header
================================================================================
2.10.1 maxpages = max_swapfile_size(), pages allowed for swap device
================================================================================
2.10.2 last_page = swap_header->info.last_page
================================================================================
2.10.3 p->highest_bit = maxpages - 1, maxpages must be order 2?
================================================================================
2.11 swap_map = vzalloc(maxpages), each page has a slot
================================================================================
2.12 swap_cgroup_swapon(p->type, maxpages)
================================================================================
2.13 nr_extents = setup_swap_map_and_extents(p, swap_header, swap_map, cluster_info, maxpages, &span)
================================================================================
2.13.1 cluster_list_init(&p->free_cluster)
================================================================================
2.13.2 cluster_list_init(&p->discard_clusters)
================================================================================
2.13.3 setup_swap_extents(p, span)
================================================================================
2.14 init_swap_address_space(p->type, maxpages)
================================================================================
2.14.1 nr = DIV_ROUND_UP(maxpages, SWAP_ADDRESS_SPACE_PAGES), one swap has N address_space
================================================================================
2.14.2 spaces = kvcalloc(nr, sizeof(struct address_space), )
================================================================================
2.14.3 space = spaces + i;
================================================================================
2.14.4 space->a_ops = &swap_aops
================================================================================
2.14.5 nr_swapper_spaces[type] = nr
================================================================================
2.14.6 swapper_spaces[type] = spaces, save those space to global variable
================================================================================
2.15 enable_swap_info(p, prio, swap_map, cluster_info, frontswap_map)
================================================================================
2.15.1 setup_swap_info(p, prio, swap_map, cluster_info)
================================================================================
2.15.2 _enable_swap_info(p)
================================================================================
2.15.2.1 plist_add(&p->list, &swap_active_head)
================================================================================
2.15.2.2 add_to_avail_list(p)
================================================================================
2.16 wake_up_interruptible(&proc_poll_wait)
================================================================================
2.17 enable_swap_slots_cache(), enable swap cache
================================================================================
2.17.1 __reenable_swap_slots_cache()
================================================================================
2.17.1.1 swap_slot_cache_enabled = has_usable_swap();
================================================================================

3. swapoff(specialfile)
================================================================================
3.1 pathname = getname(specialfile)
================================================================================
3.2 victim = file_open_name(pathname, )
================================================================================
3.3 mapping = victim->f_mapping
================================================================================
3.4 if (p->swap_file->f_mapping == mapping), get swap_info_struct from swap_active_head
================================================================================
3.5 del_from_avail_list(p), remove from swap_avail_heads
================================================================================
3.6 plist_del(&p->list, &swap_active_head), remove from swap_active_head
================================================================================
3.7 p->flags &= ~SWP_WRITEOK, remove writable flag
================================================================================
3.8 disable_swap_slots_cache_lock();
================================================================================
3.8.1 swap_slot_cache_enabled = false;
================================================================================
3.8.2 __drain_swap_slots_cache(SLOTS_CACHE|SLOTS_CACHE_RET) -> drain_slots_cache_cpu(cpu, type, false)
================================================================================
3.8.2.1 swapcache_free_entries(), free per cpu swap_slots_cache
================================================================================
3.9 try_to_unuse(p->type, false, 0)
================================================================================
3.9.1 unuse_mm(mm, type, )
================================================================================
3.9.1.1 unuse_vma(mm, type, ) -> unuse_pte_range()
================================================================================
3.10 reenable_swap_slots_cache_unlock()
================================================================================
3.10.1 swap_slot_cache_enabled = has_usable_swap();
================================================================================
3.11 p->flags &= ~SWP_VALID;		/* mark swap device as invalid */
================================================================================
3.12 flush_work(&p->discard_work);
================================================================================
3.13 destroy_swap_extents(p)
================================================================================
3.14 free_swap_count_continuations(p), free continuation page
================================================================================

3. swap_discard_work() -> swap_do_scheduled_discard(si), free page and put back to free list
================================================================================
3.1 cluster_list_del_first(&si->discard_clusters, info), remove from list
================================================================================
3.2 discard_swap_cluster(si, idx * SWAPFILE_CLUSTER, SWAPFILE_CLUSTER)
================================================================================
3.2.1 blkdev_issue_discard(si->bdev, start_block, nr_blocks, )
================================================================================
3.3 __free_cluster(si, idx)
================================================================================
3.4 memset(si->swap_map + idx * SWAPFILE_CLUSTER, 0, SWAPFILE_CLUSTER)
================================================================================

4. swap_readpage/writepage
================================================================================

5. get_swap_pages(n_goal, swp_entries[], entry_size)
================================================================================
5.1 size = swap_entry_size(entry_size)
================================================================================
5.2 atomic_long_sub(n_goal * size, &nr_swap_pages)
================================================================================
5.3 node = numa_node_id()
================================================================================
5.4 plist_for_each_entry_safe(si, next, &swap_avail_heads[node], avail_lists[node]) {
================================================================================
5.5 swap_alloc_cluster(si, swp_entries), whole cluster only for THP
================================================================================
5.5.1 idx = cluster_list_first(&si->free_cluster)
================================================================================
5.5.2 alloc_cluster(si, idx), take it from free_clusters
================================================================================
5.5.3 swap_range_alloc(si, offset, SWAPFILE_CLUSTER)
================================================================================
5.5.4 *slot = swp_entry(si->type, offset)
================================================================================
5.6 scan_swap_map_slots(si, SWAP_HAS_CACHE, n_goal, swp_entries)
================================================================================
5.6.1 scan_base = offset = si->cluster_next
================================================================================
5.6.2 scan_swap_map_try_ssd_cluster(si, &offset, &scan_base), ssd case
================================================================================
5.6.3 scan_swap_map_ssd_cluster_conflict(si, offset)
================================================================================
5.6.4 __try_to_reclaim_swap(si, offset, TTRS_ANYWAY)
================================================================================
5.6.4.1 entry = swp_entry(si->type, offset)
================================================================================
5.6.4.2 page = find_get_page(swap_address_space(entry), offset)
================================================================================
5.6.5 si->swap_map[offset] = usage
================================================================================
5.6.6 inc_cluster_info_page(si, si->cluster_info, offset)
================================================================================
5.6.7 swap_range_alloc(si, offset, 1)
================================================================================
5.6.8 swp_entries[n_ret++] = swp_entry(si->type, offset)
================================================================================
5.6.9 return n_ret
================================================================================

6. swapin_readahead(entry, gfp_mask, vmf)
================================================================================
6.1 swap_vma_readahead(entry, gfp_mask, vmf)
================================================================================
6.2 swap_cluster_readahead(entry, gfp_mask, vmf)
================================================================================
6.2.1 offset = swp_offset(entry)
================================================================================
6.2.2 mask = swapin_nr_pages(offset) - 1
================================================================================
6.2.3 page = __read_swap_cache_async(entry, gfp, vma, addr, &page_allocated)
================================================================================
6.2.4 swap_readpage(page, false)
================================================================================

7. swap_duplicate(entry)
================================================================================
7.1 __swap_duplicate(entry, 1)
================================================================================
7.1.1 swap_count_continued(p, offset, count), core function to manipulate inc/des
================================================================================
7.2 add_swap_count_continuation(entry, GFP)
================================================================================

8. unuse_pte_range(vma, pmd, addr, end, type, )
================================================================================
8.1 page = swapin_readahead(entry, GFP_HIGHUSER_MOVABLE, &vmf)
================================================================================
8.2 unuse_pte(vma, pmd, addr, entry, page), replace swp_entry with real pte
================================================================================
8.2.1 pte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);
================================================================================
8.2.2 set_pte_at(vma->vm_mm, addr, pte, pte_mkold(mk_pte(page, vma->vm_page_prot)));
================================================================================
8.2.3 swap_free()
================================================================================
8.2.4 activate_page(page)
================================================================================
8.3 try_to_free_swap(page)
================================================================================
8.3.1 delete_from_swap_cache(page)
================================================================================
8.3.1.1 __delete_from_swap_cache(page, entry)
================================================================================
8.3.1.2 put_swap_page(page, entry)
================================================================================

8. swap cache and swap entry
================================================================================
There are two operations on swap:

  a) swap entry: no corresponding page
  b) swap cache: with corresponding page

From the following commit, it reveals more detail.

    355cfa73ddff 2009-06-16 mm: modify swap_map and add SWAP_HAS_CACHE flag

This looks: swap cache = swap entry + page cache. In that commit, we can see
related allocation and release functions respectively.

Allocation:

  a) swap entry: scan_swap_map(si, SWAP_MAP)
  b) swap cache: scan_swap_map(si, SWAP_CACHE)

Release:

  a) swap entry: swap_entry_free(p, entry, SWAP_MAP)
  b) swap cache: swap_entry_free(p, entry, SWAP_CACHE)

8.1 swap allocation & release at commit 355cfa73ddff mm: modify swap_map and add SWAP_HAS_CACHE flag
================================================================================

8.1.1 swap cache allocation & release
================================================================================

    add_to_swap(), called in vmscan -> shrink_page_list
       entry = get_swap_page()
          scan_swap_map(si, SWAP_CACHE)       --- allocate
       add_to_swap_cache(page, entry, ), add page to space_address
       swapcache_free(entry, NULL)           --- release
          swap_entry_free(p, entry, SWAP_CACHE);

8.1.2 swap entry allocation & release
================================================================================

    alloc_swapdev_block(swap)
       offset = swap_offset(get_swap_page_of_type(swap)),   --- allocate
       swap_free(swp_entry(swap, offset))
          swap_entry_free(p, entry, SWAP_MAP)

8.2 swap allocation & release at commit bb6d3fb354c5 Linux 5.6-rc1
================================================================================

8.2.1 swap cache allocation & release
================================================================================

   add_to_swap()
      entry = get_swap_page()
         refill_swap_slots_cache()     --- refill swap cache's cache with bunch swap slots
             get_swap_pages(SWAP_SLOTS_CACHE_SIZE)
         get_swap_pages(1)             --- entries allocated is marked SWAP_HAS_CACHE
             swap_alloc_cluster()
                 map[i] = SWAP_HAS_CACHE
             scan_swap_map_slots(, SWAP_HAS_CACHE, )
      add_to_swap_cache(page, entry, )
      put_swap_page(page, entry)       --- release for a particular page


8.2.2 swap entry allocation & release
================================================================================

 alloc_swapdev_block(swap)
    offset = swap_offset(get_swap_page_of_type(swap)),   --- allocate
       scan_swap_map(si, 1)
          scan_swap_map_slots(si, usage, 1, &entry)
    swap_free(swp_entry(swap, offset))                   --- release
       swap_entry_free(p, entry, SWAP_MAP)               --- release only 1 entry
          p->swap_map[swp_offset(entry)] = 0

8.3 release swap entry
================================================================================

8.3.1 swap_free(entry)
================================================================================

    swap_free(entry)
        p = _swap_info_get(entry);
        __swap_entry_free(p, entry)
            usage = __swap_entry_free_locked(p, offset, 1);
            free_swap_slot(entry), if (!usage)
                cache->slots_ret[cache->n_ret++] = entry;
                or
                swapcache_free_entries(&entry, 1)

8.3.2 free_swap_and_cache(entry)
================================================================================

    free_swap_and_cache(entry)
        __swap_entry_free(p, entry)
            usage = __swap_entry_free_locked(p, offset, 1)
            free_swap_slot(entry), if (!usage)
                cache->slots_ret[cache->n_ret++] = entry;
                or
                swapcache_free_entries(&entry, 1)
        __try_to_reclaim_swap(p, swp_offset(entry), ), if usage == HAS_CACHE
            page = find_get_page(swap_address_space(entry), offset)
            try_to_free_swap(page)
                delete_from_swap_cache(page)
                    __delete_from_swap_cache(page, entry);
                    put_swap_page(page, entry)
                        usage = __swap_entry_free_locked(p, offset, SWAP_HAS_CACHE)
                        free_swap_slot(entry), if (!usage)
            put_page(page)

8.3.3 put_swap_page(page, entry)
================================================================================
called after remove page from swap cache to clear SWAP_HAS_CACHE

    put_swap_page(page, entry)
        __swap_entry_free_locked(si, offset + i, SWAP_HAS_CACHE), clear HAS_CACHE
        free_swap_slot(entry) if usage == 0
            swapcache_free_entries(&entry, 1)
                swap_entry_free(p, entries[]), clear swap_map
                    p->swap_map[offset] = 0;

9. The process of how swap cache works
================================================================================

   shrink_page_list()
       add_to_swap(page)
           get_swap_page()
               get_swap_pages(1, )                               --- set SWAP_HAS_CACHE
           add_to_swap_cache
               page_ref_add(page, nr)
               SetPageSwapCache(page)                            --- set PageSwapCache
               xas_store(&xas, page)
           SetPageDirty(page)
       try_to_unmap(page, 0)
           try_to_unmap_one(page, vma, 0)
	       ptep_get_and_clear(mm, address, pvmw.pte)
	       swap_duplicate()                                  --- inc swap_map
               set_pte_at(mm, address, pvmw.pte, swp_pte)
	       page_remove_rmap()
       pageout(page, mapping, sync_writeback) if PageDirty(page)
           SetPageReclaim(page)
           mapping->a_ops->writepage(page, &wbc) = swap_aops
       try_to_free_swap(page) or __remove_mapping()
           __delete_from_swap_cache(page, entry)
               xas_store(&xas, NULL);
               ClearPageSwapCache(page)                          --- clear PageSwapCache
           put_swap_page(page, entry)                            --- clear SWAP_HAS_CACHE
           page_ref_sub(page, nr)

   do_swap_page(vmf)
       entry = pte_to_swp_entry(vmf->orig_pte);
       page = lookup_swap_cache(entry, vma, vmf->address);
       if (!page), not in swap cache, alloc and add it
           page = alloc_page_vma()                               --- no SWAP_HAS_CACHE
           or
           page = swapin_readahead() -> __read_swap_cache_async()
               new_page = alloc_page_vma()
               swapcache_prepare(entry)                          --- set SWAP_HAS_CACHE
               __SetPageLocked(new_page)
               __SetPageSwapBacked(new_page)
               add_to_swap_cache(new_page, entry)
                   page_ref_add(page, nr)
                   SetPageSwapCache(page)                        --- set PageSwapCache
                   xas_store(&xas, page)
       swap_free(entry)                                          --- dec swap_map
       try_to_free_swap(page)                                    --- try to return swap_map

9.1 shmem case
================================================================================
    shmem_writepage()
        swap = get_swap_page(page)
        add_to_swap_cache(page, swap, )
        swap_shmem_alloc(swap)

0. /proc/swaps
================================================================================

0.0 add your own swap file
================================================================================
# create a file with 256M
sudo dd if=/dev/zero of=myswap bs=32k count=8192
# format myswap to swap file
sudo mkswap myswap
# enable it
sudo swapon myswap


0.1 procswaps_init()
================================================================================
0.1.1 proc_create("swaps", 0, NULL, &swaps_proc_ops)
================================================================================

0.2 swaps_open(inode, file)
================================================================================
0.2.1 seq_open(file, &swaps_op)
================================================================================
0.2.2 seq = file->private_data
================================================================================

0.3 swap_start(struct seq_file *swap, loff_t *pos), return a swap_info_struct
================================================================================
0.3.1 mutex_lock(&swapon_mutex)
================================================================================
0.3.2 return SEQ_START_TOKEN if (!*pos)
================================================================================

0.4 swap_show(struct seq_file *swap, void *v)
================================================================================
0.4.1 file = si->swap_file
================================================================================
0.4.2 len = seq_file_path(swap, file, " \t\n")
================================================================================


0. data structure
================================================================================
global variables

struct address_space *swapper_spaces[MAX_SWAPFILES] __read_mostly;
static unsigned int nr_swapper_spaces[MAX_SWAPFILES] __read_mostly;

DEFINE_SPINLOCK(swap_lock);
struct swap_info_struct *swap_info[MAX_SWAPFILES];
static unsigned int nr_swapfiles;


PLIST_HEAD(swap_active_head);
static struct plist_head *swap_avail_heads;

0.1 swap_info_struct
================================================================================



                                          0     1              nr_swapfiles       MAX_SWAPFILES -1
                                          |     |                 |                 |
                                          v     v                 v                 v
         struct swap_info_struct       +-----+-----+-----+-----+-----+-----+-----+-----+
          *swap_info[MAX_SWAPFILES]    |     |     |     |     |     |     |     |     |
                                       |     |     |     |     |     |     |     |     |
                                       +-----+-----+-----+-----+-----+-----+-----+-----+
      
         struct address_space          +-----+-----+-----+-----+-----+-----+-----+-----+
       *swapper_space[MAX_SWAPFILES]   |     |     |     |     |     |     |     |     |
                                       |     |     |     |     |     |     |     |     |
                                       +-----+-----+-----+-----+-----+-----+-----+-----+
      
         unsigned int                  +-----+-----+-----+-----+-----+-----+-----+-----+
       nr_swapper_spaces[MAX_SWAPFILES]|     |     |     |     |     |     |     |     |
                                       |     |     |     |     |     |     |     |     |
                                       +-----+-----+-----+-----+-----+-----+-----+-----+
                                                      ^
                                                      |
                                                      |
                                                      +----------------------+
                                                                             |
                                                                             |
                                                                             |
                                       struct swap_info_struct               |
                                       +--------------------------------+    |
                                       |type                         ---|----+
                                       |                                | index in swap_info,
                                       |                                | swapper_spaces, nr_swapper_spaces
                                       |                                |
                                       |flags                           | SWP_USED
                                       |                                |
                                       |prio                            |
                                       |    (signed short)              |
      swap_active_head      <--->      |list                            |
      swap_avail_heads[]    <--->      |avail_lists[0]                  |
                                       |    (struct plist_node)         |
                                       |    +---------------------------+
                                       |    |prio                       | = -prio
                                       |    |     (int)                 |
                                       |    |node_list                  |
                                       |    |prio_list                  |
                                       |    |     (struct list_head)    |
                                       |    +---------------------------+
                                       |    (signed char)               |
                                       |discard_work                    | = swap_discard_work
                                       |    (struct work_struct)        |
                                       |swap_file                       |
                                       |    (struct file *)             |
                                       |                                |
                                       |max                             | = maxpages
                                       |pages                           | = nr_good_pages real available pages
                                       |inuse_pages                     | = current used pages
                                       |                                |
                                       |highest_bit                     |    ----------------------+
                                       |lowest_bit                      |    ----+                 |
                                       |                                |        |                 |
                                       |                                |  0     v                 v  maxpages
                                       |swap_map                        | [  |  |  |  |  |  |  |  |  |  ]
                                       |    (char *)                    |               ^
                                       |                                |               |
                                       |cluster_next                    |    -----------+     indicate next allocation
                                       |cluster_nr                      |
                                       |    (unsigned int)              |
                                       |                                |
                                       |percpu_cluster                  |
                                       |    (struct percpu_cluster *)   |
                                       |    +---------------------------+
                                       |    |index                      |
                                       |    |   (swap_cluster_info)     |
                                       |    |next                       |
                                       |    |   (unsigned int)          |
                                       |    +---------------------------+
                                       |                                |
                                       |cluster_info                    | [maxpages/SWAPFILE_CLUSTER]
                                       |    a block of swap disk space  | 
                                       |    with SWAPFILE_CLUSTER pages |
                                       |    this is a array.            |
                                       |    Only valid for SSD          |
                                       |                                |
                                       |    (swap_cluster_info*)        |
                                       |    +---------------------------+
                                       |    |lock                       |
                                       |    |    (spinlock_t)           |   +---------+   +---------+   +---------+   +---------+
                                       |    |data:24                    |   |1        |   |3        |   |count    |   |         |
                                       |    |flags:8                    |   |FREE     |   |FREE     |   |         |   |FREE     |
                                       |    |    (unsigned int)         |   +---------+   +---------+   +---------+   +---------+
                                       |    |                           |    ^      |       ^     |                     ^
                                       |    +---------------------------+    |      |       |     |                     |
                                       |                                |    |      +-------+     +---------------------+
                                       |free_clusters                   |    |                                          |
                                       |discard_clusters                |    |                                          |
                                       |    (swap_cluster_list)         |    |                                          |
                                       |    +---------------------------+    |                                          |
                                       |    |head                     --|----+                                          |
                                       |    |tail                       |                                               |
                                       |    |   (swap_cluster_info)   --|-----------------------------------------------+
                                       |    |                           |
                                       |    +---------------------------+
                                       |                                |
                                       |                                |
                                       |                                |
                                       |swap_extent_root                | extent rbtree
                                       |    (struct rb_root)            | seems to be used by bdev
                                       |    +---------------------------+ from page to sector
                                       |    |                           |
                                       |    |start_page                 |
                                       |    |start_block                |
                                       |    |nr_pages                   |
                                       |    |                           |
                                       |    +---------------------------+
                                       |                                |
                                       |                                |
                                       |                                |
                                       |                                |
                                       +--------------------------------+


0.2 address_space
================================================================================

         struct address_space
         +--------------------------------+
         |host                            |
         |     (struct inode *)           |
         |i_pages                         |  cached pages
         |     (struct xarray)            |
         |i_mmap                          |
         |     (struct rb_root_cached)    |  tree of mapping
         |                                |
         |                                |
         |                                |
         |a_ops                           |  = swap_aops
         |     (address_space_operation)  |
         +--------------------------------+


0.3 swap_header
================================================================================

         swap_header
         +--------------------------------+
         |bootbits[1024]                  |
         |     (char)                     |
         |version                         |
         |last_page                       |
         |nr_badpages                     |
         |     (__u32)                    |
         |sws_uuid[16]                    |
         |sws_volume[16]                  |
         |     (unsigned char)            |
         |padding[117]                    |
         |badpages[1]                     |  [nr_badpages]
         |     (__u32)                    |
         +--------------------------------+

0.4 swp_entry_t
================================================================================

Encoding: (type, offset) -> swp_entry

  entry = swap_entry(type, offset)

Decoding: swp_entry -> (type, offset)

  type = swp_type(entry)
  offset = swp_offset(entry)

    
    +-----------------------------------------------+
    |             |                                 |
    +-----------------------------------------------+
    ^             ^                                 ^
    |   type      |       index/offset              |

0.5 swap_map
================================================================================
; swap_map stores the count of page refer this slot
; and this filed is encoded

Two formats for swap_map: first swap_map and continuations

    First swap_map:

        COUNT_CONTINUED
         |    SWAP_HAS_CACHE
         |     |
         v     v
       +----+----+----+----+----+----+----+----+
       |    |    |    |    |    |    |    |    |
       +----+----+----+----+----+----+----+----+

    Continuations:

        COUNT_CONTINUED
         |
         |
         v
       +----+----+----+----+----+----+----+----+
       |    |    |    |    |    |    |    |    |
       +----+----+----+----+----+----+----+----+

Bit indication in first swap_map:

   SWAP_HAS_CACHE  0x40(0100 0000)

Bit indication in all swap_map(?):

   COUNT_CONTINUED 0x80(1000 0000)

Special value in first swap_map:

   SWAP_MAP_MAX    0x3e(0011 1110)
   SWAP_MAP_BAD    0x3f(0011 1111)
   SWAP_MAP_SHMEM  0xbf(1011 1111)

Special value in swap_map continuation:

   SWAP_CONT_MAX   0x7f(0111 1111)

0. history of swap
================================================================================

Restyle scan_swap_map:
Drop swap_device_lock and swap_list_lock
use swap_lock

dae06ac43d56 2005-09-05 [PATCH] swap: update swsusp use of swap_info
5d337b9194b1 2005-09-05 [PATCH] swap: swap_lock replace list+device
048c27fd7281 2005-09-05 [PATCH] swap: scan_swap_map latency breaks
52b7efdbe5f5 2005-09-05 [PATCH] swap: scan_swap_map drop swap_device_lock
7dfad4183bf9 2005-09-05 [PATCH] swap: scan_swap_map restyled
fb4f88dcabdc 2005-09-05 [PATCH] swap: get_swap_page drop swap_list_lock
89d09a2c80ea 2005-09-05 [PATCH] swap: freeing update swap_list.next
6eb396dc4a97 2005-09-05 [PATCH] swap: swap unsigned int consistency
53092a7402f2 2005-09-05 [PATCH] swap: show span of swap extents
11d31886dbcb 2005-09-05 [PATCH] swap: swap extent list is ordered
4cd3bb10ff0b 2005-09-05 [PATCH] swap: move destroy_swap_extents calls
e2244ec2efa4 2005-09-05 [PATCH] swap: correct swapfile nr_good_pages
b0d9bcd4bb79 2005-09-05 [PATCH] swap: update swapfile i_sem comment

swap randomize if nonrot

f0d7a4b3ed46 2009-01-06 swapfile: let others seed random
858a29900ea2 2009-01-06 swapfile: change discard pgoff_t to sector_t
c60aa176c6de 2009-01-06 swapfile: swap allocation cycle if nonrot
20137a490f39 2009-01-06 swapfile: swapon randomize if nonrot
7992fde72ce0 2009-01-06 swapfile: swap allocation use discard
6a6ba83175c0 2009-01-06 swapfile: swapon use discard (trim)
ebebbbe90463 2009-01-06 swapfile: rearrange scan and swap_info
81e33971271e 2009-01-06 swapfile: remove v0 SWAP-SPACE message
886bb7e9c3ed 2009-01-06 swapfile: remove surplus whitespace
22c6f8fdb319 2009-01-06 swapfile: remove SWP_ACTIVE mask
73fd8748ab0b 2009-01-06 swapfile: swapon needs larger size type

introduce SWAP_HAS_CACHE

c9e444103b5e 2009-06-16 mm: reuse unused swap entry if necessary
355cfa73ddff 2009-06-16 mm: modify swap_map and add SWAP_HAS_CACHE flag
cb4b86ba47bb 2009-06-16 mm: add swap cache interface for swap reference

swap count continuations, encoded in swap_map

7509765a29cf 2009-12-15 swap_info: reorder its fields
aaa468653b4a 2009-12-15 swap_info: note SWAP_MAP_SHMEM
570a335b8e22 2009-12-15 swap_info: swap count continuations
8d69aaee80c1 2009-12-15 swap_info: swap_map of chars not shorts
253d553ba75a 2009-12-15 swap_info: SWAP_HAS_CACHE cleanups
73c34b6accc8 2009-12-15 swap_info: miscellaneous minor cleanups
9625a5f289f7 2009-12-15 swap_info: include first_swap_extent
efa90a981bbc 2009-12-15 swap_info: change to array of pointers
f29ad6a99b59 2009-12-15 swap_info: private to swapfile.c

Opt for SSD

ebc2a1a69111 2013-09-11 swap: make cluster allocation per-cpu
edfe23dac3e2 2013-09-11 swap: fix races exposed by swap discard
815c2c543d3a 2013-09-11 swap: make swap discard async
2a8f94493432 2013-09-11 swap: change block allocation algorithm for SSD

Regular page swap optimizations
https://lwn.net/Articles/704359/
a) per cluster lock
b) 64M address space
c) add cache for swap slots allocation

ba81f8384254 2017-02-22 mm/swap: skip readahead only when swap slot cache is enabled
039939a65059 2017-02-22 mm/swap: enable swap slots cache usage
67afa38e012e 2017-02-22 mm/swap: add cache for swap slots allocation
7c00bafee87c 2017-02-22 mm/swap: free swap slots in batch
36005bae205d 2017-02-22 mm/swap: allocate swap slots in batches
e8c26ab60598 2017-02-22 mm/swap: skip readahead for unreferenced swap slots
4b3ef9daa4fc 2017-02-22 mm/swap: split swap cache into 64MB trunks
235b62176712 2017-02-22 mm/swap: add cluster lock
6a991fc72d12 2017-02-22 mm/swap: fix kernel message in swap_info_get()

Delay splitting THP after swapped out:
https://lwn.net/Articles/696840/

fe490cc0fe9e 2017-09-06 mm, THP, swap: add THP swapping out fallback counting
bd4c82c22c36 2017-09-06 mm, THP, swap: delay splitting THP after swapped out
d6810d730022 2017-09-06 memcg, THP, swap: make mem_cgroup_swapout() support THP
abe2895b7604 2017-09-06 memcg, THP, swap: avoid to duplicated charge THP in swap cache
3e14a57b2416 2017-09-06 memcg, THP, swap: support move mem cgroup charge for THP swapped out
59807685a7e7 2017-09-06 mm, THP, swap: support splitting THP for THP swap out
225311a46411 2017-09-06 mm: test code to write THP to swap device as a whole
98cc093cba1e 2017-09-06 block, THP: make block_device_operations.rw_page support THP
f0eea189e8e9 2017-09-06 mm, THP, swap: don't allocate huge cluster for file backed swap device
ba3c4ce6def4 2017-09-06 mm, THP, swap: make reuse_swap_page() works for THP swapped out
e07098294adf 2017-09-06 mm, THP, swap: support to reclaim swap space for THP swapped out
a3aea839e42e 2017-09-06 mm, THP, swap: support to clear swap cache flag for THP swapped out

0. some articles on swap
================================================================================
Making swapping scalable https://lwn.net/Articles/704478/
Reconsidering swapping   https://lwn.net/Articles/690079/
mm: balance LRU lists based on relative thrashing https://lwn.net/Articles/690069/
