1. add_to_swap(struct page *page), called by shrink_list
================================================================================
1.1 entry = get_swap_page(page)
================================================================================
1.2 add_to_swap_cache(page, entry, )
================================================================================
1.2.1 address_space = swap_address_space(entry)
================================================================================
1.2.1.1 swapper_spaces[swp_type(entry)][swp_offset(entry) >> SWAP_ADDRESS_SPACE_SHIFT]
================================================================================
1.2.2 XA_STATE_ORDER(xas, &address_space->i_pages, idx, compound_order(page))
================================================================================
1.2.3 page_ref_add(page, nr)
================================================================================
1.2.4 SetPageSwapCache(page)
================================================================================
1.2.5 set_page_private(page + i, entry.val + i)
================================================================================
1.2.6 xas_store(&xas, page)
================================================================================
1.2.7 return 0
================================================================================
1.3 set_page_dirty(page)
================================================================================
1.4 return 1, successfully added to swap
================================================================================

2. delete_from_swap_cache(page)
================================================================================
2.1 entry = { .val = page_private(page) }
================================================================================
2.2 __delete_from_swap_cache(page, entry)
================================================================================
2.2.1 xas_store(&xas, NULL)
================================================================================
2.2.2 set_page_private(page + i, 0)
================================================================================
2.2.3 ClearPageSwapCache(page)
================================================================================
2.3 put_swap_page(), it clear SWAP_HAS_CACHE, return swap slot until no one use
================================================================================
2.4 page_ref_sub(page, compound_nr(page))
================================================================================

3. swapin_readahead(entry, gfp_mask, vmf), called in do_swap_page()
================================================================================
3.1 swap_vma_readahead(entry, gfp_mask, vmf)
================================================================================
3.1.1 swap_ra_info(vmf, &ra_info)
================================================================================
3.1.1.1 ra_val = GET_SWAP_RA_VAL(vma)
================================================================================
3.1.1.2 pfn = PFN_DOWN(SWAP_RA_ADDR(ra_val))
================================================================================
3.1.1.3 prev_win = SWAP_RA_WIN(ra_val)
================================================================================
3.1.1.4 hits = SWAP_RA_HITS(ra_val)
================================================================================
3.1.1.5 ra_info->win = win = __swapin_nr_pages(pfn, fpfn, hits, max_win, pre_vin), magic way to calculate swapin number
================================================================================
3.1.1.6 swap_ra_clamp_pfn(vma, faddr, fpfn, fpfn + win, &start, &end)
================================================================================
3.1.2 __read_swap_cache_async(entry, )
================================================================================
3.1.2.1 find_get_page(swap_address_space(entry), swp_offset(entry))
================================================================================
3.1.3 swap_readpage(page, false), read content to page async
================================================================================
3.2 swap_cluster_readahead(entry, gfp_mask, vmf)
================================================================================

0. data struct
================================================================================

0.1 swap readahead value
================================================================================

                                 |<-       PAGE_SHIFT      ->|
  +------------------------------+-------------+-------------+
  |                              |             |             |
  |          ADDR                |    WIN      |    HITS     |
  |                              |             |             |
  +------------------------------+-------------+-------------+


0.2 vma_swap_readahead
================================================================================

    struct vma_swap_readahead
    +-------------------------------+       
    |win                            |
    |offset                         |
    |nr_pte                         |
    |    (unsigned short)           |
    |ptes[SWAP_RA_PTE_CACHE_SIZE]   |
    |    (pte_t)                    |
    |                               |
    +-------------------------------+       



