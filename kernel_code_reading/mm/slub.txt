1. slab_sysfs_init(), /sys/kernel/slab/
================================================================================
; iterate on slab_cache and alias_list to create sysfs
static int __init slab_sysfs_init(void)
{
	struct kmem_cache *s;
	int err;

	mutex_lock(&slab_mutex);

	slab_kset = kset_create_and_add("slab", &slab_uevent_ops, kernel_kobj);
	if (!slab_kset) {
		mutex_unlock(&slab_mutex);
		printk(KERN_ERR "Cannot register slab subsystem.\n");
		return -ENOSYS;
	}

	slab_state = FULL;

	list_for_each_entry(s, &slab_caches, list) {
		err = sysfs_slab_add(s);
		if (err)
			printk(KERN_ERR "SLUB: Unable to add boot slab %s"
						" to sysfs\n", s->name);
	}

	while (alias_list) {
		struct saved_alias *al = alias_list;

		alias_list = alias_list->next;
		err = sysfs_slab_alias(al->s, al->name);
		if (err)
			printk(KERN_ERR "SLUB: Unable to add boot slab alias"
					" %s to sysfs\n", al->name);
		kfree(al);
	}

	mutex_unlock(&slab_mutex);
	resiliency_test();
	return 0;
}

1.1 sysfs_slab_add()
================================================================================
static int sysfs_slab_add(struct kmem_cache *s)
{
	int err;
	const char *name;
	int unmergeable = slab_unmergeable(s);

	if (unmergeable) {
		/*
		 * Slabcache can never be merged so we can use the name proper.
		 * This is typically the case for debug situations. In that
		 * case we can catch duplicate names easily.
		 */
		sysfs_remove_link(&slab_kset->kobj, s->name);
		name = s->name;
	} else {
		/*
		 * Create a unique name for the slab as a target
		 * for the symlinks.
		 */
		name = create_unique_id(s);
	}

	s->kobj.kset = cache_kset(s);
	err = kobject_init_and_add(&s->kobj, &slab_ktype, NULL, "%s", name);
	if (err)
		goto out_put_kobj;

	err = sysfs_create_group(&s->kobj, &slab_attr_group);
	if (err)
		goto out_del_kobj;

#ifdef CONFIG_MEMCG_KMEM
	if (is_root_cache(s)) {
		s->memcg_kset = kset_create_and_add("cgroup", NULL, &s->kobj);
		if (!s->memcg_kset) {
			err = -ENOMEM;
			goto out_del_kobj;
		}
	}
#endif

	kobject_uevent(&s->kobj, KOBJ_ADD);
	if (!unmergeable) {
		/* Setup first alias */
		sysfs_slab_alias(s, s->name);
	}
out:
	if (!unmergeable)
		kfree(name);
	return err;
out_del_kobj:
	kobject_del(&s->kobj);
out_put_kobj:
	kobject_put(&s->kobj);
	goto out;
}

1.1.1 create_unique_id(), get slab sysfs name
================================================================================
static char *create_unique_id(struct kmem_cache *s)
{
	char *name = kmalloc(ID_STR_LENGTH, GFP_KERNEL);
	char *p = name;

	BUG_ON(!name);

	*p++ = ':';
	/*
	 * First flags affecting slabcache operations. We will only
	 * get here for aliasable slabs so we do not need to support
	 * too many flags. The flags here must cover all flags that
	 * are matched during merging to guarantee that the id is
	 * unique.
	 */
	if (s->flags & SLAB_CACHE_DMA)
		*p++ = 'd';
	if (s->flags & SLAB_RECLAIM_ACCOUNT)
		*p++ = 'a';
	if (s->flags & SLAB_DEBUG_FREE)
		*p++ = 'F';
	if (!(s->flags & SLAB_NOTRACK))
		*p++ = 't';
	if (p != name + 1)
		*p++ = '-';
	p += sprintf(p, "%07d", s->size);

	BUG_ON(p > name + ID_STR_LENGTH - 1);
	return name;
}

1.1.2 sysfs_create_group(), add sysfs attribute for each kmem_cache
================================================================================
	sysfs_create_group(&s->kobj, &slab_attr_group);

static struct attribute_group slab_attr_group = {
	.attrs = slab_attrs,
};

1.2 sysfs_slab_alias()
================================================================================
static int sysfs_slab_alias(struct kmem_cache *s, const char *name)
{
	struct saved_alias *al;

	if (slab_state == FULL) {
		/*
		 * If we have a leftover link then remove it.
		 */
		sysfs_remove_link(&slab_kset->kobj, name);
		return sysfs_create_link(&slab_kset->kobj, &s->kobj, name);
	}

	al = kmalloc(sizeof(struct saved_alias), GFP_KERNEL);
	if (!al)
		return -ENOMEM;

	al->s = s;
	al->name = name;
	al->next = alias_list;
	alias_list = al;
	return 0;
}

2. kmem_cache_init()
================================================================================

2.1 create_boot_cache(kmem_cache_node)
================================================================================

2.1.1 __kmem_cache_create()
================================================================================

2.1.1.1 kmem_cache_open()
================================================================================

2.1.1.1.1 init_kmem_cache_nodes()
================================================================================

2.1.1.1.1.1 early_kmem_cache_node_alloc(), alloc a page and add to node->partial
================================================================================

2.1.1.1.2 alloc_kmem_cache_cpus()
================================================================================

2.1.1.2 sysfs_slab_add()
================================================================================

2.2 create_boot_cache(kmem_cache)
================================================================================

2.3 bootstrap(kmem_cache)
================================================================================

2.4 bootstrap(kmem_cache_node)
================================================================================

2.5 setup_kmalloc_cache_index_table()
================================================================================

2.6 create_kmalloc_caches(0)
================================================================================

2.7 init_freelist_randomization()
================================================================================

3. kmem_cache_create()
================================================================================

3.1 kmem_cache_sanity_check()
================================================================================

3.2 __kmem_cache_alias(), share one kmem_cache if possible
================================================================================

3.3 create_cache
================================================================================

3.3.1 __kmem_cache_create(), alloc struct kmem_cache
================================================================================

3.3.1.1 kmem_cache_open(), init kmem_cache_node and kmem_cache_cpu
================================================================================

3.3.1.2 sysfs_slab_add()
================================================================================

4. kmem_cache_alloc()
================================================================================

4.1 slab_alloc() --> slab_alloc_node(), update cpu_slab->freelist/tid
================================================================================

4.1.1 slab_pre_alloc_hook()
================================================================================

4.1.2 __slab_alloc() --> ___slab_alloc()
================================================================================

4.1.2.1 get_freelist()
================================================================================

4.1.2.2 get_freepointer()
================================================================================

4.1.2.3 next_tid()
================================================================================

4.1.2.4 new_slab_objects(), may alloc with page by new_slab()
================================================================================

4.1.2.4.1 get_partial()
================================================================================

4.1.3 slab_post_alloc_hook()
================================================================================

5. new_slab(), --> allocate_slab() get a page
================================================================================

5.1 allocate_slab(), some magic here
================================================================================

5.1.1 alloc_slab_page()
================================================================================

5.1.1.1 alloc_pages(), get page from buddy
================================================================================


6. kmem_cache_free()
================================================================================

6.1 cache_from_obj()
================================================================================

6.2 slab_free()
================================================================================

6.2.1 do_slab_free()
================================================================================

6.2.1.1 set_freepointer(), fast path
================================================================================

6.2.1.2 __slab_free(), slow path
================================================================================

0. init flow
================================================================================

start_kernel()
    mm_init()
        kmem_cache_init()

0. data structure
================================================================================

0.1 slab_cache
================================================================================

    slab_caches (struct list_head)
    +-----------------------+
    |                       |
    +-----------------------+
     |
     |   struct kmem_cache
     |   +----------------------+      +----------------------+
     +-->|list(struct list_head)| ---->|list(struct list_head)|
         +----------------------+      +----------------------+

0.2 kmem_cache
================================================================================



            kmem_cache                      
            +------------------------------+
            |kobj                          |
            |    (struct kobject)          |
            +------------------------------+
            |list                          |
            |    (struct list_head)        |
            +------------------------------+
            |name                          |
            |    (char *)                  |
            +------------------------------+
            |object_size                   |   = original object size
            |inuse                         |   = ALIGN(object_size, sizeof(void *))
            |size                          |   = ALIGN(inuse + padding + debug space, s->align)
            |align                         |
            |offset                        |
            |    (int)                     |
            |                              |
            |reserved                      |
            |                              |
            +------------------------------+
            |oo                            |
            |min                           |
            |max                           |
            |   (kmem_cache_order_objects) |
            |   +--------------------------+
            |   |order                     |
            |   |order_objects             |
            +---+--------------------------+
            |flags                         |
            |    (unsigned long)           |
            |allocflags                    |
            |    (gfp_t)                   |
            +------------------------------+
            |cpu_partial                   |  determine max #objects kept in the
            |    (int)                     |  per cpu partial lists of a processor
            |                              |
            |cpu_slab                      |  * per cpu variable pointer
            |   (struct kmem_cache_cpu*)   |          kmem_cache_cpu
            |   +--------------------------+
            |   |tid                       |  transaction id = cpu id + event id
            |   |          (unsigned long) |
            |   |freelist  (void **)       |          
            |   |page      (struct page *) |
            |   |partial   (struct page *) |          
            |   +--------------------------+          
            |   |stat[NR_SLUB_STAT_ITEMS]  |          
            |   |  (unsigned)              |          
            +---+--------------------------+        
            |min_partial                   |  determine max #nr_slabs in kmem_cache_node
            |    (int)                     |
            +------------------------------+
            |node[MAX_NUMNODES]            |  one node per NUMA, slab list for all objects
            |   (struct kmem_cache_node*)  |  
            +------------------------------+  
                |                             
                |                             
                |           struct kmem_cache_node                 
                +---------> +------------------------------+                                   
                            |list_lock                     |                                   
                            |    (spinlock_t)              |                                   
                            +------------------------------+                                   
                            |partial                       |                                   
                            |full                          |                                   
                            |    (struct list_head)        |                                   
                            +------------------------------+                                   
                            |nr_partial                    |                                   
                            |    (unsigned long)           |                                   
                            |nr_slabs                      |   number of slab on this node
                            |total_objects                 |   number of objs
                            |    (atomit_long_t)           |                                   
                            +------------------------------+                                   


0.2.1 kmem_cache_create()
================================================================================
; the state for a fresh kmem_cache


            kmem_cache                      
            +------------------------------+
            |name   (char *)               |
            +------------------------------+
            |cpu_slab                      |  * per cpu variable pointer
            |   (struct kmem_cache_cpu*)   |
            |   +--------------------------+
            |   |stat[NR_SLUB_STAT_ITEMS]  |
            |   |  (unsigned)              |
            |   |tid                       |    #cpu
            |   |          (unsigned long) |
            |   |freelist  (void **)       |    NULL
            |   |page      (struct page *) |    NULL
            |   |partial   (struct page *) |    NULL
            +---+--------------------------+
            |node[MAX_NUMNODES]            |
            |   (struct kmem_cache_node*)  |
            |   +--------------------------+
            |   |list_lock                 |
            |   |    (spinlock_t)          |
            |   |nr_partial                |    0
            |   |    (unsigned long)       |
            |   |partial                   |    empty
            |   |    (struct list_head)    |
            +---+--------------------------+


0.2.2 kmem_cache_alloc()
================================================================================

; Page retrieve priority
; 1. c->freelist, c->page
; 2. c->partial
; 3. node[]->partial
; 4. page_alloc()

0.2.2.1 ___slab_alloc(), cases for slab allocation
================================================================================
; Case 1: no memory yet, need to allocate from buddy
; allocate_slab()

    kmem_cache                      
    +------------------------------+
    |name   (char *)               |
    +------------------------------+
    |cpu_slab                      |  * per cpu variable pointer
    |   (struct kmem_cache_cpu*)   |
    |   +--------------------------+
    |   |stat[NR_SLUB_STAT_ITEMS]  |
    |   |  (unsigned)              |
    |   +--------------------------+
    |   |tid      (unsigned long)  |
    |   |                          |
    |   |freelist                  |                       
    |   |    (void **)             |                       
    |   |                          |                       
    |   |page                   +--|--->+--------+--------+--------+--------+
    |   |   (struct page *)     |  |    |        |        |        |        |
    |   |   +-------------------|--+    +--------+--------+--------+--------+
    |   |   |freelist        ---+  |
    |   |   |inuse = objects       |
    |   |   |frozen = 1            |
    |   |   +----------------------+
    |   |partial                   |  = NULL
    |   |   (struct page *)        |
    +---+--------------------------+

    kmem_cache                      
    +------------------------------+
    |name   (char *)               |
    +------------------------------+
    |cpu_slab                      |  * per cpu variable pointer
    |   (struct kmem_cache_cpu*)   |
    |   +--------------------------+
    |   |stat[NR_SLUB_STAT_ITEMS]  |
    |   |  (unsigned)              |
    |   +--------------------------+
    |   |tid      (unsigned long)  |
    |   |                          |
    |   |freelist            ------|----+  = page->freelist
    |   |    (void **)             |    |
    |   |                          |    v
    |   |page                      |    +--------+--------+--------+--------+
    |   |   (struct page *)        |    |        |        |        |        |
    |   |   +----------------------+    +--------+--------+--------+--------+
    |   |   |freelist = NULL       |
    |   |   |inuse = objects       |
    |   |   |frozen = 1            |
    |   |   +----------------------+
    |   |partial                   |  = NULL
    |   |   (struct page *)        |
    +---+--------------------------+

; Case 2: has memory on percpu freelist, so move the freelist pointer
; fast path of slab_alloc_node()

    kmem_cache                      
    +------------------------------+
    |name   (char *)               |
    +------------------------------+
    |cpu_slab                      |  * per cpu variable pointer
    |   (struct kmem_cache_cpu*)   |
    |   +--------------------------+
    |   |stat[NR_SLUB_STAT_ITEMS]  |
    |   |  (unsigned)              |
    |   +--------------------------+
    |   |tid      (unsigned long)  |
    |   |                          |             a                 A
    |   |freelist            ------|-------------+..................     
    |   |    (void **)             |             |                 .
    |   |                          |             v                 v
    |   |page                      |    +--------+--------+--------+--------+
    |   |   (struct page *)        |    |        |        |        |        |
    |   |   +----------------------+    +--------+--------+--------+--------+
    |   |   |freelist = NULL       |
    |   |   |inuse = objects       |
    |   |   |frozen = 1            |
    |   |   +----------------------+
    |   |                          |
    |   |partial                   |  = NULL
    |   |   (struct page *)        |
    +---+--------------------------+

; Case 3: no memory on freelist but has page on partial list
; ___slab_alloc() -> get_freelist()

    kmem_cache                      
    +------------------------------+
    |name   (char *)               |
    +------------------------------+
    |cpu_slab                      |  * per cpu variable pointer
    |   (struct kmem_cache_cpu*)   |
    |   +--------------------------+
    |   |stat[NR_SLUB_STAT_ITEMS]  |
    |   |  (unsigned)              |
    |   +--------------------------+
    |   |tid      (unsigned long)  |
    |   |                          |
    |   |freelist                  |  = NULL
    |   |    (void **)             |
    |   |page                      |  = NULL
    |   |   (struct page *)        |
    |   |                          |
    |   |partial             ------|--->+-----------+     +-----------+
    |   |   (struct page *)        |    |A      next|---->|B      next|
    |   |                          |    +-----------+     +-----------+
    |   |                          |    |pobjectsA  |  =  |pobjectsB  | + objectsA
    |   |                          |    |           |     |           |
    |   |                          |    |inuse <    |     |inuse <    |
    |   |                          |    | objectsA  |     | objectsB  |
    |   |                          |    |frozen = 1 |     |frozen = 1 |
    |   |                          |    +-----------+     +-----------+
    +---+--------------------------+

    kmem_cache                      
    +------------------------------+
    |name   (char *)               |
    +------------------------------+
    |cpu_slab                      |  * per cpu variable pointer
    |   (struct kmem_cache_cpu*)   |
    |   +--------------------------+
    |   |stat[NR_SLUB_STAT_ITEMS]  |
    |   |  (unsigned)              |
    |   +--------------------------+
    |   |tid      (unsigned long)  |
    |   |                          |
    |   |freelist            ------|----+   = page->freelist
    |   |    (void **)             |    |
    |   |                          |    v
    |   |page                      |    +--------+--------+--------+--------+
    |   |   (struct page *)  A     |    |        |        |        |        |
    |   |   +----------------------+    +--------+--------+--------+--------+
    |   |   |freelist = NULL       |
    |   |   |inuse = objects       |
    |   |   |frozen = 1            |
    |   |   +----------------------+
    |   |                          |
    |   |partial             ------|--->+-----------+
    |   |   (struct page *)        |    |B      next|
    |   |                          |    +-----------+
    |   |                          |    |pobjectsB  | = objectsB
    |   |                          |    |           |
    |   |                          |    |inuse <    |
    |   |                          |    | objectsB  |
    |   |                          |    |frozen = 1 |
    |   |                          |    +-----------+
    +---+--------------------------+

; Case 4: no memory on freelist nor cpu_slab->partial, try kmem_cache_node
; new_slab_objects()->get_partial()->get_partial_node()

    kmem_cache                      
    +------------------------------+
    |name   (char *)               |
    +------------------------------+
    |cpu_slab                      |  * per cpu variable pointer
    |   (struct kmem_cache_cpu*)   |
    |   +--------------------------+
    |   |stat[NR_SLUB_STAT_ITEMS]  |
    |   |  (unsigned)              |
    |   +--------------------------+
    |   |tid      (unsigned long)  |
    |   |                          |
    |   |freelist                  |  = NULL
    |   |    (void **)             |
    |   |page                      |  = NULL
    |   |   (struct page *)        |
    |   |                          |
    |   |partial                   |  = NULL
    |   |   (struct page *)        |
    |   |                          |
    +---+--------------------------+
    |node[MAX_NUMNODES]            |
    |   (struct kmem_cache_node*)  |
    |   +--------------------------+
    |   |nr_partial  = 3           |
    |   |    (unsigned long)       |
    |   |partial               ----|--->+-----------+     +-----------+     +-----------+
    |   |    (struct list_head)    |    |A       lru|---->|B       lru|---->|C       lru|
    +---+--------------------------+    +-----------+     +-----------+     +-----------+ 
                                        |inuse <    |     |inuse <    |
                                        | objects   |     | objects   |
                                        |frozen = 0 |     |frozen = 0 |
                                        +-----------+     +-----------+

    kmem_cache                      
    +------------------------------+
    |name   (char *)               |
    +------------------------------+
    |cpu_slab                      |  * per cpu variable pointer
    |   (struct kmem_cache_cpu*)   |
    |   +--------------------------+
    |   |stat[NR_SLUB_STAT_ITEMS]  |
    |   |  (unsigned)              |
    |   +--------------------------+
    |   |tid      (unsigned long)  |
    |   |                          |
    |   |freelist            ------|----+   = page->freelist
    |   |    (void **)             |    |
    |   |                          |    v
    |   |page                      |    +--------+--------+--------+--------+
    |   |   (struct page *)  A     |    |        |        |        |        |
    |   |   +----------------------+    +--------+--------+--------+--------+
    |   |   |freelist = NULL       |
    |   |   |inuse = objects       |
    |   |   |frozen = 1            |
    |   |   +----------------------+
    |   |                          |
    |   |partial             ------|--->+-----------+
    |   |   (struct page *)        |    |B      next|
    |   |                          |    +-----------+
    |   |                          |    |pobjects   | = objects
    |   |                          |    |           |
    |   |                          |    |inuse <    |
    |   |                          |    | objects   |
    |   |                          |    |frozen = 1 |
    |   |                          |    +-----------+
    |   |                          |
    +---+--------------------------+
    |node[MAX_NUMNODES]            |
    |   (struct kmem_cache_node*)  |
    |   +--------------------------+
    |   |nr_partial  = 1           |
    |   |    (unsigned long)       |
    |   |partial               ----|--->+-----------+
    |   |    (struct list_head)    |    |C       lru|
    +---+--------------------------+    +-----------+


0.2.3 slab_free()
================================================================================

; Case 1: free object on cpu_slab->page
; fast path of do_slab_free()

    kmem_cache                      
    +------------------------------+
    |name   (char *)               |
    +------------------------------+
    |cpu_slab                      |  * per cpu variable pointer
    |   (struct kmem_cache_cpu*)   |
    |   +--------------------------+
    |   |stat[NR_SLUB_STAT_ITEMS]  |
    |   |  (unsigned)              |
    |   +--------------------------+
    |   |tid      (unsigned long)  |
    |   |                          |                               obj
    |   |freelist            ------|-------------+..................     
    |   |    (void **)             |             |                 .
    |   |                          |             v                 v
    |   |page                      |    +--------+--------+--------+--------+
    |   |   (struct page *)        |    |        |        |        |        |
    |   |   +----------------------+    +--------+--------+--------+--------+
    |   |   |freelist = NULL       |
    |   |   |inuse = objects       |
    |   |   |frozen = 1            |
    |   |   +----------------------+
    |   |                          |
    |   |partial                   |  = NULL
    |   |   (struct page *)        |
    +---+--------------------------+

; Case 2: deactivate_slab() remove cpu_slab
; * to node[]->partial if partial
; * to node[]->full if full

    kmem_cache                      
    +------------------------------+
    |name   (char *)               |
    +------------------------------+
    |cpu_slab                      |  * per cpu variable pointer
    |   (struct kmem_cache_cpu*)   |
    |   +--------------------------+
    |   |stat[NR_SLUB_STAT_ITEMS]  |
    |   |  (unsigned)              |
    |   +--------------------------+
    |   |tid      (unsigned long)  |
    |   |                          |
    |   |freelist            ------|----+   = page->freelist
    |   |    (void **)             |    |
    |   |                          |    v
    |   |page                      |    +--------+--------+--------+--------+
    |   |   (struct page *)  A     |    |        |        |        |        |
    |   |   +----------------------+    +--------+--------+--------+--------+
    |   |   |freelist = NULL       |
    |   |   |inuse = objects       |
    |   |   |frozen = 1            |
    |   |   +----------------------+
    |   |                          |
    |   |partial             ------|--->+-----------+
    |   |   (struct page *)        |    |B      next|
    |   |                          |    +-----------+
    |   |                          |    |pobjects   |  = objects
    |   |                          |    |           |
    |   |                          |    |inuse <    |
    |   |                          |    | objects   |
    |   |                          |    |frozen = 1 |
    |   |                          |    +-----------+
    |   |                          |
    +---+--------------------------+
    |node[MAX_NUMNODES]            |
    |   (struct kmem_cache_node*)  |
    |   +--------------------------+
    |   |nr_partial  = 1           |
    |   |    (unsigned long)       |
    |   |partial               ----|--->+-----------+
    |   |    (struct list_head)    |    |C       lru|
    +---+--------------------------+    +-----------+

    kmem_cache                      
    +------------------------------+
    |name   (char *)               |
    +------------------------------+
    |cpu_slab                      |  * per cpu variable pointer
    |   (struct kmem_cache_cpu*)   |
    |   +--------------------------+
    |   |stat[NR_SLUB_STAT_ITEMS]  |
    |   |  (unsigned)              |
    |   +--------------------------+
    |   |tid      (unsigned long)  |
    |   |                          |
    |   |freelist                  |  = NULL
    |   |    (void **)             |
    |   |page                      |  = NULL
    |   |   (struct page *)        |
    |   |                          |
    |   |partial             ------|--->+-----------+
    |   |   (struct page *)        |    |B      next|
    |   |                          |    +-----------+
    |   |                          |    |pobjects   |  = objects
    |   |                          |    |           |
    |   |                          |    |inuse <    |
    |   |                          |    | objects   |
    |   |                          |    |frozen = 1 |
    |   |                          |    +-----------+
    |   |                          |
    +---+--------------------------+
    |node[MAX_NUMNODES]            |
    |   (struct kmem_cache_node*)  |
    |   +--------------------------+
    |   |nr_partial  = 1           |
    |   |    (unsigned long)       |
    |   |partial               ----|--->+-----------+     +-----------+
    |   |    (struct list_head)    |    |A       lru|---->|C       lru|
    +---+--------------------------+    +-----------+     +-----------+
                                        |inuse <    |
                                        | objects   |
                                        |frozen = 0 |
                                        +-----------+

; Case 3: unfreeze_partials() move all cpu_slab->partial to node[]->partial

    kmem_cache                      
    +------------------------------+
    |name   (char *)               |
    +------------------------------+
    |cpu_slab                      |  * per cpu variable pointer
    |   (struct kmem_cache_cpu*)   |
    |   +--------------------------+
    |   |stat[NR_SLUB_STAT_ITEMS]  |
    |   |  (unsigned)              |
    |   +--------------------------+
    |   |tid      (unsigned long)  |
    |   |                          |
    |   |freelist            ------|----+   = page->freelist
    |   |    (void **)             |    |
    |   |                          |    v
    |   |page                      |    +--------+--------+--------+--------+
    |   |   (struct page *)  A     |    |        |        |        |        |
    |   |   +----------------------+    +--------+--------+--------+--------+
    |   |   |freelist = NULL       |
    |   |   |inuse = objects       |
    |   |   |frozen = 1            |
    |   |   +----------------------+
    |   |                          |
    |   |partial             ------|--->+-----------+     +-----------+
    |   |   (struct page *)        |    |B      next|---->|C      next|
    |   |                          |    +-----------+     +-----------+
    |   |                          |    |pobjectsA  |  =  |pobjectsB  | + objectsA
    |   |                          |    |           |     |           |
    |   |                          |    |inuse <    |     |inuse <    |
    |   |                          |    | objectsA  |     | objectsB  |
    |   |                          |    |frozen = 1 |     |frozen = 1 |
    |   |                          |    +-----------+     +-----------+
    |   |                          |
    +---+--------------------------+
    |node[MAX_NUMNODES]            |
    |   (struct kmem_cache_node*)  |
    |   +--------------------------+
    |   |nr_partial  = 1           |
    |   |    (unsigned long)       |
    |   |partial               ----|--->+-----------+
    |   |    (struct list_head)    |    |D       lru|
    +---+--------------------------+    +-----------+


    kmem_cache                      
    +------------------------------+
    |name   (char *)               |
    +------------------------------+
    |cpu_slab                      |  * per cpu variable pointer
    |   (struct kmem_cache_cpu*)   |
    |   +--------------------------+
    |   |stat[NR_SLUB_STAT_ITEMS]  |
    |   |  (unsigned)              |
    |   +--------------------------+
    |   |tid      (unsigned long)  |
    |   |                          |
    |   |freelist            ------|----+   = page->freelist
    |   |    (void **)             |    |
    |   |                          |    v
    |   |page                      |    +--------+--------+--------+--------+
    |   |   (struct page *)  A     |    |        |        |        |        |
    |   |   +----------------------+    +--------+--------+--------+--------+
    |   |   |freelist = NULL       |
    |   |   |inuse = objects       |
    |   |   |frozen = 1            |
    |   |   +----------------------+
    |   |                          |
    |   |partial                   |  = NULL
    |   |   (struct page *)        |
    |   |                          |
    +---+--------------------------+
    |node[MAX_NUMNODES]            |
    |   (struct kmem_cache_node*)  |
    |   +--------------------------+
    |   |nr_partial  = 1           |
    |   |    (unsigned long)       |
    |   |partial               ----|--->+-----------+     +-----------+     +-----------+
    |   |    (struct list_head)    |    |B       lru|---->|C       lru|---->|D       lru|
    +---+--------------------------+    +-----------+     +-----------+     +-----------+ 
                                        |inuse <    |     |inuse <    |
                                        | objects   |     | objects   |
                                        |frozen = 0 |     |frozen = 0 |
                                        +-----------+     +-----------+

; Case 4: move a page in node[]->partial to cpu_slab->partial, put_cpu_partial()
; This is a little similar with the allocation case 4, except only one page is
; extract


    kmem_cache                      
    +------------------------------+
    |name   (char *)               |
    +------------------------------+
    |cpu_slab                      |  * per cpu variable pointer
    |   (struct kmem_cache_cpu*)   |
    |   +--------------------------+
    |   |stat[NR_SLUB_STAT_ITEMS]  |
    |   |  (unsigned)              |
    |   +--------------------------+
    |   |tid      (unsigned long)  |
    |   |                          |
    |   |freelist            ------|----+   = page->freelist
    |   |    (void **)             |    |
    |   |                          |    v
    |   |page                      |    +--------+--------+--------+--------+
    |   |   (struct page *)  A     |    |        |        |        |        |
    |   |   +----------------------+    +--------+--------+--------+--------+
    |   |   |freelist = NULL       |
    |   |   |inuse = objects       |
    |   |   |frozen = 1            |
    |   |   +----------------------+
    |   |                          |
    |   |partial             ------|--->+-----------+
    |   |   (struct page *)        |    |B      next|
    |   |                          |    +-----------+
    |   |                          |    |pobjectsB  | = objectsB
    |   |                          |    |           |
    |   |                          |    |inuse <    |
    |   |                          |    | objectsB  |
    |   |                          |    |frozen = 1 |
    |   |                          |    +-----------+
    |   |                          |
    +---+--------------------------+
    |node[MAX_NUMNODES]            |
    |   (struct kmem_cache_node*)  |
    |   +--------------------------+
    |   |nr_partial  = 3           |
    |   |    (unsigned long)       |
    |   |partial               ----|--->+-----------+     +-----------+
    |   |    (struct list_head)    |    |C       lru|---->|D       lru|
    +---+--------------------------+    +-----------+     +-----------+ 
                                        |inuse <    |     
                                        | objects   |     
                                        |frozen = 0 |     
                                        +-----------+     

    kmem_cache                      
    +------------------------------+
    |name   (char *)               |
    +------------------------------+
    |cpu_slab                      |  * per cpu variable pointer
    |   (struct kmem_cache_cpu*)   |
    |   +--------------------------+
    |   |stat[NR_SLUB_STAT_ITEMS]  |
    |   |  (unsigned)              |
    |   +--------------------------+
    |   |tid      (unsigned long)  |
    |   |                          |
    |   |freelist            ------|----+   = page->freelist
    |   |    (void **)             |    |
    |   |                          |    v
    |   |page                      |    +--------+--------+--------+--------+
    |   |   (struct page *)  A     |    |        |        |        |        |
    |   |   +----------------------+    +--------+--------+--------+--------+
    |   |   |freelist = NULL       |
    |   |   |inuse = objects       |
    |   |   |frozen = 1            |
    |   |   +----------------------+
    |   |                          |
    |   |partial             ------|--->+-----------+     +-----------+
    |   |   (struct page *)        |    |C      next|---->|B      next|
    |   |                          |    +-----------+     +-----------+
    |   |                          |    |pobjectsC  |  =  |pobjectsB  | + objectsC
    |   |                          |    |           |     |           |
    |   |                          |    |inuse <    |     |inuse <    |
    |   |                          |    | objectsC  |     | objectsB  |
    |   |                          |    |frozen = 1 |     |frozen = 1 |
    |   |                          |    +-----------+     +-----------+
    |   |                          |
    +---+--------------------------+
    |node[MAX_NUMNODES]            |
    |   (struct kmem_cache_node*)  |
    |   +--------------------------+
    |   |nr_partial  = 1           |
    |   |    (unsigned long)       |
    |   |partial               ----|--->+-----------+
    |   |    (struct list_head)    |    |C       lru|
    +---+--------------------------+    +-----------+

; Case 5: move a full page to node[]->partial, __slab_free()->add_partial()
; this is a little bit interesting, since node[]->full is configurable
; which means the full page could be an orphan

    kmem_cache                      
    +------------------------------+
    |name   (char *)               |
    +------------------------------+
    |cpu_slab                      |  * per cpu variable pointer
    |   (struct kmem_cache_cpu*)   |
    |   +--------------------------+
    |   |stat[NR_SLUB_STAT_ITEMS]  |
    |   |  (unsigned)              |
    |   +--------------------------+
    |   |tid      (unsigned long)  |
    |   |                          |
    |   |freelist            ------|----+   = page->freelist
    |   |    (void **)             |    |
    |   |                          |    v
    |   |page                      |    +--------+--------+--------+--------+
    |   |   (struct page *)  A     |    |        |        |        |        |
    |   |   +----------------------+    +--------+--------+--------+--------+
    |   |   |freelist = NULL       |
    |   |   |inuse = objects       |
    |   |   |frozen = 1            |
    |   |   +----------------------+
    |   |                          |
    |   |partial             ------|--->+-----------+
    |   |   (struct page *)        |    |B      next|
    |   |                          |    +-----------+
    |   |                          |    |pobjectsB  | = objectsB
    |   |                          |    |           |
    |   |                          |    |inuse <    |
    |   |                          |    | objectsB  |
    |   |                          |    |frozen = 1 |
    |   |                          |    +-----------+
    |   |                          |
    +---+--------------------------+
    |node[MAX_NUMNODES]            |
    |   (struct kmem_cache_node*)  |
    |   +--------------------------+
    |   |nr_partial  = 3           |
    |   |    (unsigned long)       |
    |   |partial               ----|--->+-----------+     +-----------+
    |   |    (struct list_head)    |    |C       lru|---->|D       lru|
    |   +--------------------------+    +-----------+     +-----------+ 
    |   |full                  ----|--->+-----------+
    |   |    (struct list_head)    |    |E       lru|
    +---+--------------------------+    +-----------+

    kmem_cache                      
    +------------------------------+
    |name   (char *)               |
    +------------------------------+
    |cpu_slab                      |  * per cpu variable pointer
    |   (struct kmem_cache_cpu*)   |
    |   +--------------------------+
    |   |stat[NR_SLUB_STAT_ITEMS]  |
    |   |  (unsigned)              |
    |   +--------------------------+
    |   |tid      (unsigned long)  |
    |   |                          |
    |   |freelist            ------|----+   = page->freelist
    |   |    (void **)             |    |
    |   |                          |    v
    |   |page                      |    +--------+--------+--------+--------+
    |   |   (struct page *)  A     |    |        |        |        |        |
    |   |   +----------------------+    +--------+--------+--------+--------+
    |   |   |freelist = NULL       |
    |   |   |inuse = objects       |
    |   |   |frozen = 1            |
    |   |   +----------------------+
    |   |                          |
    |   |partial             ------|--->+-----------+
    |   |   (struct page *)        |    |B      next|
    |   |                          |    +-----------+
    |   |                          |    |pobjectsB  | = objectsB
    |   |                          |    |           |
    |   |                          |    |inuse <    |
    |   |                          |    | objectsB  |
    |   |                          |    |frozen = 1 |
    |   |                          |    +-----------+
    |   |                          |
    +---+--------------------------+
    |node[MAX_NUMNODES]            |
    |   (struct kmem_cache_node*)  |
    |   +--------------------------+
    |   |nr_partial  = 3           |
    |   |    (unsigned long)       |
    |   |partial               ----|--->+-----------+     +-----------+     +-----------+
    |   |    (struct list_head)    |    |E       lru|---->|C       lru|---->|D       lru|
    |   +--------------------------+    +-----------+     +-----------+     +-----------+ 
    |   |full                      |  = NULL
    |   |    (struct list_head)    |
    +---+--------------------------+

0.3 page, the slub
================================================================================


    struct page
    +------------------------------+
    |slab_cache                    |
    |   (struct kmem_cache *)      |
    +------------------------------+
    |freelist                      |  first free object (list head)
    |   (viod *)                   |
    +------------------------------+
    |                              |  * used for kmem_cache_cpu->freelist
    |objects                       |  number of objects in Page
    |inuse                         |  number of objects used in cpu_slab
    |frozen                        |  frozen means it is in cpu_slab
    |   (unsigned )                |
    +------------------------------+
    |                              |  * used for kmem_cache_cpu->partial
    |next                          |
    |   (struct page*)             |
    |pages                         |
    |pobjects                      |
    |   (int)                      |
    +------------------------------+


0.3.1 allocate_slab, just allocated from page allocator
================================================================================


    struct page
    +------------------------------+
    |slab_cache                    |
    |   (struct kmem_cache *)      |
    +------------------------------+
    |freelist                      |  first free object
    |   (viod *)                   |
    +------------------------------+
    |objects                       |  number of slub objects in Page
    |inuse                         |  = objects
    |   (unsigned )                |
    |frozen                        |  = 1
    |   (unsigned )                |
    +------------------------------+


0.3.2 new_slab_objects, give a page from page allocator to slub
================================================================================

    struct page
    +------------------------------+
    |slab_cache                    |
    |   (struct kmem_cache *)      |
    +------------------------------+
    |freelist                      |  NULL (cpu_partial will take it)
    |   (viod *)                   |
    +------------------------------+
    |objects                       |  number of slub objects in Page
    |inuse                         |  = objects
    |   (unsigned )                |
    |frozen                        |  = 1
    |   (unsigned )                |
    +------------------------------+


0.3.3 get_freelist(), prepare a page from cpu_partial or unfreeze a page
================================================================================
; if this is a valid page, page->frozen must be set to 1, otherwise it will
; trigger a bug.
;
; and this means page->freelist must NOT be NULL and is set to NULL, so that
; it could be handled to slub
;
; and very interesting, page->inuse is set to page->objects again
; I don't get this reason yet
;
; and another question is in which case the page is set like this
; I found this is the case from "redo", after we get a page from cpu_partial,
; we are reloading the page to kmem_cache_cpu

    struct page
    +------------------------------+
    |slab_cache                    |
    |   (struct kmem_cache *)      |
    +------------------------------+  from not-NULL to 
    |freelist                      |  NULL (cpu_partial will take it)
    |   (viod *)                   |
    +------------------------------+
    |objects                       |  number of slub objects in Page
    |inuse                         |  = objects
    |   (unsigned )                |
    |frozen                        |  = 1
    |   (unsigned )                |
    +------------------------------+


; or if the page->freelist was NULL, then page->frozen will be set to 0 after
; this call



    struct page
    +------------------------------+
    |slab_cache                    |
    |   (struct kmem_cache *)      |
    +------------------------------+  from NULL to
    |freelist                      |  NULL (cpu_partial will take it)
    |   (viod *)                   |
    +------------------------------+
    |objects                       |  number of slub objects in Page
    |inuse                         |  = objects
    |   (unsigned )                |
    |frozen                        |  = 0
    |   (unsigned )                |
    +------------------------------+


0.3.4 deactivate_slab()
================================================================================

0.3.4.1 no object is used, M_FREE
================================================================================

    struct page
    +------------------------------+
    |slab_cache                    |
    |   (struct kmem_cache *)      |
    +------------------------------+ 
    |freelist                      |  point to some obj
    |   (viod *)                   |
    +------------------------------+
    |objects                       |  number of slub objects in Page
    |inuse                         |  = objects
    |   (unsigned )                |
    |frozen                        |  = 1
    |   (unsigned )                |
    +------------------------------+



    struct page
    +------------------------------+
    |slab_cache                    |
    |   (struct kmem_cache *)      |
    +------------------------------+ 
    |freelist                      |  
    |   (viod *)                   |
    +------------------------------+
    |objects                       |  number of slub objects in Page
    |inuse                         |  = 0
    |   (unsigned )                |
    |frozen                        |  = 0
    |   (unsigned )                |
    +------------------------------+


0.3.4.2 no object is used, M_FREE
================================================================================

    struct page
    +------------------------------+
    |slab_cache                    |
    |   (struct kmem_cache *)      |
    +------------------------------+ 
    |freelist                      |  point to some obj
    |   (viod *)                   |
    +------------------------------+
    |objects                       |  number of slub objects in Page
    |inuse                         |  = objects
    |   (unsigned )                |
    |frozen                        |  = 1
    |   (unsigned )                |
    +------------------------------+



    struct page
    +------------------------------+
    |slab_cache                    |
    |   (struct kmem_cache *)      |
    +------------------------------+ 
    |freelist                      |  
    |   (viod *)                   |
    +------------------------------+
    |objects                       |  number of slub objects in Page
    |inuse                         |  = 0
    |   (unsigned )                |
    |frozen                        |  = 0
    |   (unsigned )                |
    +------------------------------+



0.3.5 __slab_free(), free an obj not on c->page
================================================================================
; two cases will lead to here
; 1. the process is migrated to another cpu
; 2. the page is moved to partial or full


    struct page
    +------------------------------+
    |slab_cache                    |
    |   (struct kmem_cache *)      |
    +------------------------------+ 
    |freelist                      |  point to the obj
    |   (viod *)                   |
    +------------------------------+
    |objects                       |  number of slub objects in Page
    |inuse                         |  = objects
    |   (unsigned )                |
    |frozen                        |  = 1
    |   (unsigned )                |
    +------------------------------+



