1. softirq_init()
================================================================================
softirq_init() is called in start_kernel()

void __init softirq_init(void)
{
	int cpu;

	for_each_possible_cpu(cpu) {
		int i;

		per_cpu(tasklet_vec, cpu).tail =
			&per_cpu(tasklet_vec, cpu).head;
		per_cpu(tasklet_hi_vec, cpu).tail =
			&per_cpu(tasklet_hi_vec, cpu).head;
		for (i = 0; i < NR_SOFTIRQS; i++)
			INIT_LIST_HEAD(&per_cpu(softirq_work_list[i], cpu));
	}

	register_hotcpu_notifier(&remote_softirq_cpu_notifier);

	open_softirq(TASKLET_SOFTIRQ, tasklet_action);
	open_softirq(HI_SOFTIRQ, tasklet_hi_action);
}

1.1 open_softirq(), register a handler in softirq_vec[]
================================================================================
void open_softirq(int nr, void (*action)(struct softirq_action *))
{
	softirq_vec[nr].action = action;
}

2. raise_softirq(nr), explicit raise
================================================================================
2.1 local_irq_save(flags);
================================================================================
2.2 raise_softirq_irqoff(nr);
================================================================================
2.2.1 __raise_softirq_irqoff(nr);
================================================================================
2.2.1.1 or_softirq_pending(1UL << nr), set bit in local_softirq_pending_ref
================================================================================
2.2.2 wakeup_softirqd(), if !in_interrupt()
================================================================================
2.2.2.1 tsk = __this_cpu_read(ksoftirqd);
================================================================================
2.2.2.2 wake_up_process(tsk); wakeup ksoftirqd
================================================================================
2.3 local_irq_restore(flags);
================================================================================

2. irq_exit(), before return from irq handler
================================================================================
2.1 if !in_interrupt() && local_softirq_pending(), set during raise_softirq()
================================================================================
2.2 invoke_softirq()
================================================================================
2.2.1 do_softirq_own_stack()
================================================================================
2.2.1.1 __do_softirq()
================================================================================

3. disable/enable softirq in process context
================================================================================

3.1 local_bh_disable(), increase softirq cnt in preempt_count
================================================================================
3.1.1 __local_bh_disable_ip(_THIS_IP_, SOFTIRQ_DISABLE_OFFSET);
================================================================================
3.1.1.1 preempt_count_add(SOFTIRQ_DISABLE_OFFSET);
================================================================================
3.1.1.2 barrier();
================================================================================

3.2 local_bh_enable()
================================================================================
3.2.1 __local_bh_enable_ip(_THIS_IP_, SOFTIRQ_DISABLE_OFFSET);
================================================================================
3.2.1.1 WARN, if in_irq()
================================================================================
3.2.1.2 preempt_count_sub(cnt - 1), keep preemption disabled for following do_softirq()
================================================================================
3.2.1.3 if !in_interrupt() && local_softirq_pending(), set during raise_softirq()
================================================================================
3.2.1.4 do_softirq()
================================================================================
3.2.1.5 preempt_count_dec();
================================================================================
3.2.1.6 preempt_check_resched();
================================================================================

4. run_ksoftirqd(cpu)
================================================================================
4.1 local_irq_disable();
================================================================================
4.2 if (local_softirq_pending())
================================================================================
4.3 __do_softirq();
================================================================================
4.4 local_irq_enable();
================================================================================

5. do_softirq()
================================================================================
5.1 return if in_interrupt()
================================================================================
5.2 local_irq_save(flags)
================================================================================
5.3 pending = local_softirq_pending()
================================================================================
5.4 do_softirq_own_stack(), if pending && !ksoftirqd_running()
================================================================================
5.4.1 __do_softirq()
================================================================================
5.5 local_irq_restore(flags)
================================================================================

6. __do_softirq(), core softirq handler
================================================================================
6.1 pending = local_softirq_pending()
================================================================================
6.2 __local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET), mark in_serving_softirq()
================================================================================
6.3 set_softirq_pending(0), reset pending mask before enabling irq
================================================================================
6.4 local_irq_enable()
================================================================================
6.5 softirq_bit = ffs(pending)
================================================================================
6.6 vec_nr = h - softirq_vec
================================================================================
6.7 prev_count = preempt_count()
================================================================================
6.8 h->action(h), call the real softirq handler
================================================================================
6.9 rcu_softirq_qs(), rcu qs update
================================================================================
6.10 local_irq_disable() 
================================================================================
6.11 __local_bh_enable(SOFTIRQ_OFFSET), clear in_serving_softirq()
================================================================================

0. data structure
================================================================================
Reference:

http://www.wowotech.net/irq_subsystem/soft-irq.html

Compare softirq, tasklet and bh.

https://www.oreilly.com/library/view/understanding-the-linux/0596002130/ch04s07.html#linuxkernel2-CHP-4-FNOTE-13

In this one, it tries to explain how kthread solve a trade-off.

   The ksoftirqd_CPUn kernel threads try to solve this difficult trade-off
   problem. The do_softirq( ) function determines what softirqs are pending
   and executes their functions. If an already executed softirq is activated
   again, the function wakes up the kernel thread and terminates (Step 9 in of
   do_softirq( )). The kernel thread has low priority, so user
   programs have a chance to run; but if the machine is idle, the pending
   softirqs are executed quickly.

Disable interrupt, preempt

https://blog.csdn.net/woshijidutu/article/details/68952702

0.1 softirq_vec[]
================================================================================
static struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;

softirq_vec[NR_SOFTIRQS]
      +------------------------------------+
      |action                              |
      |  void (*)(struct softirq_action *) |
      +------------------------------------+
      |action                              |
      |  void (*)(struct softirq_action *) |
      +------------------------------------+
      |action                              |
      |  void (*)(struct softirq_action *) |
      +------------------------------------+

0.2 __preempt_count, a per-cpu counter
================================================================================
A 32bit value with several counters encoded.

          PREEMPT_MASK:	0x000000ff
          SOFTIRQ_MASK:	0x0000ff00
          HARDIRQ_MASK:	0x000f0000
              NMI_MASK:	0x00100000
  PREEMPT_NEED_RESCHED:	0x80000000

And related helper functions to check current status.

 * in_irq()       - We're in (hard) IRQ context
 * in_softirq()   - We have BH disabled, or are processing softirqs
 * in_interrupt() - We're in NMI,IRQ,SoftIRQ context or have BH disabled
 * in_serving_softirq() - We're in softirq context
 * in_nmi()       - We're in NMI context
 * in_task()	  - We're in task context

    |<    8bits     >|<    8bits     >|<    8bits     >|<     8bits    >|
    +-+--------------+-----+-+--------+--------------+-+----------------+
    | |              |     | |hard irq| softirq cnt  | | preempt cnt    |
    +-+--------------+-----+-+--------+--------------+-+----------------+
     ^                      ^                         ^
     |                      |                         |
     |                      |                         |
     |                      |                         |
     |                      |                         +--- Bit8:  in_serving_softirq()
     |                      +----------------------------- Bit20: NMI_MASK
     +---------------------------------------------------- Bit31: PREEMPT_NEED_RESCHED


0.3 irq_stat, per-cpu irq_cpustat_t
================================================================================

    irq_cpustat_t
    +------------------------------------+
    |__softirq_pending                   |  is local_softirq_pending_ref
    |    (u16)                           |
    |                                    |
    |                                    |
    +------------------------------------+

