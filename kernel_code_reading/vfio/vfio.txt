1. vfio_init()
================================================================================
; create /sys/class/vfio
; create char device /dev/vfio/vfio     -> vfio_fops
; create char device /dev/vfio/$GROUP   -> vfio_group_fops
; load vfio_iommu_type1 and vfio_iommu_spapr_tce
static int __init vfio_init(void)
{
	int ret;

	idr_init(&vfio.group_idr);
	mutex_init(&vfio.group_lock);
	mutex_init(&vfio.iommu_drivers_lock);
	INIT_LIST_HEAD(&vfio.group_list);
	INIT_LIST_HEAD(&vfio.iommu_drivers_list);
	init_waitqueue_head(&vfio.release_q);

	vfio.class = class_create(THIS_MODULE, "vfio");
	if (IS_ERR(vfio.class)) {
		ret = PTR_ERR(vfio.class);
		goto err_class;
	}

	vfio.class->devnode = vfio_devnode;

	ret = alloc_chrdev_region(&vfio.devt, 0, MINORMASK, "vfio");
	if (ret)
		goto err_base_chrdev;

	cdev_init(&vfio.cdev, &vfio_fops);
	ret = cdev_add(&vfio.cdev, vfio.devt, 1);
	if (ret)
		goto err_base_cdev;

	vfio.dev = device_create(vfio.class, NULL, vfio.devt, NULL, "vfio");
	if (IS_ERR(vfio.dev)) {
		ret = PTR_ERR(vfio.dev);
		goto err_base_dev;
	}

	/* /dev/vfio/$GROUP */
	cdev_init(&vfio.group_cdev, &vfio_group_fops);
	ret = cdev_add(&vfio.group_cdev,
		       MKDEV(MAJOR(vfio.devt), 1), MINORMASK - 1);
	if (ret)
		goto err_groups_cdev;

	pr_info(DRIVER_DESC " version: " DRIVER_VERSION "\n");

	/*
	 * Attempt to load known iommu-drivers.  This gives us a working
	 * environment without the user needing to explicitly load iommu
	 * drivers.
	 */
	request_module_nowait("vfio_iommu_type1");
	request_module_nowait("vfio_iommu_spapr_tce");

	return 0;

err_groups_cdev:
	device_destroy(vfio.class, vfio.devt);
err_base_dev:
	cdev_del(&vfio.cdev);
err_base_cdev:
	unregister_chrdev_region(vfio.devt, MINORMASK);
err_base_chrdev:
	class_destroy(vfio.class);
	vfio.class = NULL;
err_class:
	return ret;
}


1.1 vfio_fops(), /dev/vfio/vfio
================================================================================
static const struct file_operations vfio_fops = {
	.owner		= THIS_MODULE,
	.open		= vfio_fops_open,
	.release	= vfio_fops_release,
	.read		= vfio_fops_read,
	.write		= vfio_fops_write,
	.unlocked_ioctl	= vfio_fops_unl_ioctl,
#ifdef CONFIG_COMPAT
	.compat_ioctl	= vfio_fops_compat_ioctl,
#endif
	.mmap		= vfio_fops_mmap,
};

1.1.1 vfio_fops_open(), ,create a vfio_container
================================================================================
static int vfio_fops_open(struct inode *inode, struct file *filep)
{
	struct vfio_container *container;

	container = kzalloc(sizeof(*container), GFP_KERNEL);
	if (!container)
		return -ENOMEM;

	INIT_LIST_HEAD(&container->group_list);
	init_rwsem(&container->group_lock);
	kref_init(&container->kref);

	filep->private_data = container;

	return 0;
}

1.1.2 vfio_fops_read(), iommu_driver(vfio_iommu_type1)->ops->read
================================================================================
static ssize_t vfio_fops_read(struct file *filep, char __user *buf,
			      size_t count, loff_t *ppos)
{
	struct vfio_container *container = filep->private_data;
	struct vfio_iommu_driver *driver;
	ssize_t ret = -EINVAL;

	down_read(&container->group_lock);

	driver = container->iommu_driver;
	if (likely(driver && driver->ops->read))
		ret = driver->ops->read(container->iommu_data,
					buf, count, ppos);

	up_read(&container->group_lock);

	return ret;
}

1.1.3 vfio_fops_write(), iommu_driver(vfio_iommu_type1)->ops->write
================================================================================
static ssize_t vfio_fops_write(struct file *filep, const char __user *buf,
			       size_t count, loff_t *ppos)
{
	struct vfio_container *container = filep->private_data;
	struct vfio_iommu_driver *driver;
	ssize_t ret = -EINVAL;

	down_read(&container->group_lock);

	driver = container->iommu_driver;
	if (likely(driver && driver->ops->write))
		ret = driver->ops->write(container->iommu_data,
					 buf, count, ppos);

	up_read(&container->group_lock);

	return ret;
}

1.1.4 vfio_fops_unl_ioctl()
================================================================================
static long vfio_fops_unl_ioctl(struct file *filep,
				unsigned int cmd, unsigned long arg)
{
	struct vfio_container *container = filep->private_data;
	struct vfio_iommu_driver *driver;
	void *data;
	long ret = -EINVAL;

	if (!container)
		return ret;

	switch (cmd) {
	case VFIO_GET_API_VERSION:
		ret = VFIO_API_VERSION;
		break;
	case VFIO_CHECK_EXTENSION:
		ret = vfio_ioctl_check_extension(container, arg);
		break;
	case VFIO_SET_IOMMU:
		ret = vfio_ioctl_set_iommu(container, arg);
		break;
	default:
		down_read(&container->group_lock);

		driver = container->iommu_driver;
		data = container->iommu_data;

		if (driver) /* passthrough all unrecognized ioctls */
			ret = driver->ops->ioctl(data, cmd, arg);

		up_read(&container->group_lock);
	}

	return ret;
}

1.1.4.1 VFIO_SET_IOMMU, container->iommu_driver = driver
================================================================================

1.1.5 vfio_fops_release(), release vfio_container when no one use it
================================================================================
static int vfio_fops_release(struct inode *inode, struct file *filep)
{
	struct vfio_container *container = filep->private_data;

	filep->private_data = NULL;

	vfio_container_put(container);

	return 0;
}

1.1.5.1 vfio_container_release()
================================================================================
static void vfio_container_release(struct kref *kref)
{
	struct vfio_container *container;
	container = container_of(kref, struct vfio_container, kref);

	kfree(container);
}

1.2 vfio_ioctl_set_iommu()
================================================================================
; iterate on vfio.iommu_drivers_list
; call iommu_driver.open
; for each iommu_driver iterate on each group in group_list, call attach_group

static long vfio_ioctl_set_iommu(struct vfio_container *container,
				 unsigned long arg)
{
	struct vfio_iommu_driver *driver;
	long ret = -ENODEV;

	down_write(&container->group_lock);

	/*
	 * The container is designed to be an unprivileged interface while
	 * the group can be assigned to specific users.  Therefore, only by
	 * adding a group to a container does the user get the privilege of
	 * enabling the iommu, which may allocate finite resources.  There
	 * is no unset_iommu, but by removing all the groups from a container,
	 * the container is deprivileged and returns to an unset state.
	 */
	if (list_empty(&container->group_list) || container->iommu_driver) {
		up_write(&container->group_lock);
		return -EINVAL;
	}

	mutex_lock(&vfio.iommu_drivers_lock);
	list_for_each_entry(driver, &vfio.iommu_drivers_list, vfio_next) {
		void *data;

		if (!try_module_get(driver->ops->owner))
			continue;

		/*
		 * The arg magic for SET_IOMMU is the same as CHECK_EXTENSION,
		 * so test which iommu driver reported support for this
		 * extension and call open on them.  We also pass them the
		 * magic, allowing a single driver to support multiple
		 * interfaces if they'd like.
		 */
		if (driver->ops->ioctl(NULL, VFIO_CHECK_EXTENSION, arg) <= 0) {
			module_put(driver->ops->owner);
			continue;
		}

		/* module reference holds the driver we're working on */
		mutex_unlock(&vfio.iommu_drivers_lock);

		data = driver->ops->open(arg);
		if (IS_ERR(data)) {
			ret = PTR_ERR(data);
			module_put(driver->ops->owner);
			goto skip_drivers_unlock;
		}

		ret = __vfio_container_attach_groups(container, driver, data);
		if (!ret) {
			container->iommu_driver = driver;
			container->iommu_data = data;
		} else {
			driver->ops->release(data);
			module_put(driver->ops->owner);
		}

		goto skip_drivers_unlock;
	}

	mutex_unlock(&vfio.iommu_drivers_lock);
skip_drivers_unlock:
	up_write(&container->group_lock);

	return ret;
}

1.2.1 vfio_iommu_powerpc->ops->ioctl(VFIO_CHECK_EXTENSION), extension check
================================================================================

1.2.2 vfio_iommu_powerpc->ops->open(), give vfio_iommu_driver a chance to init
================================================================================
; create a tce_container
static void *tce_iommu_open(unsigned long arg)
{
	struct tce_container *container;

	if (arg != VFIO_SPAPR_TCE_IOMMU) {
		pr_err("tce_vfio: Wrong IOMMU type\n");
		return ERR_PTR(-EINVAL);
	}

	container = kzalloc(sizeof(*container), GFP_KERNEL);
	if (!container)
		return ERR_PTR(-ENOMEM);

	mutex_init(&container->lock);

	return container;
}

1.2.3 __vfio_container_attach_groups(), vfio_iommu_driver->attach_group
================================================================================
static int __vfio_container_attach_groups(struct vfio_container *container,
					  struct vfio_iommu_driver *driver,
					  void *data)
{
	struct vfio_group *group;
	int ret = -ENODEV;

	list_for_each_entry(group, &container->group_list, container_next) {
		ret = driver->ops->attach_group(data, group->iommu_group);
		if (ret)
			goto unwind;
	}

	return ret;

unwind:
	list_for_each_entry_continue_reverse(group, &container->group_list,
					     container_next) {
		driver->ops->detach_group(data, group->iommu_group);
	}

	return ret;
}

1.2.3.1 tce_iommu_attach_group(), do init and take iommu ownership from host
================================================================================
; this is one of the magic
; iommu group will "disconnect" the iommu from host, so that give the chance
; for guest to take over it

static int tce_iommu_attach_group(void *iommu_data,
		struct iommu_group *iommu_group)
{
	int ret;
	struct tce_container *container = iommu_data;
	struct iommu_table *tbl = iommu_group_get_iommudata(iommu_group);

	BUG_ON(!tbl);
	mutex_lock(&container->lock);

	/* pr_debug("tce_vfio: Attaching group #%u to iommu %p\n",
			iommu_group_id(iommu_group), iommu_group); */
	if (container->tbl) {
		pr_warn("tce_vfio: Only one group per IOMMU container is allowed, existing id=%d, attaching id=%d\n",
				iommu_group_id(container->tbl->it_group),
				iommu_group_id(iommu_group));
		ret = -EBUSY;
	} else if (container->enabled) {
		pr_err("tce_vfio: attaching group #%u to enabled container\n",
				iommu_group_id(iommu_group));
		ret = -EBUSY;
	} else {
		ret = iommu_take_ownership(tbl);
		if (!ret)
			container->tbl = tbl;
	}

	mutex_unlock(&container->lock);

	return ret;
}

1.3 vfio_group_fops(), /dev/vfio/$GROUP
================================================================================
static const struct file_operations vfio_group_fops = {
	.owner		= THIS_MODULE,
	.unlocked_ioctl	= vfio_group_fops_unl_ioctl,
#ifdef CONFIG_COMPAT
	.compat_ioctl	= vfio_group_fops_compat_ioctl,
#endif
	.open		= vfio_group_fops_open,
	.release	= vfio_group_fops_release,
};

1.3.1 vfio_group_fops_open(), file->private_data = vfio_group
================================================================================
; get the vfio_group and check whether it is available

static int vfio_group_fops_open(struct inode *inode, struct file *filep)
{
	struct vfio_group *group;
	int opened;

	group = vfio_group_get_from_minor(iminor(inode));
	if (!group)
		return -ENODEV;

	/* Do we need multiple instances of the group open?  Seems not. */
	opened = atomic_cmpxchg(&group->opened, 0, 1);
	if (opened) {
		vfio_group_put(group);
		return -EBUSY;
	}

	/* Is something still in use from a previous open? */
	if (group->container) {
		atomic_dec(&group->opened);
		vfio_group_put(group);
		return -EBUSY;
	}

	filep->private_data = group;

	return 0;
}

1.3.2 vfio_group_fops_release(), release
================================================================================
static int vfio_group_fops_release(struct inode *inode, struct file *filep)
{
	struct vfio_group *group = filep->private_data;

	filep->private_data = NULL;

	vfio_group_try_dissolve_container(group);

	atomic_dec(&group->opened);

	vfio_group_put(group);

	return 0;
}

1.3.3 vfio_group_fops_unl_ioctl()
================================================================================
static long vfio_group_fops_unl_ioctl(struct file *filep,
				      unsigned int cmd, unsigned long arg)
{
	struct vfio_group *group = filep->private_data;
	long ret = -ENOTTY;

	switch (cmd) {
	case VFIO_GROUP_GET_STATUS:
	{
		struct vfio_group_status status;
		unsigned long minsz;

		minsz = offsetofend(struct vfio_group_status, flags);

		if (copy_from_user(&status, (void __user *)arg, minsz))
			return -EFAULT;

		if (status.argsz < minsz)
			return -EINVAL;

		status.flags = 0;

		if (vfio_group_viable(group))
			status.flags |= VFIO_GROUP_FLAGS_VIABLE;

		if (group->container)
			status.flags |= VFIO_GROUP_FLAGS_CONTAINER_SET;

		if (copy_to_user((void __user *)arg, &status, minsz))
			return -EFAULT;

		ret = 0;
		break;
	}
	case VFIO_GROUP_SET_CONTAINER:
	{
		int fd;

		if (get_user(fd, (int __user *)arg))
			return -EFAULT;

		if (fd < 0)
			return -EINVAL;

		ret = vfio_group_set_container(group, fd);
		break;
	}
	case VFIO_GROUP_UNSET_CONTAINER:
		ret = vfio_group_unset_container(group);
		break;
	case VFIO_GROUP_GET_DEVICE_FD:
	{
		char *buf;

		buf = strndup_user((const char __user *)arg, PAGE_SIZE);
		if (IS_ERR(buf))
			return PTR_ERR(buf);

		ret = vfio_group_get_device_fd(group, buf);
		kfree(buf);
		break;
	}
	}

	return ret;
}

1.4 vfio_group_set_container(), connect vfio_group and vfio_container
================================================================================
static int vfio_group_set_container(struct vfio_group *group, int container_fd)
{
	struct fd f;
	struct vfio_container *container;
	struct vfio_iommu_driver *driver;
	int ret = 0;

	if (atomic_read(&group->container_users))
		return -EINVAL;

	f = fdget(container_fd);
	if (!f.file)
		return -EBADF;

	/* Sanity check, is this really our fd? */
	if (f.file->f_op != &vfio_fops) {
		fdput(f);
		return -EINVAL;
	}

	container = f.file->private_data;
	WARN_ON(!container); /* fget ensures we don't race vfio_release */

	down_write(&container->group_lock);

	driver = container->iommu_driver;
	if (driver) {
		ret = driver->ops->attach_group(container->iommu_data,
						group->iommu_group);
		if (ret)
			goto unlock_out;
	}

	group->container = container;
	list_add(&group->container_next, &container->group_list);

	/* Get a reference on the container and mark a user within the group */
	vfio_container_get(container);
	atomic_inc(&group->container_users);

unlock_out:
	up_write(&container->group_lock);
	fdput(f);
	return ret;
}

1.5 vfio_group_get_device_fd()
================================================================================
static int vfio_group_get_device_fd(struct vfio_group *group, char *buf)
{
	struct vfio_device *device;
	struct file *filep;
	int ret = -ENODEV;

	if (0 == atomic_read(&group->container_users) ||
	    !group->container->iommu_driver || !vfio_group_viable(group))
		return -EINVAL;

	mutex_lock(&group->device_lock);
	list_for_each_entry(device, &group->device_list, group_next) {
		if (strcmp(dev_name(device->dev), buf))
			continue;

		ret = device->ops->open(device->device_data);
		if (ret)
			break;
		/*
		 * We can't use anon_inode_getfd() because we need to modify
		 * the f_mode flags directly to allow more than just ioctls
		 */
		ret = get_unused_fd_flags(O_CLOEXEC);
		if (ret < 0) {
			device->ops->release(device->device_data);
			break;
		}

		filep = anon_inode_getfile("[vfio-device]", &vfio_device_fops,
					   device, O_RDWR);
		if (IS_ERR(filep)) {
			put_unused_fd(ret);
			ret = PTR_ERR(filep);
			device->ops->release(device->device_data);
			break;
		}

		/*
		 * TODO: add an anon_inode interface to do this.
		 * Appears to be missing by lack of need rather than
		 * explicitly prevented.  Now there's need.
		 */
		filep->f_mode |= (FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE);

		vfio_device_get(device);
		atomic_inc(&group->container_users);

		fd_install(ret, filep);
		break;
	}
	mutex_unlock(&group->device_lock);

	return ret;
}

1.5.1 vfio_device->ops->open(), create connection between vfio_device with fd
================================================================================
static int vfio_pci_open(void *device_data)
{
	struct vfio_pci_device *vdev = device_data;
	int ret = 0;

	if (!try_module_get(THIS_MODULE))
		return -ENODEV;

	mutex_lock(&driver_lock);

	if (!vdev->refcnt) {
		ret = vfio_pci_enable(vdev);
		if (ret)
			goto error;

		vfio_spapr_pci_eeh_open(vdev->pdev);
	}
	vdev->refcnt++;
error:
	mutex_unlock(&driver_lock);
	if (ret)
		module_put(THIS_MODULE);
	return ret;
}

2. vfio_add_group_dev(), add a device to vfio_group->device_list
================================================================================
; called in vfio_pci driver probe.
int vfio_add_group_dev(struct device *dev,
		       const struct vfio_device_ops *ops, void *device_data)
{
	struct iommu_group *iommu_group;
	struct vfio_group *group;
	struct vfio_device *device;

	iommu_group = iommu_group_get(dev);
	if (!iommu_group)
		return -EINVAL;

	group = vfio_group_get_from_iommu(iommu_group);
	if (!group) {
		group = vfio_create_group(iommu_group);
		if (IS_ERR(group)) {
			iommu_group_put(iommu_group);
			return PTR_ERR(group);
		}
	}

	device = vfio_group_get_device(group, dev);
	if (device) {
		WARN(1, "Device %s already exists on group %d\n",
		     dev_name(dev), iommu_group_id(iommu_group));
		vfio_device_put(device);
		vfio_group_put(group);
		iommu_group_put(iommu_group);
		return -EBUSY;
	}

	device = vfio_group_create_device(group, dev, ops, device_data);
	if (IS_ERR(device)) {
		vfio_group_put(group);
		iommu_group_put(iommu_group);
		return PTR_ERR(device);
	}

	/*
	 * Added device holds reference to iommu_group and vfio_device
	 * (which in turn holds reference to vfio_group).  Drop extra
	 * group reference used while acquiring device.
	 */
	vfio_group_put(group);

	return 0;
}

2.1 vfio_create_group(), create vfio_group /dev/vfio/#GROUP
================================================================================
; create /dev/vfio/xx for vfio_group
static struct vfio_group *vfio_create_group(struct iommu_group *iommu_group)
{
	struct vfio_group *group, *tmp;
	struct device *dev;
	int ret, minor;

	group = kzalloc(sizeof(*group), GFP_KERNEL);
	if (!group)
		return ERR_PTR(-ENOMEM);

	kref_init(&group->kref);
	INIT_LIST_HEAD(&group->device_list);
	mutex_init(&group->device_lock);
	atomic_set(&group->container_users, 0);
	atomic_set(&group->opened, 0);
	group->iommu_group = iommu_group;

	group->nb.notifier_call = vfio_iommu_group_notifier;

	/*
	 * blocking notifiers acquire a rwsem around registering and hold
	 * it around callback.  Therefore, need to register outside of
	 * vfio.group_lock to avoid A-B/B-A contention.  Our callback won't
	 * do anything unless it can find the group in vfio.group_list, so
	 * no harm in registering early.
	 */
	ret = iommu_group_register_notifier(iommu_group, &group->nb);
	if (ret) {
		kfree(group);
		return ERR_PTR(ret);
	}

	mutex_lock(&vfio.group_lock);

	minor = vfio_alloc_group_minor(group);
	if (minor < 0) {
		vfio_group_unlock_and_free(group);
		return ERR_PTR(minor);
	}

	/* Did we race creating this group? */
	list_for_each_entry(tmp, &vfio.group_list, vfio_next) {
		if (tmp->iommu_group == iommu_group) {
			vfio_group_get(tmp);
			vfio_free_group_minor(minor);
			vfio_group_unlock_and_free(group);
			return tmp;
		}
	}

	dev = device_create(vfio.class, NULL, MKDEV(MAJOR(vfio.devt), minor),
			    group, "%d", iommu_group_id(iommu_group));
	if (IS_ERR(dev)) {
		vfio_free_group_minor(minor);
		vfio_group_unlock_and_free(group);
		return (struct vfio_group *)dev; /* ERR_PTR */
	}

	group->minor = minor;
	group->dev = dev;

	list_add(&group->vfio_next, &vfio.group_list);

	mutex_unlock(&vfio.group_lock);

	return group;
}

2.2 vfio_group_create_device(), create vfio_device/ops and link to vfio_group
================================================================================
struct vfio_device *vfio_group_create_device(struct vfio_group *group,
					     struct device *dev,
					     const struct vfio_device_ops *ops,
					     void *device_data)
{
	struct vfio_device *device;
	int ret;

	device = kzalloc(sizeof(*device), GFP_KERNEL);
	if (!device)
		return ERR_PTR(-ENOMEM);

	kref_init(&device->kref);
	device->dev = dev;
	device->group = group;
	device->ops = ops;
	device->device_data = device_data;

	ret = dev_set_drvdata(dev, device);
	if (ret) {
		kfree(device);
		return ERR_PTR(ret);
	}

	/* No need to get group_lock, caller has group reference */
	vfio_group_get(group);

	mutex_lock(&group->device_lock);
	list_add(&device->group_next, &group->device_list);
	mutex_unlock(&group->device_lock);

	return device;
}

3. vfio_register_iommu_driver(), link to vfio.iommu_drivers_list
================================================================================
int vfio_register_iommu_driver(const struct vfio_iommu_driver_ops *ops)
{
	struct vfio_iommu_driver *driver, *tmp;

	driver = kzalloc(sizeof(*driver), GFP_KERNEL);
	if (!driver)
		return -ENOMEM;

	driver->ops = ops;

	mutex_lock(&vfio.iommu_drivers_lock);

	/* Check for duplicates */
	list_for_each_entry(tmp, &vfio.iommu_drivers_list, vfio_next) {
		if (tmp->ops == ops) {
			mutex_unlock(&vfio.iommu_drivers_lock);
			kfree(driver);
			return -EINVAL;
		}
	}

	list_add(&driver->vfio_next, &vfio.iommu_drivers_list);

	mutex_unlock(&vfio.iommu_drivers_lock);

	return 0;
}

0. data structure
================================================================================

   struct vfio(this is a global variable); /dev/vfio/vfio 
   +-----------------------------+    list of struct vfio_iommu_driver(registered by vfio_register_iommu_driver)
   |iommu_drivers_list        ---|--> vfio_iommu_type1 --> vfio_iommu_spapr_tce
   |                             |
   +-----------------------------+    
   |group_idr(struct idr)        |    struct vfio_group; /dev/vfio/XXX, XXX equals to iommu_group id
   |group_list                ---|--> +---------------------------------+
   | (list of struct vfio_group) |    |dev(struct device*)              | <-----------------------------------+
   |                             |    |minor(int)                       |                                     |
   |                             |    |                                 |                                     |
   |                             |    |kref(struct kref)                |                                     |
   +-----------------------------+    +---------------------------------+                                     |
   |relsease_q                   |    |                                 |   struct vfio_device                |
   |                             |    +---------------------------------+   one fd with vfio_device_ops       |
   |                             |    |device_list                   ---|-->+-----------------------------+   |
   |                             |    | (list of struct vfio_device)    |   |group                     ---|---+
   +-----------------------------+    +---------------------------------+   | (struct vfio_group*)        |
	                              |                                 |   +-----------------------------+
	                              |                                 |   |ops                          | ---> vfio_pci_ops
	                              |                                 |   |  (struct vfio_device_ops*)  |
	                              |                                 |   +-----------------------------+
                                      |                                 |   |dev                          | point to the real device
                                      |                                 |   | (struct device*)            | like pdev->dev
                                      |                                 |   +-----------------------------+  -----+
                          +---------> |                                 |   |                             |       |        struct device
                          |           |                                 |   |                             |       +------->+---------------+
                          |           |                                 |   +-----------------------------+                |iommu_group    |
                          |           +---------------------------------+                                                / |               |
                          |           |iommu_group(struct iommu_group*) |                                               /  |               |
                          |           |                              ---|-+                                    +-------+   +---------------+
                          |           +---------------------------------+ |                                   /
                          |           |                                 | |                                  /
                          |           |                                 | |                                 v
                          |           |                                 | | struct iommu_group; /sys/kernel/iommu_group/XXX
                          |           |                                 | +--+-----------------------------+
                          |           |                                 |    |devices                      | devices in this group
                          |           +---------------------------------+    |(list of struct iommu_device)|
                          |           |containter                       |    +-----------------------------+ 
                          |     +-----|   (struct vfio_container*)      |    |id(int)                      | id equals to XXX
                          |     |     +---------------------------------+    |                             |
                          |     |                                            |                             |
                          |     |                                            +-----------------------------+
    struct vfio_container |     |
                          |     v
    +---------------------|-------+       
    |group_list           |       |
    | (list of struct vfio_group) |
    +-----------------------------+    point to the iommu_driver
    |iommu_driver                 | -> vfio_iommu_spapr_tce
    |  (struct vfio_iommu_driver*)|
    +-----------------------------+
    |iommu_data                   | -> struct tce_container
    |  (void *)                   |    +-------------------------------+
    +-----------------------------+    |tbl(struct iommu_tbl)          |
                                       |                               |
                                       +-------------------------------+
                                       |                               |
                                       |                               |
                                       +-------------------------------+


					Figure.0 vfio


vfio_group is created in vfio_create_group(), in turns by vfio_add_group_dev()
	vfio_add_group_dev() will be called by vfio_pci_probe() when we attach
	a device with vfio_pci driver.
vfio_device is added to vfio_group in vfio_add_group_dev()
	when probing a pci device with vfio_pci driver, a vfio_device will be
	created

vfio_container is created on open /dev/vfio/vfio(vfio_fops_open())
vfio_container->iommu_driver is set in vfio_ioctl_set_iommu()
	this will iterate on all vfio_iommu_driver list and do attach if
	possible. And here looks like the only place to call
	iommu_driver->ops->open(), which create the vfio_container->iommu_data.
vfio_group is added to vfio_container's group_list in vfio_group_set_container()
	vfio_group_set_container() is an ioctl on /dev/vfio/$GROUP
	since the vfio_container's group_list is a list, looks a
	vfio_container could control several vfio_group

vfio_device is retrieved by the name and then exported to userspace as a fd
	the vfio_device fd is retrieved by vfio_group_get_device_fd()
	user space access the device with vfio_device_fops, with in turn use
	vfio_device->ops.
