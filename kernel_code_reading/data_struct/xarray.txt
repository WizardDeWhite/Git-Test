1. xa_init(xaray *, flags)
================================================================================
1.1 xa_init_flags(xaray *, flags)
================================================================================
spin_lock_init(&xa->xa_lock);
xa->xa_flags = flags;
xa->xa_head = NULL;

2. xa_load(xarry *, index)
================================================================================
2.1 XA_STATE(xas, xa, index)
================================================================================
2.2 entry = xas_load(&xas)
================================================================================
2.3 xas_retry(&xas, entry)
================================================================================

3. xa_store(xarray *xa, index, entry, gfp_t)
================================================================================
3.1 xa_lock(xa)
================================================================================
3.2 __xa_store(xa, index, entry, gfp)
================================================================================
3.2.1 XA_STATE(xas, xa, index)
================================================================================
3.2.1.1 xas.xa = xa
================================================================================
3.2.1.2 xas.xa_index = index
================================================================================
3.2.1.3 xas.xa_shift = 0
================================================================================
3.2.1.4 xas.xa_sibs = 0
================================================================================
3.2.1.5 xas.xa_offset = 0
================================================================================
3.2.1.6 xas.xa_node = XAS_RESTART
================================================================================
3.2.1.7 xas.xa_alloc = NULL
================================================================================
3.2.2 return error if xa_is_advanced(entry)
================================================================================
3.2.3 curr = xas_store(&xas, entry)
================================================================================
3.2.4 xas_clear_mark(&xas, XA_FREE_MARK)
================================================================================
3.2.4.1 node = xas->xa_node
================================================================================
3.2.4.2 offset = xas->xa_offset
================================================================================
3.2.4.3 node_clear_mark(node, offset, mark)
================================================================================
3.2.4.4 return if node_any_mark(node, mark), not go up parent if one of use is still set
================================================================================
3.2.4.5 offset = node->offset
================================================================================
3.2.4.6 node = xa_parent_locked(xas->xa, node)
================================================================================
3.2.5 __xas_nomem(&xas, gfp)
================================================================================
3.2.5.1 xas->xa_alloc = kmem_cache_alloc(radix_tree_node_cachep, gfp)
================================================================================
3.2.5.2 xas->xa_node = XAS_RESTART
================================================================================
3.2.6 return xas_result(&xas, curr)
================================================================================
3.2.6.1 return NULL if xa_is_zero(curr)
================================================================================
3.2.6.2 curr = xas->xa_node if xas_error(xas)
================================================================================
3.2.6.3 return curr
================================================================================
3.3 xa_unlock(xa)
================================================================================

4. xa_erase(xarry *, index)
================================================================================

5. xa_store_range(xarry *, first, last, entry, gfp_t)
================================================================================

6. xa_destroy(xarry *)
================================================================================

7. xa_empty(xarry *)
================================================================================
7.1 xa->xa_head == NULL
================================================================================

8. xa_dump(xarry *)
================================================================================

9. xas_store(xas, entry)
================================================================================
9.1 first = xas_create(xas, allow_root), create a slot to store an entry
================================================================================
9.1.1 xas_expand(xas, entry)
================================================================================
9.2 return fist if xas_invalid(&xas)
================================================================================

10. xas_load(xas)
================================================================================
10.1 entry = xas_start(xas)
================================================================================
10.1.1 entry = xa_head(xas->xa)
================================================================================
10.1.2 xas->xa_node = NULL
================================================================================
10.1.3 return entry
================================================================================
10.2 while (xa_is_node(entry))
================================================================================
10.3 node = xa_to_node(entry)
================================================================================
10.4 break if xas->xa_shift > node->shift
================================================================================
10.5 entry = xas_descend(xas, node)
================================================================================
10.5.1 offset = get_offset(xas->xa_index, node)
================================================================================
10.5.1.1 return (index >> node->shift) & XA_CHUNK_MASK;
================================================================================
10.5.2 entry = node->slots[offset]
================================================================================
10.5.3 xas->xa_node = node
================================================================================
10.5.4 return entry
================================================================================
10.6 break if node-shift == 0
================================================================================
10.7 return entry
================================================================================

10. xas_create(xas)
================================================================================
10.1 node = xas->xa_node
================================================================================
10.2 entry = xa->xa_head
================================================================================
10.3 shift = xas_expand(xas, entry), grow the tree from leaf to root
================================================================================
10.3.1 max = xas_max(xas)
================================================================================
10.3.1.1 max = xas->xa_index
================================================================================
10.3.1.2 mask = xas_size(xas) - 1
================================================================================
10.3.1.3 max |= mask
================================================================================
10.3.1.4 return max
================================================================================
10.3.2 return roundup(fls_long(max), XA_CHUNK_SHIFT) if !head
================================================================================
10.3.3 xas->xa_node = NULL
================================================================================
10.3.4 while (max > max_index(head))
================================================================================
10.4 entry = xa->xa_head
================================================================================
10.5 slot = &xa->xa_head
================================================================================
10.6 while (shift > order), grow the tree from root to leaf
================================================================================
10.7 node = xas_alloc(xas, shift)
================================================================================
10.8 entry = xas_descend(xas, node)
================================================================================
10.9 slot = &node->slots[xas->xa_offset]
================================================================================

10. xas_create_range(xas)
================================================================================
10.1 xas->xa_index |= xas_size(xas) - 1, point to the end index
================================================================================
10.2 xas_create(xas, true)
================================================================================

10. xas_find(xas, max)
================================================================================
10.1 xas_advance()
================================================================================
10.1.1 xas->xa_offset++
================================================================================
10.1.2 xas_move_index(xas, xas->xa_offset)
================================================================================

10. __xa_erase(xa, index)
================================================================================
10.1 XA_STATE(xas, xa, index)
================================================================================
10.2 xas_store(&xas, NULL)
================================================================================

10. xas_free_nodes(struct xa_state *xas, struct xa_node *top), fantastic code
================================================================================
10.1 offset = 0, node = top
================================================================================
10.2 for (;;)
================================================================================
10.3 entry = xa_entry_locked(xas->xa, node, offset)
================================================================================
10.3.1 return node->slots[offset]
================================================================================
10.4 node = xa_to_node(entry), go to next level if this is a node
================================================================================
10.5 node->slots[offset] = XA_RETRY_ENTRY if entry, set to retry
================================================================================
10.6 xas_update(xas, node)
================================================================================
10.7 xa_node_free(node)
================================================================================
10.7.1 radix_tree_node_rcu_free()
================================================================================
10.8 node = parent, up one level
================================================================================

11. xas_delete_node(xas), attempt to delete xas->xa_node and its parent
================================================================================
11.1 node = xas->xa_node
================================================================================
11.2 parent = node->parent
================================================================================
11.3 xas->xa_node = parent
================================================================================
11.4 xas->xa_offset = node->offset
================================================================================
11.5 xa_node_free(node)
================================================================================
11.5.1 radix_tree_node_rcu_free
================================================================================
11.6 parent->slots[xas->xa_offset] = NULL
================================================================================
11.7 parent->count--
================================================================================
11.8 node = parent
================================================================================
11.9 xas_update(xas, node)
================================================================================
11.10 xas_shrink(xas), shrink node if the node has only 1 entry at slot0 and descend
================================================================================
11.10.1 node = xas->xa_node
================================================================================
11.10.2 break if node->count != 1
================================================================================
11.10.3 entry = node->slots[0]
================================================================================
11.10.4 break if !entry
================================================================================
11.10.5 break if (!xa_is_node(entry) && node->shift)
================================================================================
11.10.6 entry = NULL if xa_is_zero(entry) && xa_zero_busy(xa)
================================================================================
11.10.7 xas->xa_node = XAS_BOUNDS
================================================================================
11.10.8 xa->xa_head = entry
================================================================================
11.10.9 xa_node_free(node)
================================================================================
11.10.10 node = xa_to_node(entry)
================================================================================
11.10.11 node->parent = NULL
================================================================================

0. Normal API helpers
================================================================================

0.1 xa_mk_value(v)
================================================================================
0.1.1 return (void *)((v << 1) | 1);
================================================================================
0.2 xa_is_value(entry)
================================================================================
0.2.1 return (unsigned long)entry & 1;
================================================================================
0.3 xa_to_value(entry)
================================================================================
0.3.1 return (unsigned long)entry >> 1;
================================================================================

0.4 xa_mk_internal(v)
================================================================================
0.4.1 return (void *)((v << 2) | 2);
================================================================================
0.5 xa_is_internal(entry)
================================================================================
0.5.1 return ((unsigned long)entry & 3) == 2;
================================================================================
0.6 xa_to_internal(entry)
================================================================================
0.6.1 return (unsigned long)entry >> 2;
================================================================================

0.7 xa_mk_node(struct xa_node *node), node address must be aligned to 4
================================================================================
0.7.1 return (void *)((unsigned long)node | 2);
================================================================================
0.8 xa_is_node(entry)
================================================================================
0.8.1 return xa_is_internal(entry) && (unsigned long)entry > 4096;
================================================================================
0.9 xa_to_node(entry)
================================================================================
0.9.1 return (struct xa_node *)((unsigned long)entry - 2);
================================================================================

0.10 xa_mk_sibling(offset)
================================================================================
0.10.1 return xa_mk_internal(offset);
================================================================================
0.11 xa_is_sibling(entry)
================================================================================
0.11.1 return IS_ENABLED(CONFIG_XARRAY_MULTI) && xa_is_internal(entry) && (entry < xa_mk_sibling(XA_CHUNK_SIZE - 1));
================================================================================
0.12 xa_to_sibling(entry)
================================================================================
0.12.1 return xa_to_internal(entry);
================================================================================

0.13 xa_is_err(entry)
================================================================================
0.13.1 return unlikely(xa_is_internal(entry) && entry >= xa_mk_internal(-MAX_ERRNO));
================================================================================

0. Advanced API helpers
================================================================================

0.1 xas_invalide(xas)
================================================================================
0.1.1 return (unsigned long)xas->xa_node & 3; ???
================================================================================

0.2 xas_error(xas)
================================================================================
0.2.1 return xa_err(xas->xa_node)
================================================================================
0.2.1.1 return (long)xas->xa_node >> 2 if xa_is_err(xas->xa_node)
================================================================================
0.3 xas_set_err(xas, err)
================================================================================
0.3.1 xas->xa_node = XA_ERROR(err)
================================================================================
0.3.1.1 XA_ERR(errno) (((unsigned long)errno << 2) | 2UL), encode to internal
================================================================================

0.4 xas_is_node(xax)
================================================================================
0.4.1 return !xas_invalid(xas) && xas->xa_node;
================================================================================

0.4 xas_top(node)
================================================================================
0.4.1 return node <= XAS_RESTART;
================================================================================
0.4.1.1 #define XAS_RESTART	((struct xa_node *)3UL)
================================================================================

0.5 xas_reload(xas)
================================================================================
0.5.1 node = xax->xa_node
================================================================================
0.5.2 return xa_entry(xas->xa, node, xas->xa_offset) if node
================================================================================
0.5.2.1 return node->slots[xas->xa_offset]
================================================================================
0.5.3 return xa_head(xas->xa)
================================================================================
0.5.3.1 return xa->xa_head
================================================================================

0.6 xas_set(xas, index)
================================================================================
0.6.1 xas->xa_index = index
================================================================================
0.6.2 xas->xa_node = XAS_RESTART
================================================================================

0.7 xas_set_order(xas, index, order), entry occupies 2^order indices
================================================================================
0.7.1 xas->xa_index = order < BITS_PER_LONG ? (index >> order) << order : 0; index is order aligned
================================================================================
0.7.1.1 equals xa_index = ALIGN_DOWN(index, order)
================================================================================
0.7.2 xas->xa_shift = order - (order % XA_CHUNK_SHIFT);
================================================================================
0.7.2.1 equals xa_shift = rounddown(order, XA_CHUNK_SHIFT)
================================================================================
0.7.3 xas->xa_sibs = (1 << (order % XA_CHUNK_SHIFT)) - 1;
================================================================================
0.7.3.1 so (1 << order) == (1 << xa_shift) + xa_sibs + 1
================================================================================
0.7.4 xas->xa_node = XAS_RESTART;
================================================================================

0. data structure
================================================================================

0.1 xarray
================================================================================

    xarray
    +---------------------------+
    |xa_lock                    |
    |     (spinlock_t)          |
    |xa_flags                   |
    |     (gfp_t)               |
    |xa_head                    |
    |     (void *)              |
    +---------------------------+

0.2 xa_node
================================================================================
    xa_node
    +-------------------------------------+
    |shift                                |  this node charge bits in range
    |                                     |  [shift, shift + XA_CHUNK_SHIFT - 1]
    |offset                               |  slot offset in parent
    |count                                |
    |nr_values                            |
    |      (char)                         |
    |array                                |
    |      (struct xarray*)               |
    |parent                               |
    |      (struct xa_node*)              |
    |private_list|rcu_head                |
    |      (struct list_head|rcu_head)    |
    |tags/marks                           |
    |   [XA_MAX_MARKS][XA_MARK_LONGS]     |  bitmap for each mark
    |      (unsigned long)                |  each bit represent a slot
    |                                     |
    |slots[XA_CHUNK_SIZE]                 |  1 << 6
    |      (void *)                       |
    |                                     |
    +-------------------------------------+

0.3 xa_state
================================================================================
; when order is set, 2^order entry represents xa_sibs slots in a node with
; node->shift == xa_shift

    xa_state
    +---------------------------+
    |xa                         |
    |     (xarray *)            |
    |xa_index                   |  = ALIGN_DOWN(index, order)
    |     (unsigned long)       |
    |xa_shift                   |  = rounddown(order, XA_CHUNK_SHIFT)
    |xa_sibs                    |  = 1 << (order - xa_shift) - 1
    |xa_offset                  |  = offset in xa_node->slots
    |xa_pad                     |
    |     (unsigned char)       |
    |xa_node                    |  store 1) error state 2) current node
    |xa_alloc                   |
    |     (struct xa_node*)     |
    |xa_update                  |
    |     (xa_update_node_t)    |
    +---------------------------+
 

0.4 xarray, when XA_CHUNK_SHIFT = 4
================================================================================

       xarray->xa_head = xa_node0
                         +-------------------------------+
                         |parent   = NULL                |
                         |shift    = 8                   |
                         |max_index= (1 << (8 + 4)) - 1  |
                         |offset                         |
                         |                               |
                         |slots[XA_CHUNK_SIZE]           |
                         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                         |f|e|d|c|b|a|9|8|7|6|5|4|3|2|1|0|
                         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                              |                         |
                              |                         |
                              v                         v
              xa_node2                                  xa_node1
              +-------------------------------+         +-------------------------------+
              |parent   = xa_node0            |         |parent   = xa_node0            |
              |shift    = 4                   |         |shift    = 4                   |
              |max_index= (1 << (4 + 4)) - 1  |         |max_index= (1 << (4 + 4)) - 1  |
              |offset   = d                   |         |offset   = 0                   |
              |                               |         |                               |
              |slots[XA_CHUNK_SIZE]           |         |slots[XA_CHUNK_SIZE]           |
              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
              |f|e|d|c|b|a|9|8|7|6|5|4|3|2|1|0|         |f|e|d|c|b|a|9|8|7|6|5|4|3|2|1|0|
              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                           |                         |
                                           |                         +--> [0x090, 0x09f]
                                           v
                           xa_node3
                           +-------------------------------+
                           |parent   = xa_node2            |
                           |shift    = 0                   |
                           |max_index= (1 << 4) - 1        |
                           |offset   = 1                   |
                           |                               |
                           |slots[XA_CHUNK_SIZE]           |
                           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                           |f|e|d|c|b|a|9|8|7|6|5|4|3|2|1|0|
                           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                              |                 |
                              |                 +--> 0xd15
                              +--> 0xd1e

0.5 ordered xarray
================================================================================

       xarray->xa_head = xa_node0
                         +-------------------------------+
                         |parent   = NULL                |
                         |shift    = 8                   |
                         |offset                         |
                         |                               |
                         |slots[XA_CHUNK_SIZE]           |
                         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                         |f|e|d|c|b|a|9|8|7|6|5|4|3|2|1|0|
                         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                                        |
         xa_state(order = 5)                            |
           .xa = xarray                                 v
           .xa_index = 0x090                            xa_node1
                                                        +-------------------------------+
                            descend to this level       |parent   = xa_node0            |
           .xa_shift = 4         ---------              |shift    = 4                   |
                                                        |offset   = 0                   |
                                                        |                               |
                                                        |slots[XA_CHUNK_SIZE]           |
                              occupy two slots          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           .xa_sibs  = 2         ---------              |f|e|d|c|b|a|9|8|7|6|5|4|3|2|1|0|
                                                        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                                                   | |
                                                                   +-+--> [0x090, 0x0af]

0.6 kind of entries
================================================================================
look into following places to get a picture
  * xa_dump_entry()
  * head of xarray.h
  * comment of xa_mk_internal()

(00)Pointer:
(x1)Value:
(10)Internal:
   [0, 255]       sibling entries       --+- advanced entry
   256            retry entry           -/
   257            zero entry
   > 4096         node entry(without left shift)
   >= -MAX_ERRNO  Error(never stored in slots array)


# check on entry
xa_is_value():    ((unsigned long)entry & 1)
xa_is_internal(): ((unsigned long)entry & 3) == 2
xa_is_sibling():  xa_is_internal() && entry < xa_mk_internal(XA_CHUNK_SIZE-1)
xa_is_retry():    xa_mk_internal(256)
xa_is_zero():     xa_mk_internal(257)
xa_is_node():     xa_is_internal() && > 4096, which includes xa_is_err()
xa_is_err():      xa_is_internal() && entry >= xa_mk_internal(-MAX_ERRNO)
                  the entry here never stored in slots array

# check on xas, to be specific it checks xas->xa_node
xas_valid(): !xas_invalid()
xas_invalid(): (unsigned long)xas->xa_node & 3
xas_frozen():  node & 2
xas_top():     node <= XAS_RESTART
xas_is_node(): xas_valid(xas) && xas->xa_node => !((unsigned long)xas->xa_node & 3)
               this only check xas->xa_node, which would be set to:
               * NULL(0)
               * XAS_BOUNDS(1)/XAS_RESTART(3)
               * XA_ERROR()
               * xa_to_node(entry)
xas_error():   xa_err(xas->xa_node)


0.7 userspace test
================================================================================
sudo yum install userspace-rcu-devel.x86_64
cd tools/testing/radix-tree
make
./xarray

