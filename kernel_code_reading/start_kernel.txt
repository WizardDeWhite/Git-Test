1. start_kernel
===============================================================================
start_kernel()
	lockdep_init()
	smp_setup_processor_id()
	debug_objects_early_init()

	; set up the initial canary ASAP
	boot_init_stack_canary()
	cgroup_init_early()
	local_irq_disable()
	early_boot_irqs_disabled = true;


	tick_init()
	boot_cpu_init()
	page_address_init()
	setup_arch(&command_line)
	mm_init_owner(&init_mm, &init_task)
	mm_init_cpumask(&init_mm)
	setup_command_line(command_line)
	setup_nr_cpu_ids()
	setup_per_cpu_areas()
	smp_prepare_boot_cpu()

	build_all_zonelists(NULL)
	page_alloc_init()

	parse_early_param()

	jump_label_init()

	setup_log_buf()
	pidhash_init()
	vfs_caches_init_early()
	sort_main_extable()
	trap_init()
	mm_init()

	sched_init()
	preempt_disable()

	idr_init_cache()
	perf_event_init()
	rcu_init()
	radix_tree_init()
	early_irq_init()
	init_IRQ()
	prio_tree_init()
	init_timers()
	hrtimers_init()
	softirq_init()
	timekeeping_init()
	time_init()
	profile_init()
	call_function_init()
	early_boot_irqs_disabled = false;
	local_irq_enable()

	gfp_allowed_mask = __GFP_BITS_MASK;

	kmem_cache_init_late()

	console_init()
	lockdep_info()

	locking_selftest()

	page_cgroup_init()
	debug_objects_mem_init()
	kmemleak_init()
	setup_per_cpu_pageset()
	numa_policy_init()
	sched_clock_init()
	calibrate_delay()
	pidmap_init()
	anon_vma_init()

	thread_info_cache_init()
	cred_init()
	fork_init(totalram_pages)
	proc_caches_init()
	buffer_init()
	key_init()
	security_init()
	dbg_late_init()
	vfs_caches_init(totalram_pages)
	signals_init()
	page_writeback_init()
	proc_root_init()
	cgroup_init()
	cpuset_init()
	taskstats_init_early()
	delayacct_init()

	check_bugs()

	acpi_early_init()
	sfi_init_late()
	ftrace_init()
	rest_init(); process 0

2. rest_init()  last part of process 0
===============================================================================
this is the last part of process 0
after fork two thread, it call cpu_idle()
rest_init()
	rcu_scheduler_starting();
	kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND); process 1
	numa_default_policy();
	pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES); process 2
	rcu_read_lock();
	kthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);
	rcu_read_unlock();
	complete(&kthreadd_done);

	init_idle_bootup_task(current);
	schedule_preempt_disabled();
	cpu_idle();

2.1 kernel_init(), now process 1 come to earch
===============================================================================
kernel_init()
	wait_for_completion(&kthreadd_done)
	set_mems_allowed(node_states[N_HIGH_MEMORY])
	set_cpus_allowed_ptr(current, cpu_all_mask)
	cad_pid = task_pid(current);
	smp_prepare_cpus(setup_max_cpus)
	dp_pre_smp_initcalls();
	lockup_detector_init()
	smp_init()
	sched_init_smp()
	do_basic_setup()

	/* Open the /dev/console on the rootfs, this should never fail */
	if (sys_open((const char __user *) "/dev/console", O_RDWR, 0) < 0)
		printk(KERN_WARNING "Warning: unable to open an initial console.\n");

	(void) sys_dup(0);
	(void) sys_dup(0);
	/*
	 * check if there is an early userspace init.  If yes, let it do all
	 * the work
	 */

	if (!ramdisk_execute_command)
		ramdisk_execute_command = "/init";

	if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0) {
		ramdisk_execute_command = NULL;
		prepare_namespace();
	}

	/*
	 * Ok, we have completed the initial bootup, and
	 * we're essentially up and running. Get rid of the
	 * initmem segments and start the user-mode stuff..
	 */

	init_post()

2.1.1 do_basic_setup()
===============================================================================
do_basic_setup()
	cpuset_init_smp()
	usermodehelper_init()
	shmem_init()
	driver_init()
	init_irq_proc()
	do_ctos()
	usermodehelper_enable()
	do_initcalls()

2.1.1.1 driver_init(), initialize driver model
===============================================================================
driver_init(void)
{
	/* These are the core pieces */
	devtmpfs_init();
	devices_init();
	buses_init();
	classes_init();
	firmware_init();
	hypervisor_init();

	/* These are also core pieces, but must come after the
	 * core core pieces.
	 */
	platform_bus_init();
	cpu_dev_init();
	memory_dev_init();
}

2.1.1.1.1 devices_init(), initialize those root kset
===============================================================================
devices_init(void)
{
	devices_kset = kset_create_and_add("devices", &device_uevent_ops, NULL);
	if (!devices_kset)
		return -ENOMEM;
	dev_kobj = kobject_create_and_add("dev", NULL);
	if (!dev_kobj)
		goto dev_kobj_err;
	sysfs_dev_block_kobj = kobject_create_and_add("block", dev_kobj);
	if (!sysfs_dev_block_kobj)
		goto block_kobj_err;
	sysfs_dev_char_kobj = kobject_create_and_add("char", dev_kobj);
	if (!sysfs_dev_char_kobj)
		goto char_kobj_err;

	return 0;

 char_kobj_err:
	kobject_put(sysfs_dev_block_kobj);
 block_kobj_err:
	kobject_put(dev_kobj);
 dev_kobj_err:
	kset_unregister(devices_kset);
	return -ENOMEM;
}

2.1.1.2 do_initcalls(), do initialization based on the initial level
===============================================================================
go throught the initcall_levels table, call init call for different part
do_initcalls()
	for (level = 0; level < ARRAY_SIZE(initcall_levels) - 1; level++)
		do_initcall_level(level);

do_initcall_levle()
	for (fn = initcall_levels[level]; fn < initcall_levels[level+1]; fn++)
		do_one_initcall(*fn);
			fn() ; call the function here

the inicall_levels is a static arrary of address
static initcall_t *initcall_levels[] __initdata = {
	__initcall0_start,
	__initcall1_start,
	__initcall2_start,
	__initcall3_start,
	__initcall4_start,
	__initcall5_start,
	__initcall6_start,
	__initcall7_start,
	__initcall_end,
};

Take a look at INIT_CALLS macro.

2.1.2 init_post(), start process 1
===============================================================================
this thread is responsible for start process 1
at last it create a user space process 1
init_post()
	async_synchronize_full()
	free_initmem()
	mark_rodata_ro()
	system_state = SYSTEM_RUNNING;
	numa_default_policy();

	current->signal->flags |= SIGNAL_UNKILLABLE;

	if (ramdisk_execute_command) {
		run_init_process(ramdisk_execute_command)
		printk(KERN_WARNING "Failed to execute");
	}

	if (execute_command) {
		run_init_process(execute_command);
		printk(KERN_WARNING "Failed to execute");
	}

	run_init_process("/sbin/init");
	run_init_process("/etc/init");
	run_init_process("/bin/init");
	run_init_process("/bin/sh");

	panic("No init found. Try passing init= option to kernel."
		"See Linux Documentation/init.txt for guidance");

