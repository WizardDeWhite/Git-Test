1. pnv_pci_ioda_setup_dma_pe(), create iommu_group for each PE
================================================================================
iommu_register_group(tbl, pci_domain_nr(pe->pbus), pe->pe_number);

set_iommu_table_base(&pe->pdev->dev, tbl);

1.1 iommu_register_group(), create an iommu_group for each PE
================================================================================
void iommu_register_group(struct iommu_table *tbl,
		int pci_domain_number, unsigned long pe_num)
{
	struct iommu_group *grp;
	char *name;

	grp = iommu_group_alloc();
	if (IS_ERR(grp)) {
		pr_warn("powerpc iommu api: cannot create new group, err=%ld\n",
				PTR_ERR(grp));
		return;
	}
	tbl->it_group = grp;
	iommu_group_set_iommudata(grp, tbl, group_release);
	name = kasprintf(GFP_KERNEL, "domain%d-pe%lx",
			pci_domain_number, pe_num);
	if (!name)
		return;
	iommu_group_set_name(grp, name);
	kfree(name);
}

1.1.1 iommu_group_alloc(), register iommu_group in system
================================================================================
assign an ID, group->id

1.1.2 iommu_group_set_iommudata(), group arch data set to tbl
================================================================================
void iommu_group_set_iommudata(struct iommu_group *group, void *iommu_data,
			       void (*release)(void *iommu_data))
{
	group->iommu_data = iommu_data;
	group->iommu_data_release = release;
}

1.1.3 iommu_group_set_name(), /sys/kernel/iommu_group/#/group->name?
================================================================================
int iommu_group_set_name(struct iommu_group *group, const char *name)
{
	int ret;

	if (group->name) {
		iommu_group_remove_file(group, &iommu_group_attr_name);
		kfree(group->name);
		group->name = NULL;
		if (!name)
			return 0;
	}

	group->name = kstrdup(name, GFP_KERNEL);
	if (!group->name)
		return -ENOMEM;

	ret = iommu_group_create_file(group, &iommu_group_attr_name);
	if (ret) {
		kfree(group->name);
		group->name = NULL;
		return ret;
	}

	return 0;
}

1.1.3.1 iommu_group_create_file()
================================================================================
static int iommu_group_create_file(struct iommu_group *group,
				   struct iommu_group_attribute *attr)
{
	return sysfs_create_file(&group->kobj, &attr->attr);
}

1.2 set_iommu_table_base(), set iommu_group arch specific data
================================================================================
static inline void set_iommu_table_base(struct device *dev, void *base)
{
	dev->archdata.dma_data.iommu_table_base = base;
}

2. tce_iommu_init(), add device to iommu_group, done after pci tree enumerated
================================================================================
subsys_initcall_sync(tce_iommu_init);
#define subsys_initcall_sync(fn)	__define_initcall(fn, 4s)

; one thing to be noticed, this call is called after pcibios_init which 
; subsys_initcall(). 
; which means when it is called, the pci device tree is created.

static int __init tce_iommu_init(void)

	struct pci_dev *pdev = NULL;

	BUILD_BUG_ON(PAGE_SIZE < IOMMU_PAGE_SIZE);

	for_each_pci_dev(pdev)
		iommu_add_device(&pdev->dev);

	bus_register_notifier(&pci_bus_type, &tce_iommu_bus_nb);
	return 0;
}

2.1 iommu_add_device(), add already created devices to the iommu_group
================================================================================
; iommu_group are already there
static int iommu_add_device(struct device *dev)
{
	struct iommu_table *tbl;
	int ret = 0;

	if (WARN_ON(dev->iommu_group)) {
		pr_warn("iommu_tce: device %s is already in iommu group %d, skipping\n",
				dev_name(dev),
				iommu_group_id(dev->iommu_group));
		return -EBUSY;
	}

	tbl = get_iommu_table_base(dev);
	if (!tbl || !tbl->it_group) {
		pr_debug("iommu_tce: skipping device %s with no tbl\n",
				dev_name(dev));
		return 0;
	}

	pr_debug("iommu_tce: adding %s to iommu group %d\n",
			dev_name(dev), iommu_group_id(tbl->it_group));

	ret = iommu_group_add_device(tbl->it_group, dev);
	if (ret < 0)
		pr_err("iommu_tce: %s has not been added, ret=%d\n",
				dev_name(dev), ret);

	return ret;
}

2.1.1 get_iommu_table_base(), check whether a iommu_table is associated
================================================================================

2.1.2 iommu_group_add_device()
================================================================================

2.2 tce_iommu_bus_nb(), this is called in device_add/device_del for each device
================================================================================
static struct notifier_block tce_iommu_bus_nb = {
	.notifier_call = iommu_bus_notifier,
};

static int iommu_bus_notifier(struct notifier_block *nb,
			      unsigned long action, void *data)
{
	struct device *dev = data;

	switch (action) {
	case BUS_NOTIFY_ADD_DEVICE:
		return iommu_add_device(dev);
	case BUS_NOTIFY_DEL_DEVICE:
		iommu_del_device(dev);
		return 0;
	default:
		return 0;
	}
}

2.2.1 iommu_add_device(), add dev into a iommu_group
================================================================================

0. Data structures
================================================================================

     struct iommu_group
     +----------------------------+<------------------------------------+
     |id(int)                     |                                     |
     +----------------------------+                                     |
     |kobj                        |                                     |
     |                            |                                     |
     |devices_kobj                |     struct iommu_device             |
     +----------------------------+     +-----------------------+       |
     |devices(list_head)          |---->+list(list_head)        |       |
     | (list struct iommu_device) |     +-----------------------+       |
     +----------------------------+     |dev(struct device)     |       |
     |notifier                    |     |      iommu_group   -----------+
     |   (blocking_notifier_head) |     +-----------------------+ 
     |                            |     |name                   |
     |                            |     +-----------------------+
     |                            |
     +----------------------------+     struct iommu_table*(so one iommu_table map one iommu_group)
     |iommu_data                  |---->+---------------------+
     |   (void *)                 |     |                     |
     |iommu_data_release          |     |                     |
     |   (void (*)(void *))       |     |                     |
     |                            |     +---------------------+
     +----------------------------+
	Figure 2.1 iommu_group
