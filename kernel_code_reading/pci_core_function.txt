1. pci_create_root_bus()
===============================================================================
pci_create_root_bus(struct device *parent, int bus,
		struct pci_ops *ops, void *sysdata, struct list_head *resources)
	struct pci_host_bridge *host_bridge;
	host_bridge = kzalloc(sizeof(*host_bridge), GFP_KERNEL);

	struct pci_bus *b;
	b = pci_alloc_bus();

	struct device *dev;
	dev = kzalloc(sizeof(*dev), GFP_KERNEL);

	b->sysdata = sysdata;
	b->ops = ops;

	b2 = pci_find_bus(pci_domain_nr(b), bus);
	if (b2) goto err_out;

	dev->parent = parent;
	dev->release = pci_release_bus_bridge_dev;
	dev_set_name(dev, "pci%04x:%02x", pci_domain_nr(b), bus);
	error = device_register(dev);

	b->bridge = get_device(dev);
	device_enable_async_suspend(b->bridge);
	pci_set_bus_of_node(b);

	b->dev.class = &pcibus_class;
	b->dev.parent = b->bridge;
	dev_set_name(&b->dev, "%04x:%02x", pci_domain_nr(b), bus);
	error = device_register(&b->dev);
	pci_create_legacy_files(b);
	b->number = b->secondary = bus;

	host_bridge->bus = b;
	INIT_LIST_HEAD(&host_bridge->windows);

	/* Add initial resources to the bus */
	; add the resource in *resources* list to bus->resources list
	pci_bus_add_resource()

	list_add_tail(&host_bridge->list, &pci_host_bridges);
        list_add_tail(&b->node, &pci_root_buses);
                                                
                                                
                                                
                                                            
       host_bridge(struct pci_host_bridge)      
       +-------------------+                   
       | windows           |                              +->parent(first parameter of 
       +-------------------+                              |         pci_create_root_bus)
       |bus(struct pci_bus)|                              |
       +-------------------+                              +---------------------+
        |                                                                       |
        |                                                                       |
        |                                                 dev(struct device)    |
        |                                           +---->+----------------+    |
        |                                           |     |   parent       |----+
        |    pci_root_bus(struct pci_bus)           |     +----------------+          
        +--->+-------------------------------+      |     |                | 
             |dev(struct device)             |      |     |                |
             |   class = pcibus_class        |      |     +----------------+
             |   parent      ----------------|---+  |
             |                               |   |  |
             +-------------------------------+<--+  |
             |bridge(struct device)          |      |
             |                               |------+
             +-------------------------------+
             |self(struct pci_dev) = NULL    |
             +-------------------------------+
             |number = bus                   |
             +-------------------------------+  
             |secondary = bus                |  
             +-------------------------------+  
             |resources(list_head)           |  
             |     a list of io/mem resource |
             |     available for this bus    |  
             +-------------------------------+  

                Figure 1.1 relationship between pci_root_bus/host_bridge


2. pci_scan_child_bus(), give the a pci bus, create the sub pci tree
===============================================================================
pci_scan_child_bus(struct pci_bus *bus)
	max = bus->secondary

	/* Go find them, Rover! */
	for (devfn = 0; devfn < 0x100; devfn += 8)
		pci_scan_slot(bus, devfn);

	/* Reserve buses for SR-IOV capability. */
	max += pci_iov_bus_range(bus);

	if (!bus->is_added) {
		dev_dbg(&bus->dev, "fixups for bus\n");
		pcibios_fixup_bus(bus);
		if (pci_is_root_bus(bus))
			bus->is_added = 1;
	}

	for (pass=0; pass < 2; pass++)
		list_for_each_entry(dev, &bus->devices, bus_list) {
			if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
			    dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)
				max = pci_scan_bridge(bus, dev, max, pass);
		}

	return max;

2.2 pci_is_root_bus()
===============================================================================
pci_is_root_bus(struct pci_bus *pbus)
	return !(pbus->parent);

the bus is a root bus when it doesn't have parent.

2.3 pci_scan_slot()
===============================================================================
pci_scan_slot(struct pci_bus *bus, int devfn)
	if (only_one_child(bus) && (devfn > 0))
		return 0; /* Already scanned the entire slot */

	dev = pci_scan_single_device(bus, devfn);
	if (!dev->is_added)
		nr++;

	; calculate fn based on different scheme and call
	pci_scan_single_device(bus, devfn + fn), nr++ if needed

	/* only one slot has pcie device */
	if (bus->self && nr)
		pcie_aspm_init_link_state(bus->self);

	return nr; return the number of newly find pci device

2.4 pci_scan_single_device()
===============================================================================
pci_scan_single_device(struct pci_bus *bus, int devfn)
	struct pci_dev *dev;

	dev = pci_scan_device(bus, devfn);

	pci_device_add(dev, bus);

2.4.1 pci_scan_device()
===============================================================================
pci_scan_device(struct pci_bus *bus, int devfn)
	struct pci_dev *dev;

	dev = alloc_pci_dev();

	dev->bus = bus;
	dev->devfn = devfn;
	dev->vendor = l & 0xffff;
	dev->device = (l >> 16) & 0xffff;

	pci_setup_device(dev);

2.4.1.1 pci_setup_device(), setup the newly found pci_dev
===============================================================================
; set the type, parent, and resource
pci_setup_device(struct pci_dev *dev )
	; get header type, 00h device, 01h bridge, 02h Card Bus
	if (pci_read_config_byte(dev, PCI_HEADER_TYPE, &hdr_type))

	dev->sysdata = dev->bus->sysdata;
	dev->dev.parent = dev->bus->bridge;
	dev->dev.bus = &pci_bus_type;
	dev->hdr_type = hdr_type & 0x7f;

	dev_set_name(&dev->dev, "%04x:%02x:%02x.%d", pci_domain_nr(dev->bus),
		     dev->bus->number, PCI_SLOT(dev->devfn),
		     PCI_FUNC(dev->devfn));

	; early fixups
	pci_fixup_device(pci_fixup_early, dev);

	switch(dev->hdr_typ) { ; three types
	case PCI_HEADER_TYPE_NORMAL:
		pci_read_irq(dev);
		pci_read_bases(dev, 6, PCI_ROM_ADDRESS);
		pci_read_config_word(dev, PCI_SUBSYSTEM_VENDOR_ID, &dev->subsystem_vendor);
		pci_read_config_word(dev, PCI_SUBSYSTEM_ID, &dev->subsystem_device);
	case PCI_HEADER_TYPE_BRIDGE:
		pci_read_irq(dev);
		dev->transparent = ((dev->class & 0xff) == 1);
		pci_read_bases(dev, 2, PCI_ROM_ADDRESS1);
		set_pcie_hotplug_bridge(dev);
		pos = pci_find_capability(dev, PCI_CAP_ID_SSVID);
		if (pos) {
			pci_read_config_word(dev, pos + PCI_SSVID_VENDOR_ID, &dev->subsystem_vendor);
			pci_read_config_word(dev, pos + PCI_SSVID_DEVICE_ID, &dev->subsystem_device);
		}
	case PCI_HEADER_TYPE_CARDBUS:
		pci_read_irq(dev);
		pci_read_bases(dev, 1, 0);
		pci_read_config_word(dev, PCI_CB_SUBSYSTEM_VENDOR_ID, &dev->subsystem_vendor);
		pci_read_config_word(dev, PCI_CB_SUBSYSTEM_ID, &dev->subsystem_device);
	}

	return 0;



               struct pci_dev
               +------------------------------------+
               |dev(struct device)                  |
               |   bus (attached to which bus)      |
               |       bridge                       |<----+
               |   devfn (device/function number)   |     |
               |   vendor (vendor ID)               |     |
               |   device (device ID)               |     |
               |   parent           ----------------|-----+
               |   bus = &pci_bus_type              |
               +------------------------------------+
               |resource                            |
               |    (an array of struct resource)   |
               |    retrieve addreess from BAR      |
               |                                    |
               |                                    |
               +------------------------------------+

               Figure 2.1 newly added pci_dev structure


2.4.1.1.1 pci_read_bases(), setup pci_dev->resource from BAR 
===============================================================================
pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
	; howmany/rom is determined by the pci_dev type
	for (pos = 0; pos < howmany; pos++) {
		struct resource *res = &dev->resource[pos];
		reg = PCI_BASE_ADDRESS_0 + (pos << 2);
		pos += __pci_read_base(dev, pci_bar_unknown, res, reg);
	}

	if (rom) {
		struct resource *res = &dev->resource[PCI_ROM_RESOURCE];
		dev->rom_base_reg = rom;
		res->flags = IORESOURCE_MEM | IORESOURCE_PREFETCH |
				IORESOURCE_READONLY | IORESOURCE_CACHEABLE |
				IORESOURCE_SIZEALIGN;
		__pci_read_base(dev, pci_bar_mem32, res, rom);
	}

2.4.2 pci_device_add()
===============================================================================
pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
	device_initialize(&dev->dev);
	dev->dev.release = pci_release_dev;
	pci_dev_get(dev);

	pci_init_capabilities(dev);

	; add to the bus->devices list
	list_add_tail(&dev->bus_list, &bus->devices);

2.4.2.1 pci_init_capabilities()
===============================================================================
pci_init_capabilities(struct pci_dev *dev)
	/* MSI/MSI-X list */
	pci_msi_init_pci_dev(dev);

	/* Buffers for saving PCIe and PCI-X capabilities */
	pci_allocate_cap_save_buffers(dev);

	/* Power Management */
	pci_pm_init(dev);
	platform_pci_wakeup_init(dev);

	/* Vital Product Data */
	pci_vpd_pci22_init(dev);

	/* Alternative Routing-ID Forwarding */
	pci_enable_ari(dev);

	/* Single Root I/O Virtualization */
	pci_iov_init(dev);

	/* Enable ACS P2P upstream forwarding */
	pci_enable_acs(dev);

2.5 pci_scan_bridge()
===============================================================================
pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 ; bus is the bus where the dev attached to 
 ; dev is a pci_dev whose type is brige or cardbus
 ; max is the max bus number we have met
 ; pass indidate the pass index
 * We need to process bridges in two passes -- first we scan those
 * already configured by the BIOS and after we are done with all of
 * them, we proceed to assigning numbers to the remaining buses in
 * order to avoid overlaps between old and new bus numbers.

 	; for both bridge and cardbus, 0x18-0x1a is the bus number
	; retrieve the bus number from bridge which is set 
	; by firmware
	pci_read_config_dword(dev, PCI_PRIMARY_BUS, &buses);
	primary = buses & 0xFF;
	secondary = (buses >> 8) & 0xFF;
	subordinate = (buses >> 16) & 0xFF;

	; check the bus number
	; 1. primary should equals to bus->number
	; 2. secondary bus number should bigger than primary
	if (!pass &&
	    (primary != bus->number || secondary <= bus->number)) {
		dev_dbg(&dev->dev, "bus configuration invalid, reconfiguring\n");
		broken = 1;
	}

	; disable MasterAbortMode, to do the real work
	pci_write_config_word(dev, PCI_BRIDGE_CONTROL,
			      bctl & ~PCI_BRIDGE_CTL_MASTER_ABORT);


	; pass 0, 
	; the normal case
		child = pci_find_bus(pci_domain_nr(bus), secondary);
		if (!child) {
			child = pci_add_new_bus(bus, dev, secondary);
			if (!child)
				goto out;
			child->primary = primary;
			child->subordinate = subordinate;
			child->bridge_ctl = bctl;
		}

		cmax = pci_scan_child_bus(child);
		if (cmax > max)
			max = cmax;
		if (child->subordinate > max)
			max = child->subordinate;
	
	; pass 1
	; handle the bridge which is not configured well by firmware
		/* Clear errors */
		pci_write_config_word(dev, PCI_STATUS, 0xffff);

		; prevent assigning a bus number that already
		; exist
		child = pci_find_bus(pci_domain_nr(bus), max+1);
		if (!child) {
			child = pci_add_new_bus(bus, dev, ++max);
			if (!child)
				goto out;
		}
		buses = (buses & 0xff000000)
		      | ((unsigned int)(child->primary)     <<  0)
		      | ((unsigned int)(child->secondary)   <<  8)
		      | ((unsigned int)(child->subordinate) << 16);

		; write the device
		pci_write_config_dword(dev, PCI_PRIMARY_BUS, buses);

		pci_fixup_parent_subordinate_busnr(child, max);
		/* Now we can scan all subordinate buses... */
		max = pci_scan_child_bus(child);
		/*
		 * now fix it up again since we have found
		 * the real value of max.
		 */
		pci_fixup_parent_subordinate_busnr(child, max);

		child->subordnate = max;
		pci_write_config_byte(dev, PCI_SUBORDINATE_BUS， max);
	return max;

2.5.1 pci_add_new_bus()
===============================================================================
pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev, int busnr)
	struct pci_bus *child;

	child = pci_alloc_child_bus(parent, dev, busnr);
	if (child) {
		down_write(&pci_bus_sem);
		list_add_tail(&child->node, &parent->children);
		up_write(&pci_bus_sem);
	}
	return child;

2.5.1.1 pci_alloc_child_bus()
===============================================================================
pci_alloc_child_bus(struct pci_bus *parent, struct pci_dev *bridge, int busnr)
	child = pci_alloc_bus()

	child->parent = parent;
	child->ops = parent->ops;
	child->sysdata = parent->sysdata;

	child->dev.class = &pcibus_class;
	dev_set_name(&child->dev, ...);

	child->number = child->secondary = busnr;
	child->primary = parent->secondary;
	child->subordinate = 0xff;

	if (!bridge)
		return child;

	child->self = bridge;
	child->bridge = get_device(&bridge->dev);
	pci_set_bus_of_node(child);
	pci_set_bus_speed(child);

	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++) {
		child->resource[i] = &bridge->resource[PCI_BRIDGE_RESOURCES+i];
		child->resource[i]->name = child->name;
	}
	
	; a bridge pci_dev has its subordinate
	bridge->subordinate = child;

	return child;

             -------+---------      Bus 00(pci_bus) <-------------------+
                    |                 +---secondary(00) <---------------|------+
           +--------+--------+                                          |      |
           |     00:02.0     |                                          |      |
           | PCIe-PCI bridge |<--------------------------------------------+   |
           | (pci_dev)       |                                          |  |   |
           |     dev         |<----------------------------------------------+ |
           +--------+--------+                                          |  | | |
                    |                            +--------------------+ |  | | |
                    |                            |parent              |-+  | | |
         +---------------------+ Bus 02(pci_bus) +--------------------+    | | |
         |                     |                 |self(pci_dev)       |----+ | |
         |                     |                 +--------------------+      | |
         |                     |                 |bridge(device)      |------+ |                              
         |                     |                 +--------------------+        |                              
         |                     |                 |primary             |--------+                              
         |                     |                 +--------------------+                                       
         |                     |                 |resource(struct *)  |            
         |                     |                 |  point to corres-  |
    +----v----+           +----v----+            |  ponding bridge res|
    | 02:00.0 |           | 02:01.0 |            |  in self, which is |
    |(pci_dev)|           |(pci_dev)|            |  the bridge        |
    +---------+           +---------+            +--------------------+

                     Figure 2.2 newly added pci_bus and its parent
                     (this is an example, the number could be different)

2.5.2 pci_fixup_parent_subordinate_busnr(), fix parent bus number
===============================================================================
pci_fixup_parent_subordinate_busnr(struct pci_bus *child, int max)
	struct pci_bus *parent = child->parent;

	/* Attempts to fix that up are really dangerous unless
	   we're going to re-assign all bus numbers. */
	if (!pcibios_assign_all_busses())
		return;

	while (parent->parent && parent->subordinate < max) {
		parent->subordinate = max;
		pci_write_config_byte(parent->self, PCI_SUBORDINATE_BUS, max);
		parent = parent->parent;
	}

3. __pci_read_base() read the BAR in config space, set to pci_dev->resource[]
===============================================================================
__pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
		struct resource *res, unsigned int pos)
	; pos is pointed to the BAR position in PCI config space
	; below is to retrieve the BAR address and size
	pci_read_config_dword(dev, pos, &l);
	pci_write_config_dword(dev, pos, l | mask);
	pci_read_config_dword(dev, pos, &sz);
	pci_write_config_dword(dev, pos, l);

	; l is the base address
	; sz is the size

	struct pci_bus_region region;

	region.start = l;
	region.end = l +sz;

	pcibios_bus_to_resource(dev, res, &region);

3.1 pcibios_bus_to_resource(), calculate CPU address of BAR, set to pci_dev->resource
===============================================================================
pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
		strutct pci_bus_region *region)
	struct pci_host_bridge *bridge = pci_host_bridge(dev);
	struct pci_host_bridge_window *window;
	struct pci_bus_region bus_region;
	resource_size_t offset = 0;

	; go throught the bridge window list
	; find the offset
	list_for_each_entry(window, &bridge->windows, list) {
		if (resource_type(res) != resource_type(window->res))
			continue;

		bus_region.start = window->res->start - window->offset;
		bus_region.end = window->res->end - window->offset;

		if (region_contains(&bus_region, region)) {
			offset = window->offset;
			break;
		}
	}

	; set the real CPU address to pci_dev->resource
	res->start = region->start + offset;
	res->end = region->end + offset;

4. pci_find_bus(), find the bus with given domain and bus number
===============================================================================
pci_find_bus(int domain, int busnr)
	while ((bus = pci_find_next_bus(bus)) != NULL)  {
		if (pci_domain_nr(bus) != domain)
			continue;
		tmp_bus = pci_do_find_bus(bus, busnr);
		if (tmp_bus)
			return tmp_bus;
	}
	return NULL;

4.1 pci_find_next_bus()
===============================================================================
pci_find_next_bus(struct pci_bus *from)
	n = from ? from->node.next : pci_root_buses.next;
	if (n != &pci_root_buses)
		b = pci_bus_b(n);
	return b;

4.2 pci_do_find_bus()
===============================================================================
pci_do_find_bus(struct pci_bus *bus, unsigned char busnr)
	if(bus->number == busnr)
		return bus;

	list_for_each(tmp, &bus->children) {
		child = pci_do_find_bus(pci_bus_b(tmp), busnr);
		if(child)
			return child;
	}
	return NULL;

5. pci_bus_add_devices(), go throught the root bus and add devices
===============================================================================
 * Add newly discovered PCI devices (which are on the bus->devices
 * list) to the global PCI device list, add the sysfs and procfs
 * entries.  Where a bridge is found, add the discovered bus to
 * the parents list of child buses, and recurse (breadth-first
 * to be compatible with 2.4)
 	; go throught the devices just under current bus
	; and add to system
	list_for_each_entry(dev, &bus->devices, bus_list) {
		/* Skip already-added devices */
		if (dev->is_added)
			continue;
		retval = pci_bus_add_device(dev);
		if (retval)
			dev_err(&dev->dev, "Error adding device, continuing\n");
	}

	list_for_each_entry(dev, &bus->devices, bus_list) {
		BUG_ON(!dev->is_added);

		child = dev->subordinate;
		/*
		 * If there is an unattached subordinate bus, attach
		 * it and then scan for unattached PCI devices.
		 */
		if (!child)
			continue;
		; add child to parent->children
		if (list_empty(&child->node)) {
			down_write(&pci_bus_sem);
			list_add_tail(&child->node, &dev->bus->children);
			up_write(&pci_bus_sem);
		}
		pci_bus_add_devices(child);

		/*
		 * register the bus with sysfs as the parent is now
		 * properly registered.
		 */
		if (child->is_added)
			continue;
		retval = pci_bus_add_child(child);
		if (retval)
			dev_err(&dev->dev, "Error adding bus, continuing\n");
	}

5.1 pci_bus_add_device(), register pci_dev->dev, create sysfs entry
===============================================================================
pci_bus_add_device(struct pci_dev *dev)
	retval = device_add(&dev->dev);
	if (retval)
		return retval;

	dev->is_added = 1;
	pci_proc_attach_device(dev);
	pci_create_sysfs_dev_files(dev);
	return 0;

5.2 pci_bus_add_child(), register the bus->dev, create sysfs entry
===============================================================================
pci_bus_add_child(struct pci_bus *bus)
	if (bus->bridge)
		bus->dev.parent = bus->bridge;

	retval = device_register(&bus->dev);
	if (retval)
		return retval;

	bus->is_added = 1;

	/* Create legacy_io and legacy_mem files for this bus */
	pci_create_legacy_files(bus);

	return retval;

6. pcie_bus_configure_settings()
===============================================================================
pcie_bus_configure_settings(struct pci_bus *bus, u8 mpss)
	if (!pci_is_pcie(bus->self))
		return;

	if (pcie_bus_config == PCIE_BUS_TUNE_OFF)
		return;

	/* FIXME - Peer to peer DMA is possible, though the endpoint would need
	 * to be aware to the MPS of the destination.  To work around this,
	 * simply force the MPS of the entire system to the smallest possible.
	 */
	if (pcie_bus_config == PCIE_BUS_PEER2PEER)
		smpss = 0;

	if (pcie_bus_config == PCIE_BUS_SAFE) {
		smpss = mpss;

		pcie_find_smpss(bus->self, &smpss);
		pci_walk_bus(bus, pcie_find_smpss, &smpss);
	}

	pcie_bus_configure_set(bus->self, &smpss);
	pci_walk_bus(bus, pcie_bus_configure_set, &smpss);

6.1 pcie_find_smpss()
===============================================================================
pcie_find_smpss(struct pci_dev *dev, void *data)

6.2 pci_walk_bus(), walk devices on/under bus, calling callback
===============================================================================
pci_walk_bus(struct pci_bus *top, int(*cb)(struct pci_dev *, void *),
		void *userdata)
	bus = top;
	next = top->devices.next;
	for (;;) {
		if (next == &bus->devices) {; meet the end of bus->devices
			/* end of this bus, go up or finish */
			if (bus == top)
				break;
			next = bus->self->bus_list.next;
			bus = bus->self->bus;
			continue;
		}
		dev = list_entry(next, struct pci_dev, bus_list);
		if (dev->subordinate) {
			/* this is a pci-pci bridge, do its devices next */
			next = dev->subordinate->devices.next;
			bus = dev->subordinate;
		} else
			next = dev->bus_list.next;

		/* Run device routines with the device locked */
		device_lock(&dev->dev);
		retval = cb(dev, userdata);
		device_unlock(&dev->dev);
		if (retval)
			break;
	}

7. pci_update_resource(), write resource info into bar
===============================================================================
pci_update_resource(struct pci_dev *dev, int resno)
	struct resource *res = dev->resource + resno;
	pcibios_resource_to_bus(dev, &region, res);
	new = region.start | (res->flags & PCI_REGION_FLAG_MASK);
	if (res->flags & IORESOURCE_IO)
		mask = (u32)PCI_BASE_ADDRESS_IO_MASK;
	else
		mask = (u32)PCI_BASE_ADDRESS_MEM_MASK;

	; calculate reg for the real offset in config space
	reg = pci_resource_bar(dev, resno, &type);

	pci_write_config_dword(dev, reg, new);
	pci_read_config_dword(dev, reg, &check);

7.1 pci_resouce_bar(), retrieve the bar offset in config space 
===============================================================================
pci_resource_bar(struct pci_dev *dev, int resno, enum pci_bar_type *type)
	int reg;

	if (resno < PCI_ROM_RESOURCE) {
		*type = pci_bar_unknown;
		return PCI_BASE_ADDRESS_0 + 4 * resno;
	} else if (resno == PCI_ROM_RESOURCE) {
		*type = pci_bar_mem32;
		return dev->rom_base_reg;
	} else if (resno < PCI_BRIDGE_RESOURCES) {
		/* device specific resource */
		reg = pci_iov_resource_bar(dev, resno, type);
		if (reg)
			return reg;
	}

	dev_err(&dev->dev, "BAR %d: invalid resource\n", resno);
	return 0;

8. pci_read_bridge_bases(), for a bridge set its io/mem forward range
===============================================================================
pci_read_bridge_bases(struct pci_bus *child)
	struct pci_dev *dev = child->self;
	struct resource *res;
	int i;

	if (pci_is_root_bus(child))	/* It's a host bus, nothing to read */
		return;

	pci_bus_remove_resources(child);
	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++)
		child->resource[i] = &dev->resource[PCI_BRIDGE_RESOURCES+i];

	pci_read_bridge_io(child);
	pci_read_bridge_mmio(child);
	pci_read_bridge_mmio_pref(child);

	; if this is a transparent bridge, use his parent res
	if (dev->transparent) {
		pci_bus_for_each_resource(child->parent, res, i) {
			if (res) {
				pci_bus_add_resource(child, res,
						     PCI_SUBTRACTIVE_DECODE);
				dev_printk(KERN_DEBUG, &dev->dev,
					   "  bridge window %pR (subtractive decode)\n",
					   res);
			}
		}
	}

8.1 pci_bus_remove_resources(), clean up the resource list
===============================================================================
pci_bus_remove_resources(struct pci_bus *bus)
	int i;

	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++)
		bus->resource[i] = NULL;

	; release the list of bus->resources
	pci_free_resource_list(&bus->resources);


8.2 pci_read_bridge_io(), get io limit
===============================================================================
pci_read_bridge_io(struct pci_bus *child)
	struct pci_dev *dev = child->self;

	res = child->resource[0];
	pci_read_config_byte(dev, PCI_IO_BASE, &io_base_lo);
	pci_read_config_byte(dev, PCI_IO_LIMIT, &io_limit_lo);
	base = (io_base_lo & PCI_IO_RANGE_MASK) << 8;
	limit = (io_limit_lo & PCI_IO_RANGE_MASK) << 8;

	if ((io_base_lo & PCI_IO_RANGE_TYPE_MASK) == PCI_IO_RANGE_TYPE_32) {
		u16 io_base_hi, io_limit_hi;
		pci_read_config_word(dev, PCI_IO_BASE_UPPER16, &io_base_hi);
		pci_read_config_word(dev, PCI_IO_LIMIT_UPPER16, &io_limit_hi);
		base |= (io_base_hi << 16);
		limit |= (io_limit_hi << 16);
	}

	if (base && base <= limit) {
		res->flags = (io_base_lo & PCI_IO_RANGE_TYPE_MASK) | IORESOURCE_IO;
		res2.flags = res->flags;
		region.start = base;
		region.end = limit + 0xfff;
		pcibios_bus_to_resource(dev, &res2, &region);
		if (!res->start)
			res->start = res2.start;
		if (!res->end)
			res->end = res2.end;
		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
	}

8.3 pci_read_bridge_mmio(), get mem limit
===============================================================================
pci_read_bridge_mmio(struct pci_bus *child)
	struct pci_dev *dev = child->self;

	res = child->resource[1];
	pci_read_config_word(dev, PCI_MEMORY_BASE, &mem_base_lo);
	pci_read_config_word(dev, PCI_MEMORY_LIMIT, &mem_limit_lo);
	base = (mem_base_lo & PCI_MEMORY_RANGE_MASK) << 16;
	limit = (mem_limit_lo & PCI_MEMORY_RANGE_MASK) << 16;
	if (base && base <= limit) {
		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
		region.start = base;
		region.end = limit + 0xfffff;
		pcibios_bus_to_resource(dev, res, &region);
		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
	}

8.3 pci_read_bridge_mmio_pref(), get mem pref limit
===============================================================================

0. Figures, internal representation of pci subsystem
===============================================================================
                    
                                   -------+---------Bus 00(pci_bus) 
                                          |                 
                                 +--------+--------+       
                                 |     00:02.0     |      
                                 | PCIe-PCI bridge |
                                 | (pci_dev)       |
                                 +--------+--------+
                                          |                                
                                          |                                
                               +---------------------+    Bus 02(pci_bus)  
                               |                     |                     
                               |                     |                     
                               |                     |                     
                          +----v----+           +----v----+                
                          | 02:00.0 |           | 02:01.0 |                
                          |(pci_dev)|           |(pci_dev)|                
                          +---------+           +---------+

                     Figure 0.1 internal representaion of PCIe/PCE bridge
                                and its child bus and devices
                     (this is an example, the number could be different)
         

                                      ^
                                      |
      +-------------------------------|--------------------------------+
      |                               |                                |
      |                          +----+----+                           |
      |                          | virtual |                           |
      |                          | PCI-PCI | (pci_dev)                 |
      |                          | bridge  |                           |
      |                          +----+----+                           |
      |                               |                                |
      |                               |Bus#3(pci_bus)                  |
      |                               |                                |
      |          +----------------------------------------+            |
      |          |                    |                   |            |
      |          |                    |                   |            |
      |          |03:00.0             |03:01.0            |03:02.0     |
      |     +----+----+          +----+----+         +----++---+       |
      |     | virtual |          | virtual |         | virtual |       |
      |     | PCI-PCI |pci_dev   | PCI-PCI |pci_dev  | PCI-PCI |pci_dev|
      |     | bridge  |          | bridge  |         | bridge  |       |
      |     +----+----+          +----+----+         +----+----+       |
      |          |                    |                   |            |
      |          |                    |                   |            |
      +----------|--------------------|-------------------|------------+
                 | Bus#4(pci_bus)     | Bus#5(pci_bus)    |Bus#6(pci_bus)
                 v                    v                   v

                   Figure 0.2 internal representation of PCIe Switch
                   (this is an example, the number could be different)

                            Bus 0(pci_bus)                      
                            +--------------------+<----+
                            |children(list_head) |     |
                            |                    |-+   |
                            +--------------------+ |   |
                                                   |   |
                                                   |   |
                    +------------------------------+   |
                    |                                  |
                    |                                  |
                    |        Bridge(pci_dev)           |                     
                    |       +--------------------+<----|---+--------------+
                    |       |subordinate(pci_bus)|-+   |   |              |
                    |       +--------------------+ |   |   |              |
                    |                              |   |   |              |
                    |                              |   |   |              |
                    |       Bus 1(pci_bus)         |   |   |              |
                    +--+--->+-------------------+<-+   |   |              |
                       |    |parent(pci_bus)    |------+   |              |
                       |    +-------------------+          |              |
                       |    |self(pci_dev)      |----------+              |
                       |    |bridge(device)     |                         |
                       |    +-------------------+                         |
                       |    |devices(list_head) |                         |
                       |    +--------+----------+                         |
                       |             |                                    |
                       |      ----+--+---+----                            |
   pci_dev             |          |      |          pci_dev               |
   +---------------+<--|----------+      +--------->+-----------------+   |
   |bus(pci_bus)   |---+                            |bus(pci_bus)     |   |
   +---------------+                                +-----------------+   |
   |dev.parent     |                                |dev.parent       |---+
   +---------------+                                +-----------------+

                  Figure 0.3 relationship between bridge/bus/child device
                  (this is an example, the number could be different
		   another version on web is http://tldp.org/LDP/tlk/dd/pci.html
		   Section 6.6.1)
