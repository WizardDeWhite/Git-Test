1. application_impl::reset_p2p_node()
================================================================================

1.1 net::node::load_configuration()
================================================================================

1.2 net::node::set_node_delegate(this)
================================================================================
; such a magic assignment
; after doing so, _delegate has the address of application_impl

void node_impl::set_node_delegate(node_delegate* del, fc::thread* thread_for_delegate_calls)
{
  VERIFY_CORRECT_THREAD();
  _delegate.reset();
  if (del)
    _delegate.reset(new statistics_gathering_node_delegate_wrapper(del, thread_for_delegate_calls));
  if( _delegate )
    _chain_id = del->get_chain_id();
}

1.3 net::node::add_node()
================================================================================
; add to _potential_peer_db

void node_impl::add_node(const fc::ip::endpoint& ep)
{
  VERIFY_CORRECT_THREAD();
  // if we're connecting to them, we believe they're not firewalled
  potential_peer_record updated_peer_record = _potential_peer_db.lookup_or_create_entry_for_endpoint(ep);

  // if we've recently connected to this peer, reset the last_connection_attempt_time to allow
  // us to immediately retry this peer
  updated_peer_record.last_connection_attempt_time = std::min<fc::time_point_sec>(updated_peer_record.last_connection_attempt_time,
                                                                                  fc::time_point::now() - fc::seconds(_peer_connection_retry_timeout));
  _add_once_node_list.push_back(updated_peer_record);
  _potential_peer_db.update_entry(updated_peer_record);
  trigger_p2p_network_connect_loop();
}

1.4 net::node::listen_on_port()
================================================================================
; set listen_endpoint and write to config file

void node_impl::listen_on_port( uint16_t port, bool wait_if_not_available )
{
  VERIFY_CORRECT_THREAD();
  _node_configuration.listen_endpoint = fc::ip::endpoint( fc::ip::address(), port );
  _node_configuration.wait_if_endpoint_is_busy = wait_if_not_available;
  save_node_configuration();
}

1.5 net::node::listen_to_p2p_network()
================================================================================

_tcp_server.listen()

1.6 net::node::connect_to_p2p_network()
================================================================================
void node_impl::connect_to_p2p_network()
{
  VERIFY_CORRECT_THREAD();
  assert(_node_public_key != fc::ecc::public_key_data());

  assert(!_accept_loop_complete.valid() &&
         !_p2p_network_connect_loop_done.valid() &&
         !_fetch_sync_items_loop_done.valid() &&
         !_fetch_item_loop_done.valid() &&
         !_advertise_inventory_loop_done.valid() &&
         !_terminate_inactive_connections_loop_done.valid() &&
         !_fetch_updated_peer_lists_loop_done.valid() &&
         !_bandwidth_monitor_loop_done.valid() &&
         !_dump_node_status_task_done.valid());
  if (_node_configuration.accept_incoming_connections)
    _accept_loop_complete = fc::async( [=](){ accept_loop(); }, "accept_loop");
  _p2p_network_connect_loop_done = fc::async( [=]() { p2p_network_connect_loop(); }, "p2p_network_connect_loop" );
  _fetch_sync_items_loop_done = fc::async( [=]() { fetch_sync_items_loop(); }, "fetch_sync_items_loop" );
  _fetch_item_loop_done = fc::async( [=]() { fetch_items_loop(); }, "fetch_items_loop" );
  _advertise_inventory_loop_done = fc::async( [=]() { advertise_inventory_loop(); }, "advertise_inventory_loop" );
  _terminate_inactive_connections_loop_done = fc::async( [=]() { terminate_inactive_connections_loop(); }, "terminate_inactive_connections_loop" );
  _fetch_updated_peer_lists_loop_done = fc::async([=](){ fetch_updated_peer_lists_loop(); }, "fetch_updated_peer_lists_loop");
  _bandwidth_monitor_loop_done = fc::async([=](){ bandwidth_monitor_loop(); }, "bandwidth_monitor_loop");
  _dump_node_status_task_done = fc::async([=](){ dump_node_status_task(); }, "dump_node_status_task");
}

1.6.1 node_impl::accept_loop()
================================================================================
void node_impl::accept_loop()
{
  VERIFY_CORRECT_THREAD();
  while ( !_accept_loop_complete.canceled() )
  {
    peer_connection_ptr new_peer(peer_connection::make_shared(this));

    try
    {
      _tcp_server.accept( new_peer->get_socket() );
      ilog( "accepted inbound connection from ${remote_endpoint}", ("remote_endpoint", new_peer->get_socket().remote_endpoint() ) );
      if (_node_is_shutting_down)
        return;
      new_peer->connection_initiation_time = fc::time_point::now();
      _handshaking_connections.insert( new_peer );
      _rate_limiter.add_tcp_socket( &new_peer->get_socket() );
      std::weak_ptr<peer_connection> new_weak_peer(new_peer);
      new_peer->accept_or_connect_task_done = fc::async( [this, new_weak_peer]() {
        peer_connection_ptr new_peer(new_weak_peer.lock());
        assert(new_peer);
        if (!new_peer)
          return;
        accept_connection_task(new_peer);
      }, "accept_connection_task" );

      // limit the rate at which we accept connections to mitigate DOS attacks
      fc::usleep( fc::milliseconds(10) );
    } FC_CAPTURE_AND_LOG( (0) )
  }
} // accept_loop()

1.6.2 node_impl::p2p_network_connect_loop()
================================================================================

1.6.3 node_impl::fetch_sync_items_loop()
================================================================================

1.6.4 node_impl::fetch_items_loop()
================================================================================

1.6.5 node_impl::advertise_inventory_loop()
================================================================================

1.6.6 node_impl::terminate_inactive_connections_loop()
================================================================================

1.6.7 node_impl::fetch_updated_peer_lists_loop()
================================================================================

1.6.8 node_impl::bandwidth_monitor_loop()
================================================================================

1.6.9 node_impl::dump_node_status()
================================================================================

1.7 net::node::sync_from()
================================================================================
void node_impl::sync_from(const item_id& current_head_block, const std::vector<uint32_t>& hard_fork_block_numbers)
{
  VERIFY_CORRECT_THREAD();
  _most_recent_blocks_accepted.clear();
  _sync_item_type = current_head_block.item_type;
  _most_recent_blocks_accepted.push_back(current_head_block.item_hash);
  _hard_fork_block_numbers = hard_fork_block_numbers;
}

0. data structure
================================================================================

0.1 node
================================================================================

    node : enable_shared_from_this
    +----------------------------------+
    |my                                |
    |   (node_impl, node_impl_deleter) |
    |                                  |
    |                                  |
    +----------------------------------+

0.1.1 node_impl
================================================================================

    node_impl : public peer_connection_delegate
    +--------------------------------------------+
    |_delegate                                   |
    |(statistics_gathering_node_delegate_wrapper)|
    |                                            |
    +--------------------------------------------+
    |_user_agent_string                          |
    |     (string)                               |
    |_node_public_key                            |
    |_node_id                                    |
    |     (node_id_t)                            |
    |                                            |
    |_tcp_server                                 |
    |     (tcp_server)                           |
    |                                            |
    |                                            |
    |                                            |
    |_chain_id                                   |
    |     (sha256)                               |
    |_node_configuration_directory               |
    |_node_configuration                         |
    |                                            |
    |_actual_listening_endpoint                  |
    |     (ip::endpoint)                         |
    |_publicly_visible_listening_endpoint        |
    |     (ip::endpoint)                         |
    |                                            |
    |_add_once_node_list                         |
    |     (list<potential_peer_record>)          |
    |_potential_err_db                           |
    |     (peer_database)                        |
    |                                            |
    |_active_sync_request                        |
    |_new_received_sync_items                    |
    |_received_sync_items                        |
    |     (net::block_message)                   |
    |                                            |
    |_items_to_fetch                             |
    |_recently_failed_items                      |
    |                                            |
    |_most_recent_blocks_accepted                |
    |                                            |
    |_handshaking_connections                    |
    |_active_connections                         |
    |_closing_connections                        |
    |_terminating_connections                    |
    |    (peer_connection_ptr)                   |
    |                                            |
    |_handle_message_calls_in_progress           |
    |                                            |
    |                                            |
    |                                            |
    +--------------------------------------------+
    |on_message()                                |
    |on_hello_message()                          |
    |                                            |
    |                                            |
    |                                            |
    +--------------------------------------------+

0.1.1.1 peer_connection_delegate , an interface
================================================================================

    peer_connection_delegate
    +-----------------------------------------+
    |on_message()                             |
    |on_connection_closed()                   |
    |get_message_for_item()                   |
    |                                         |
    +-----------------------------------------+


0.1.1.2 statistics_gathering_node_delegate_wrapper : public node_delegate
================================================================================

    statistics_gathering_node_delegate_wrapper
    +-----------------------------------------+
    |_node_delegate                           |
    |    (node_delegate *)                    |
    |                                         |
    |                                         |
    +-----------------------------------------+


0.1.2 node_impl_deleter, a cleanup function
================================================================================
    struct node_impl_deleter
    {
      void operator()(node_impl*);
    };

    void node_impl_deleter::operator()(node_impl* impl_to_delete)
    {
#ifdef P2P_IN_DEDICATED_THREAD
      std::weak_ptr<fc::thread> weak_thread;
      if (impl_to_delete)
      {
        std::shared_ptr<fc::thread> impl_thread(impl_to_delete->_thread);
        weak_thread = impl_thread;
        impl_thread->async([impl_to_delete](){ delete impl_to_delete; }, "delete node_impl").wait();
        dlog("deleting the p2p thread");
      }
      if (weak_thread.expired())
        dlog("done deleting the p2p thread");
      else
        dlog("failed to delete the p2p thread, we must be leaking a smart pointer somewhere");
#else // P2P_IN_DEDICATED_THREAD
      delete impl_to_delete;
#endif // P2P_IN_DEDICATED_THREAD
    }
