1. hmp_migrate()
================================================================================
void hmp_migrate(Monitor *mon, const QDict *qdict)
{
    bool detach = qdict_get_try_bool(qdict, "detach", false);
    bool blk = qdict_get_try_bool(qdict, "blk", false);
    bool inc = qdict_get_try_bool(qdict, "inc", false);
    const char *uri = qdict_get_str(qdict, "uri");
    Error *err = NULL;

    qmp_migrate(uri, !!blk, blk, !!inc, inc, false, false, &err);
    if (err) {
        monitor_printf(mon, "migrate: %s\n", error_get_pretty(err));
        error_free(err);
        return;
    }

    if (!detach) {
        HMPMigrationStatus *status;

        if (monitor_suspend(mon) < 0) {
            monitor_printf(mon, "terminal does not allow synchronous "
                           "migration, continuing detached\n");
            return;
        }

        status = g_malloc0(sizeof(*status));
        status->mon = mon;
        status->is_block_migration = blk || inc;
        status->timer = timer_new_ms(QEMU_CLOCK_REALTIME, hmp_migrate_status_cb,
                                          status);
        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME));
    }
}

1.1 qmp_migrate()
================================================================================
void qmp_migrate(const char *uri, bool has_blk, bool blk,
                 bool has_inc, bool inc, bool has_detach, bool detach,
                 Error **errp)
{
    Error *local_err = NULL;
    MigrationState *s = migrate_get_current();
    MigrationParams params;
    const char *p;

    params.blk = has_blk && blk;
    params.shared = has_inc && inc;

    if (migration_is_setup_or_active(s->state) ||
        s->state == MIGRATION_STATUS_CANCELLING) {
        error_setg(errp, QERR_MIGRATION_ACTIVE);
        return;
    }
    if (runstate_check(RUN_STATE_INMIGRATE)) {
        error_setg(errp, "Guest is waiting for an incoming migration");
        return;
    }

    if (qemu_savevm_state_blocked(errp)) {
        return;
    }

    if (migration_blockers) {
        *errp = error_copy(migration_blockers->data);
        return;
    }

    /* We are starting a new migration, so we want to start in a clean
       state.  This change is only needed if previous migration
       failed/was cancelled.  We don't use migrate_set_state() because
       we are setting the initial state, not changing it. */
    s->state = MIGRATION_STATUS_NONE;

    s = migrate_init(&params);

    if (strstart(uri, "tcp:", &p)) {
        tcp_start_outgoing_migration(s, p, &local_err);
#ifdef CONFIG_RDMA
    } else if (strstart(uri, "rdma:", &p)) {
        rdma_start_outgoing_migration(s, p, &local_err);
#endif
#if !defined(WIN32)
    } else if (strstart(uri, "exec:", &p)) {
        exec_start_outgoing_migration(s, p, &local_err);
    } else if (strstart(uri, "unix:", &p)) {
        unix_start_outgoing_migration(s, p, &local_err);
    } else if (strstart(uri, "fd:", &p)) {
        fd_start_outgoing_migration(s, p, &local_err);
#endif
    } else {
        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, "uri",
                   "a valid migration protocol");
        migrate_set_state(s, MIGRATION_STATUS_SETUP, MIGRATION_STATUS_FAILED);
        return;
    }

    if (local_err) {
        migrate_fd_error(s);
        error_propagate(errp, local_err);
        return;
    }
}

1.1.1 migrate_get_current(), global MigrationState
================================================================================
MigrationState *migrate_get_current(void)
{
    static bool once;
    static MigrationState current_migration = {
        .state = MIGRATION_STATUS_NONE,
        .bandwidth_limit = MAX_THROTTLE,
        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,
        .mbps = -1,
        .parameters[MIGRATION_PARAMETER_COMPRESS_LEVEL] =
                DEFAULT_MIGRATE_COMPRESS_LEVEL,
        .parameters[MIGRATION_PARAMETER_COMPRESS_THREADS] =
                DEFAULT_MIGRATE_COMPRESS_THREAD_COUNT,
        .parameters[MIGRATION_PARAMETER_DECOMPRESS_THREADS] =
                DEFAULT_MIGRATE_DECOMPRESS_THREAD_COUNT,
        .parameters[MIGRATION_PARAMETER_X_CPU_THROTTLE_INITIAL] =
                DEFAULT_MIGRATE_X_CPU_THROTTLE_INITIAL,
        .parameters[MIGRATION_PARAMETER_X_CPU_THROTTLE_INCREMENT] =
                DEFAULT_MIGRATE_X_CPU_THROTTLE_INCREMENT,
    };

    if (!once) {
        qemu_mutex_init(&current_migration.src_page_req_mutex);
        once = true;
    }
    return &current_migration;
}

1.1.2 migration_is_setup_or_active()
================================================================================
static bool migration_is_setup_or_active(int state)
{
    switch (state) {
    case MIGRATION_STATUS_ACTIVE:
    case MIGRATION_STATUS_POSTCOPY_ACTIVE:
    case MIGRATION_STATUS_SETUP:
        return true;

    default:
        return false;

    }
}

1.1.3 qemu_savevm_state_blocked()
================================================================================
bool qemu_savevm_state_blocked(Error **errp)
{
    SaveStateEntry *se;

    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
        if (se->vmsd && se->vmsd->unmigratable) {
            error_setg(errp, "State blocked by non-migratable device '%s'",
                       se->idstr);
            return true;
        }
    }
    return false;
}

1.1.3.1 if (se->vmsd && se->vmsd->unmigratable)
================================================================================

1.1.4 migration_blockers
================================================================================
inserted by migrate_add_blocker()

1.1.3 migrate_init()
================================================================================
MigrationState *migrate_init(const MigrationParams *params)
{
    MigrationState *s = migrate_get_current();

    /*
     * Reinitialise all migration state, except
     * parameters/capabilities that the user set, and
     * locks.
     */
    s->bytes_xfer = 0;
    s->xfer_limit = 0;
    s->cleanup_bh = 0;
    s->file = NULL;
    s->state = MIGRATION_STATUS_NONE;
    s->params = *params;
    s->rp_state.from_dst_file = NULL;
    s->rp_state.error = false;
    s->mbps = 0.0;
    s->downtime = 0;
    s->expected_downtime = 0;
    s->dirty_pages_rate = 0;
    s->dirty_bytes_rate = 0;
    s->setup_time = 0;
    s->dirty_sync_count = 0;
    s->start_postcopy = false;
    s->migration_thread_running = false;
    s->last_req_rb = NULL;

    migrate_set_state(&s->state, MIGRATION_STATUS_NONE, MIGRATION_STATUS_SETUP);

    QSIMPLEQ_INIT(&s->src_page_requests);

    s->total_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);
    return s;
}

1.1.3.1 migrate_get_current()
================================================================================

1.1.3.2 migrate_set_state(NONE, SETUP)
================================================================================

1.1.3.3 s->total_time = qemu_clock_get_ms()
================================================================================

1.1.4 tcp_start_outgoing_migration()
================================================================================
void tcp_start_outgoing_migration(MigrationState *s, const char *host_port, Error **errp)
{
    inet_nonblocking_connect(host_port, tcp_wait_for_connect, s, errp);
}

1.1.4.1 tcp_wait_for_connect()
================================================================================
static void tcp_wait_for_connect(int fd, Error *err, void *opaque)
{
    MigrationState *s = opaque;

    if (fd < 0) {
        DPRINTF("migrate connect error: %s\n", error_get_pretty(err));
        s->file = NULL;
        migrate_fd_error(s);
    } else {
        DPRINTF("migrate connect success\n");
        s->file = qemu_fopen_socket(fd, "wb");
        migrate_fd_connect(s);
    }
}

1. migrate_fd_connect()
================================================================================
void migrate_fd_connect(MigrationState *s)
{
    /* This is a best 1st approximation. ns to ms */
    s->expected_downtime = max_downtime/1000000;
    s->cleanup_bh = qemu_bh_new(migrate_fd_cleanup, s);

    qemu_file_set_rate_limit(s->file,
                             s->bandwidth_limit / XFER_LIMIT_RATIO);

    /* Notify before starting migration thread */
    notifier_list_notify(&migration_state_notifiers, s);

    /*
     * Open the return path; currently for postcopy but other things might
     * also want it.
     */
    if (migrate_postcopy_ram()) {
        if (open_return_path_on_source(s)) {
            error_report("Unable to open return-path for postcopy");
            migrate_set_state(&s->state, MIGRATION_STATUS_SETUP,
                              MIGRATION_STATUS_FAILED);
            migrate_fd_cleanup(s);
            return;
        }
    }

    migrate_compress_threads_create();
    qemu_thread_create(&s->thread, "migration", migration_thread, s,
                       QEMU_THREAD_JOINABLE);
    s->migration_thread_running = true;
}

1.1 qemu_file_set_rate_limit()
================================================================================
void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)
{
    f->xfer_limit = limit;
}

1.2 notifier_list_notify(&migration_state_notifiers)
================================================================================

1.3 migrate_compress_threads_create()
================================================================================
void migrate_compress_threads_create(void)
{
    int i, thread_count;

    if (!migrate_use_compression()) {
        return;
    }
    quit_comp_thread = false;
    compression_switch = true;
    thread_count = migrate_compress_threads();
    compress_threads = g_new0(QemuThread, thread_count);
    comp_param = g_new0(CompressParam, thread_count);
    comp_done_cond = g_new0(QemuCond, 1);
    comp_done_lock = g_new0(QemuMutex, 1);
    qemu_cond_init(comp_done_cond);
    qemu_mutex_init(comp_done_lock);
    for (i = 0; i < thread_count; i++) {
        /* com_param[i].file is just used as a dummy buffer to save data, set
         * it's ops to empty.
         */
        comp_param[i].file = qemu_fopen_ops(NULL, &empty_ops);
        comp_param[i].done = true;
        qemu_mutex_init(&comp_param[i].mutex);
        qemu_cond_init(&comp_param[i].cond);
        qemu_thread_create(compress_threads + i, "compress",
                           do_data_compress, comp_param + i,
                           QEMU_THREAD_JOINABLE);
    }
}

1.3.1 qemu_thread_create(do_data_compress)
================================================================================

1.4 qemu_thread_create(migration_thread)
================================================================================

1. migration_thread()
================================================================================

1.1 qemu_savevm_state_header
================================================================================

1.1.1 qemu_put_be32(f, QEMU_VM_FILE_MAGIC);
================================================================================

1.1.2 qemu_put_be32(f, QEMU_VM_FILE_VERSION);
================================================================================
    
1.1.3 qemu_put_be32(f, QEMU_VM_CONFIGURATION);
================================================================================

1.1.4 vmstate_save_state(f, &vmstate_configuration, &savevm_state, 0);
================================================================================

1.2 qemu_savevm_send_open_return_path(s->to_dst_file);
================================================================================

1.3 qemu_savevm_send_ping(s->to_dst_file, 1);
================================================================================

1.4 qemu_savevm_state_setup(s->to_dst_file);
================================================================================

1.4.1 save_section_header(f, se, QEMU_VM_SECTION_START)
================================================================================

1.4.2 se->ops->save_setup(f, se->opaque)
================================================================================

1.4.3 save_section_footer(f, se)
================================================================================

1.4.4 precopy_notify(PRECOPY_NOTIFY_SETUP, &local_err)
================================================================================

1.5 migrate_set_state(&s->state, MIGRATION_STATUS_SETUP, MIGRATION_STATUS_ACTIVE);
================================================================================

1.6 migration_iteration_run
================================================================================

1.6.1 qemu_savevm_state_pending(f, &pend_pre, &pend_compat, &pend_post)
================================================================================

1.6.1.1 se->ops->save_live_pending()
================================================================================

1.6.2 qemu_savevm_state_iterate()
================================================================================

1.6.2.1 save_section_header(f, se, QEMU_VM_SECTION_PART)
================================================================================

1.6.2.2 se->ops->save_live_iterate(f, se->opaque)
================================================================================

1.6.2.3 save_section_footer(f, se)
================================================================================

1.6.3 migration_completion()
================================================================================

1.6.3.1 qemu_system_wakeup_request(QEMU_WAKEUP_REASON_OTHER, NULL);
================================================================================

1.6.3.2 vm_stop_force_state(RUN_STATE_FINISH_MIGRATE)
================================================================================

1.6.3.3 qemu_savevm_state_complete_precopy(s->to_dst_file, false, inactivate);
================================================================================

1.6.3.3.1 cpu_synchronize_all_states();
================================================================================

1.6.3.3.2 save_section_header(f, se, QEMU_VM_SECTION_END);
================================================================================

1.6.3.3.3 se->ops->save_live_complete_precopy(f, se->opaque)
================================================================================

1.6.3.3.4 save_section_footer(f, se);
================================================================================

1.6.3.3.5 save_section_header(f, se, QEMU_VM_SECTION_FULL);
================================================================================

1.6.3.3.6 vmstate_save(f, se, vmdesc)
================================================================================

1.6.3.3.7 save_section_footer(f, se);
================================================================================

1.6.3.3.8 qemu_put_xx, vmdesc
================================================================================
qemu_put_byte(f, QEMU_VM_VMDESCRIPTION);
qemu_put_be32(f, vmdesc_len);
qemu_put_buffer(f, (uint8_t *)qjson_get_str(vmdesc), vmdesc_len);

1.7 migration_detect_error
================================================================================

1.8 migration_update_counters
================================================================================

1.9 migration_iteration_finish
================================================================================

1. process_incoming_migration_co()
================================================================================

1. vmstate_save(f, vmsd, opaque, vmdesc_id) -> vmstate_save_state_v()
================================================================================

1.1 vmsd->pre_save()
================================================================================

1.2 vmsd_desc_field_start(vmsd, vmdesc_loop, field, i, n_elems)
================================================================================

1.3 vmstate_info_nullptr.put() 
================================================================================

1.4 vmstate_save_state(f, field->vmsd, curr_elem, vmdesc_loop)
================================================================================

1.5 vmstate_save_state_v(f, field->vmsd, curr_elem, vmdesc_loop, field->struct_version_id)
================================================================================

1.6 field->info->put(f, curr_elem, size, field, vmdesc_loop)
================================================================================

1.7 vmstate_subsection_save()
================================================================================

1.1 vmsd->post_save()
================================================================================

1. register SaveStateEntry
================================================================================

1.1 main(),blk_mig_init()
================================================================================

1.1.1 QSIMPLEQ_INIT(&block_mig_state.bmds_list);
================================================================================
1.1.2 QSIMPLEQ_INIT(&block_mig_state.blk_list);
================================================================================
1.1.3 qemu_mutex_init(&block_mig_state.lock);
================================================================================
1.1.4 register_savevm_live(NULL, "block", 0, 1, savevm_block_handlers, block_mig_state)
================================================================================
1.1.4.1 savevm_state_handler_insert(se), insert to savevm_state.handlers
================================================================================

1.2 ram_mig_init()
================================================================================
1.2.1 qemu_mutex_init(&XBZRLE.lock);
================================================================================
1.2.2 register_savevm_live(NULL, "ram", 0, 4, &savevm_ram_handlers, &ram_state);
================================================================================

1.3 dirty_bitmap_mig_init()
================================================================================
1.3.1 QSIMPLEQ_INIT(&dirty_bitmap_mig_state.dbms_list);
================================================================================
1.3.2 register_savevm_live(NULL, "dirty-bitmap", 0, 1, &savevm_dirty_bitmap_handlers, &dirty_bitmap_mig_state);
================================================================================

0. call flow for migration_thread
================================================================================

     migration_thread()
       qemu_savevm_state_header
           qemu_put_be32(f, QEMU_VM_FILE_MAGIC);
           qemu_put_be32(f, QEMU_VM_FILE_VERSION);
           qemu_put_be32(f, QEMU_VM_CONFIGURATION);
           vmstate_save_state(f, &vmstate_configuration, &savevm_state, 0);
       qemu_savevm_send_open_return_path(s->to_dst_file);
       qemu_savevm_send_ping(s->to_dst_file, 1);
           qemu_savevm_command_send(f, MIG_CMD_PING, , (uint8_t *)&buf)

       ; iterate savevm_state and call save_setup
       qemu_savevm_state_setup(s->to_dst_file);
           save_section_header(f, se, QEMU_VM_SECTION_START)
           se->ops->save_setup(f, se->opaque)
           save_section_footer(f, se)
           precopy_notify(PRECOPY_NOTIFY_SETUP, &local_err)
       migrate_set_state(&s->state, MIGRATION_STATUS_SETUP, MIGRATION_STATUS_ACTIVE);
       migration_iteration_run

           ; iterate savevm_state and call save_live_pending
           qemu_savevm_state_pending(pend_pre/compat/post)
               se->ops->save_live_pending()

           ; iterate savevm_state and call save_live_iterate
           qemu_savevm_state_iterate()
               save_section_header(f, se, QEMU_VM_SECTION_PART)
               se->ops->save_live_iterate(f, se->opaque)
               save_section_footer(f, se)
           migration_completion()
               qemu_system_wakeup_request(QEMU_WAKEUP_REASON_OTHER, NULL);
               vm_stop_force_state(RUN_STATE_FINISH_MIGRATE)

               qemu_savevm_state_complete_precopy(s->to_dst_file, false, inactivate);
                   ; iterate savevm_state and call save_live_complete_precopy
                   cpu_synchronize_all_states();
                   save_section_header(f, se, QEMU_VM_SECTION_END);
                   se->ops->save_live_complete_precopy(f, se->opaque)
                   save_section_footer(f, se);

                   ; iterate savevm_state and call vmstate_save
                   save_section_header(f, se, QEMU_VM_SECTION_FULL);
                   vmstate_save(f, se, vmdesc)
                   save_section_footer(f, se);
       migration_detect_error
       migration_update_counters
       migration_iteration_finish
    

0. data structure
================================================================================

0.1 MigrationState(current_migration)
================================================================================

    TYPE_DEVICE
    +---------------------------------+ 
    |class_size                       | = sizeof(DeviceClass)
    |class_init                       | = device_class_init
    |                                 |
    |instance_size                    | = sizeof(Object)
    |instance_init                    | = device_initfn
    |instance_finalize                | = device_finalize
    |                                 |
    |realize                          | = 
    +---------------------------------+ 


    TYPE_MIGRATION
    +---------------------------------+
    |class_size                       | = sizeof(MigrationClass)
    |class_init                       | = migration_class_init
    |                                 |
    |instance_size                    | = sizeof(MigrationState)
    |instance_init                    | = migration_instance_init
    |instance_finalize                | = migration_instance_finalize
    |                                 |
    |realize                          | = 
    +---------------------------------+

    current_migration(MigrationState)
    +---------------------------------+
    |parameters                       |
    |    (MigrationParams)            |
    |    +----------------------------+
    |    |has_tls_creds               | = all default to true
    |    |   (bool)                   |
    |    |tls_creds                   |
    |    |   (char*)                  |
    |    |has_tls_hostname            |
    |    |   (bool)                   |
    |    |tls_hostname                |
    |    |   (char*)                  |
    |    |has_announce_initial        |
    |    |   (bool)                   |
    |    |announce_initial            |
    |    |   (uint64_t)               |
    |    |         .                  |
    |    |         .                  |
    |    |         .                  |
    |    |         .                  |
    +----+----------------------------+
    |send_configuration               |
    |send_section_footer              |
    |only_migratable                  | only allow for migratable device
    |    (bool)                       |
    +---------------------------------+
    |state                            | = MIGRATION_STATUS_NONE(start with)
    |    (int)                        |
    |vm_was_running                   |
    |    (bool)                       |
    +---------------------------------+
    |file                             | tcp socket fd
    |    (QEMUFile *)                 |
    +---------------------------------+
    |thread                           | migration_thread
    |    (QemuThread)                 |
    +---------------------------------+
    |threshold_size                   | if remaining data is smaller, last round
    |    (int64_t)                    |
    |                                 |
    |start_time                       | = assigned in migrate_init()
    |setup_time                       | = time used in setup stage migration_thread
    |iteration_start_time             | = init at every round
    |expected_downtime                | = remaining ram / bandwidth
    |downtime_start                   | = assigned in migration_completion()
    |downtime                         | = end_time - s->downtime_start
    |total_time                       | = end_time - s->start_time
    |    (int64_t)                    |
    |                                 |
    |iteration_initial_bytes          | = init at every round
    |iteration_initial_pages          | = init at every round
    |    (int64_t)                    |
    |mbps                             | = migration_total_bytes() / time_spent
    |pages_per_second                 | = ram_get_total_transferred_pages() / time_spent
    |    (double)                     |
    |                                 |
    +---------------------------------+
    |rp_state                         | related to return path
    |    +----------------------------+
    |    |from_dst_file               |
    |    |    (QEMUFile *)            |
    |    |rp_thread                   |
    |    |rp_sem                      |
    |    |                            |
    +----+----------------------------+
    |                                 |
    |                                 |
    +---------------------------------+

0.1.1 state change
================================================================================
  MIGRATION_STATUS_NONE        migration_object_init / migration_instance_init / migrate_init  ?
  MIGRATION_STATUS_SETUP       migrate_init
  MIGRATION_STATUS_ACTIVE      migration_thread

0.2 SaveState
================================================================================

    SaveState(savevm_state)
    +--------------------------------------+
    |global_section_id                     |
    |     (int)                            |
    |name                                  |
    |     (char*)                          |
    |len                                   |
    |target_page_bits                      |
    |caps_count                            |
    |     (uint32_t)                       |
    +--------------------------------------+
    |capabilities                          |
    |     (MigrationCapability*)           |
    +--------------------------------------+
    |handlers                              |
    |     (list of SaveStateEntry)         |
    +--------------------------------------+


    SaveStateEntry                          SaveStateEntry                       SaveStateEntry                 
    +-----------------------------+         +-----------------------------+      +------------------------------------+
    |idstr                        |         |idstr                        |      |idstr                               |
    |     = "block"               |         |     = "ram"                 |      |     = "dirty-bitmap"               |
    |ops                          |         |ops                          |      |ops                                 |
    |     = savevm_block_handlers |         |     = savevm_ram_handlers   |      |     = savevm_dirty_bitmap_handlers |
    |opaque                       |         |opaque                       |      |opaque                              |
    |     = block_mig_state       |         |     = ram_state             |      |     = dirty_bitmap_mig_state       |
    |vmsd                         |         |vmsd                         |      |vmsd                                |
    |     = NULL                  |         |     = NULL                  |      |     = NULL                         |
    +-----------------------------+         +-----------------------------+      +------------------------------------+


0.2.1 RAMState
================================================================================

    RAMState
    +--------------------------------------+
    |f                                     | = s->to_dst_file
    |    (QEMUFile *)                      |
    |last_seen_block                       |
    |last_sent_block                       |
    |last_req_rb                           |
    |    (RAMBlock *)                      |
    |last_page                             |
    |    (ram_addr_t)                      |
    |last_version                          |
    |    (uint32_t)                        |
    |ram_bulk_stage                        |
    |fpo_enabled                           |
    |    (bool)                            |
    |dirty_rate_high_cnt                   |
    |time_last_bitmap_sync                 |
    |bytes_xfer_prev                       |
    |num_dirty_pages_period                |
    |xbzrle_cache_miss_prev                |
    |    (uint64_t)                        |
    |compress_thread_busy_prev             |
    |compressed_size_prev                  |
    |compress_pages_prev                   |
    |    (uint64_t)                        |
    |target_page_count_prev                |
    |target_page_count                     |
    |migration_dirty_pages                 |
    |    (uint64_t)                        |
    |src_page_requests                     |
    |    (list of RAMSrcPageRequest)       |
    +--------------------------------------+



0.3 SaveStateEntry
================================================================================
; insert by savevm_state_handler_insert()
; ordered by se->vmsd->priority

    SaveStateEntry
    +--------------------------------------+
    |idstr                                 |
    |    (char [256])                      |
    |instance_id                           | = calculate_new_instance_id(se->idstr)
    |alias_id                              |
    |version_id                            |
    |load_version_id                       |
    |section_id                            | = savevm_state.global_section_id++
    |load_section_id                       |
    |    (int)                             |
    |is_ram                                |
    |    (int)                             |
    +--------------------------------------+
    |ops                                   |
    |    (struct SaveVMHandlers *)         |
    |    +---------------------------------+
    |    |save_state                       |
    |    |save_cleanup                     |
    |    |save_live_complete_precopy       |
    |    |save_live_complete_postcopy      |
    |    |is_active                        |
    |    |has_postcopy                     |
    |    |is_live_iterate                  |
    |    |save_live_iterate                |
    |    |save_setup                       |
    |    |save_live_pending                |
    |    |load_state                       |
    |    |load_setup                       |
    |    |load_cleanup                     |
    |    |resume_prepare                   |
    +----+---------------------------------+
    |opaque                                |
    |    (void *)                          |
    +--------------------------------------+
    |compat                                |
    |    (CompatEntry*)                    |
    |    +---------------------------------+
    |    |idstr                            |
    |    |    (char [256])                 |
    |    |instance_id                      |
    |    |    (int)                        |
    +----+---------------------------------+
    |vmsd                                  | -------> VMStateDescription
    |    (VMStateDescription *)            |          +--------------------------------------+
    +--------------------------------------+          |name                                  |  "configuration"
    |                                      |          |    (char *)                          |
    |                                      |          +--------------------------------------+
    +--------------------------------------+          |version_id                            |
                                                      |minimum_version_id                    |
                                                      |minimum_version_id_old                |
                                                      |    (int)                             |
                                                      +--------------------------------------+
                                                      |pre_load                              |
                                                      |post_load                             |  configuration_post_load
                                                      |    int (*) ()                        |
                                                      |pre_save                              |  configuration_pre_save
                                                      |    void (*)()                        |
                                                      |needed                                |
                                                      |    bool (*)()                        |
                                                      +--------------------------------------+
                                                      |fields                                |
                                                      |    (VMStateField *)                  |
                                                      |    +---------------------------------+
                                                      |    |name                             |
                                                      |    |offset                           |
                                                      |    |size                             |
                                                      |    |start                            |
                                                      |    |                                 |
                                                      |    |info                             |
                                                      |    |    (VMStateInfo *)              |
                                                      |    |    +----------------------------+
                                                      |    |    |name                        |
                                                      |    |    |get                         |
                                                      |    |    |put                         |
                                                      |    |    |                            |
                                                      +----+----+----------------------------+
                                                      |                                      |
                                                      |                                      |
                                                      +--------------------------------------+
                                                      |subsections                           |
                                                      |    (VMStateDescription **)           |
                                                      +--------------------------------------+
