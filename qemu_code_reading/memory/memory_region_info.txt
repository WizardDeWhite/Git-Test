1. memory_region_info
================================================================================
static const TypeInfo memory_region_info = {
    .parent             = TYPE_OBJECT,
    .name               = TYPE_MEMORY_REGION,
    .instance_size      = sizeof(MemoryRegion),
    .instance_init      = memory_region_initfn,
    .instance_finalize  = memory_region_finalize,
};

1.1 memory_region_initfn, add property
================================================================================
static void memory_region_initfn(Object *obj)
{
    MemoryRegion *mr = MEMORY_REGION(obj);
    ObjectProperty *op;

    mr->ops = &unassigned_mem_ops;
    mr->ram_addr = RAM_ADDR_INVALID;
    mr->enabled = true;
    mr->romd_mode = true;
    mr->global_locking = true;
    mr->destructor = memory_region_destructor_none;
    QTAILQ_INIT(&mr->subregions);
    QTAILQ_INIT(&mr->coalesced);

    op = object_property_add(OBJECT(mr), "container",
                             "link<" TYPE_MEMORY_REGION ">",
                             memory_region_get_container,
                             NULL, /* memory_region_set_container */
                             NULL, NULL, &error_abort);
    op->resolve = memory_region_resolve_container;

    object_property_add(OBJECT(mr), "addr", "uint64",
                        memory_region_get_addr,
                        NULL, /* memory_region_set_addr */
                        NULL, NULL, &error_abort);
    object_property_add(OBJECT(mr), "priority", "uint32",
                        memory_region_get_priority,
                        NULL, /* memory_region_set_priority */
                        NULL, NULL, &error_abort);
    object_property_add_bool(OBJECT(mr), "may-overlap",
                             memory_region_get_may_overlap,
                             NULL, /* memory_region_set_may_overlap */
                             &error_abort);
    object_property_add(OBJECT(mr), "size", "uint64",
                        memory_region_get_size,
                        NULL, /* memory_region_set_size, */
                        NULL, NULL, &error_abort);
}

2. memory_region_init_io/ram/alias(), create a MemoryRegion with different type
================================================================================
void memory_region_init_io(MemoryRegion *mr,
                           Object *owner,
                           const MemoryRegionOps *ops,
                           void *opaque,
                           const char *name,
                           uint64_t size)
{
    memory_region_init(mr, owner, name, size);
    mr->ops = ops ? ops : &unassigned_mem_ops;
    mr->opaque = opaque;
    mr->terminates = true;
}

void memory_region_init_ram(MemoryRegion *mr,
                            Object *owner,
                            const char *name,
                            uint64_t size,
                            Error **errp)
{
    memory_region_init(mr, owner, name, size);
    mr->ram = true;
    mr->terminates = true;
    mr->destructor = memory_region_destructor_ram;
    mr->ram_addr = qemu_ram_alloc(size, mr, errp);
    mr->dirty_log_mask = tcg_enabled() ? (1 << DIRTY_MEMORY_CODE) : 0;
}

2.1 memory_region_init()
================================================================================
void memory_region_init(MemoryRegion *mr,
                        Object *owner,
                        const char *name,
                        uint64_t size)
{
    if (!owner) {
        owner = container_get(qdev_get_machine(), "/unattached");
    }

    object_initialize(mr, sizeof(*mr), TYPE_MEMORY_REGION);
    mr->size = int128_make64(size);
    if (size == UINT64_MAX) {
        mr->size = int128_2_64();
    }
    mr->name = g_strdup(name);

    if (name) {
        char *escaped_name = memory_region_escape_name(name);
        char *name_array = g_strdup_printf("%s[*]", escaped_name);
        object_property_add_child(owner, name_array, OBJECT(mr), &error_abort);
        object_unref(OBJECT(mr));
        g_free(name_array);
        g_free(escaped_name);
    }
}

2.1.1 memory_region_initfn, add property
================================================================================

2.2 qemu_ram_alloc(), mmap between guest and host
================================================================================
ram_addr_t qemu_ram_alloc(ram_addr_t size, MemoryRegion *mr, Error **errp)
{
    return qemu_ram_alloc_internal(size, size, NULL, NULL, false, mr, errp);
}

static
ram_addr_t qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
                                   void (*resized)(const char*,
                                                   uint64_t length,
                                                   void *host),
                                   void *host, bool resizeable,
                                   MemoryRegion *mr, Error **errp)
{
    RAMBlock *new_block;
    ram_addr_t addr;
    Error *local_err = NULL;

    size = TARGET_PAGE_ALIGN(size);
    max_size = TARGET_PAGE_ALIGN(max_size);
    new_block = g_malloc0(sizeof(*new_block));
    new_block->mr = mr;
    new_block->resized = resized;
    new_block->used_length = size;
    new_block->max_length = max_size;
    assert(max_size >= size);
    new_block->fd = -1;
    new_block->host = host;
    if (host) {
        new_block->flags |= RAM_PREALLOC;
    }
    if (resizeable) {
        new_block->flags |= RAM_RESIZEABLE;
    }
    addr = ram_block_add(new_block, &local_err);
    if (local_err) {
        g_free(new_block);
        error_propagate(errp, local_err);
        return -1;
    }
    return addr;
}

2.2.1 ram_block_add()
================================================================================
static ram_addr_t ram_block_add(RAMBlock *new_block, Error **errp)
{
    RAMBlock *block;
    RAMBlock *last_block = NULL;
    ram_addr_t old_ram_size, new_ram_size;

    old_ram_size = last_ram_offset() >> TARGET_PAGE_BITS;

    qemu_mutex_lock_ramlist();
    new_block->offset = find_ram_offset(new_block->max_length);

    if (!new_block->host) {
        if (xen_enabled()) {
            xen_ram_alloc(new_block->offset, new_block->max_length,
                          new_block->mr);
        } else {
            new_block->host = phys_mem_alloc(new_block->max_length,
                                             &new_block->mr->align);
            if (!new_block->host) {
                error_setg_errno(errp, errno,
                                 "cannot set up guest memory '%s'",
                                 memory_region_name(new_block->mr));
                qemu_mutex_unlock_ramlist();
                return -1;
            }
            memory_try_enable_merging(new_block->host, new_block->max_length);
        }
    }

    new_ram_size = MAX(old_ram_size,
              (new_block->offset + new_block->max_length) >> TARGET_PAGE_BITS);
    if (new_ram_size > old_ram_size) {
        migration_bitmap_extend(old_ram_size, new_ram_size);
    }
    /* Keep the list sorted from biggest to smallest block.  Unlike QTAILQ,
     * QLIST (which has an RCU-friendly variant) does not have insertion at
     * tail, so save the last element in last_block.
     */
    QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {
        last_block = block;
        if (block->max_length < new_block->max_length) {
            break;
        }
    }
    if (block) {
        QLIST_INSERT_BEFORE_RCU(block, new_block, next);
    } else if (last_block) {
        QLIST_INSERT_AFTER_RCU(last_block, new_block, next);
    } else { /* list is empty */
        QLIST_INSERT_HEAD_RCU(&ram_list.blocks, new_block, next);
    }
    ram_list.mru_block = NULL;

    /* Write list before version */
    smp_wmb();
    ram_list.version++;
    qemu_mutex_unlock_ramlist();

    new_ram_size = last_ram_offset() >> TARGET_PAGE_BITS;

    if (new_ram_size > old_ram_size) {
        int i;

        /* ram_list.dirty_memory[] is protected by the iothread lock.  */
        for (i = 0; i < DIRTY_MEMORY_NUM; i++) {
            ram_list.dirty_memory[i] =
                bitmap_zero_extend(ram_list.dirty_memory[i],
                                   old_ram_size, new_ram_size);
       }
    }
    cpu_physical_memory_set_dirty_range(new_block->offset,
                                        new_block->used_length,
                                        DIRTY_CLIENTS_ALL);

    if (new_block->host) {
        qemu_ram_setup_dump(new_block->host, new_block->max_length);
        qemu_madvise(new_block->host, new_block->max_length, QEMU_MADV_HUGEPAGE);
        qemu_madvise(new_block->host, new_block->max_length, QEMU_MADV_DONTFORK);
        if (kvm_enabled()) {
            kvm_setup_guest_memory(new_block->host, new_block->max_length);
        }
    }

    return new_block->offset;
}

2.2.1.0 last_ram_offset()
================================================================================
ram_addr_t last_ram_offset(void)
{
    RAMBlock *block;
    ram_addr_t last = 0;

    rcu_read_lock();
    QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {
        last = MAX(last, block->offset + block->max_length);
    }
    rcu_read_unlock();
    return last;
}

2.2.1.1 find_ram_offset(), find the mingap to fit
================================================================================
static ram_addr_t find_ram_offset(ram_addr_t size)
{
    RAMBlock *block, *next_block;
    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;

    assert(size != 0); /* it would hand out same offset multiple times */

    if (QLIST_EMPTY_RCU(&ram_list.blocks)) {
        return 0;
    }

    QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {
        ram_addr_t end, next = RAM_ADDR_MAX;

        end = block->offset + block->max_length;

        QLIST_FOREACH_RCU(next_block, &ram_list.blocks, next) {
            if (next_block->offset >= end) {
                next = MIN(next, next_block->offset);
            }
        }
        if (next - end >= size && next - end < mingap) {
            offset = end;
            mingap = next - end;
        }
    }

    if (offset == RAM_ADDR_MAX) {
        fprintf(stderr, "Failed to find gap of requested size: %" PRIu64 "\n",
                (uint64_t)size);
        abort();
    }

    return offset;
}

2.2.1.2 phys_mem_alloc(), alloc shared memory pages, mmap ANONYMOUS page
================================================================================
void *qemu_anon_ram_alloc(size_t size, uint64_t *alignment)
{
    size_t align = QEMU_VMALLOC_ALIGN;
    size_t total = size + align - getpagesize();
    void *ptr = mmap(0, total, PROT_READ | PROT_WRITE,
                     MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    size_t offset = QEMU_ALIGN_UP((uintptr_t)ptr, align) - (uintptr_t)ptr;

    if (ptr == MAP_FAILED) {
        return NULL;
    }

    if (alignment) {
        *alignment = align;
    }
    ptr += offset;
    total -= offset;

    if (offset > 0) {
        munmap(ptr - offset, offset);
    }
    if (total > size) {
        munmap(ptr + size, total - size);
    }

    trace_qemu_anon_ram_alloc(size, ptr);
    return ptr;
}

2.2.1.3 memory_try_enable_merging()
================================================================================
static int memory_try_enable_merging(void *addr, size_t len)
{
    if (!machine_mem_merge(current_machine)) {
        /* disabled by the user */
        return 0;
    }

    return qemu_madvise(addr, len, QEMU_MADV_MERGEABLE);
}

2.2.1.4 migration_bitmap_extend(), migration related
================================================================================
void migration_bitmap_extend(ram_addr_t old, ram_addr_t new)
{
    /* called in qemu main thread, so there is
     * no writing race against this migration_bitmap
     */
    if (migration_bitmap) {
        unsigned long *old_bitmap = migration_bitmap, *bitmap;
        bitmap = bitmap_new(new);

        /* prevent migration_bitmap content from being set bit
         * by migration_bitmap_sync_range() at the same time.
         * it is safe to migration if migration_bitmap is cleared bit
         * at the same time.
         */
        qemu_mutex_lock(&migration_bitmap_mutex);
        bitmap_copy(bitmap, old_bitmap, old);
        bitmap_set(bitmap, old, new - old);
        atomic_rcu_set(&migration_bitmap, bitmap);
        qemu_mutex_unlock(&migration_bitmap_mutex);
        migration_dirty_pages += new - old;
        synchronize_rcu();
        g_free(old_bitmap);
    }
}

2.2.1.5 bitmap_zero_extend(), extend dirty memory bitmap
================================================================================
static inline unsigned long *bitmap_zero_extend(unsigned long *old,
                                                long old_nbits, long new_nbits)
{
    long new_len = BITS_TO_LONGS(new_nbits) * sizeof(unsigned long);
    unsigned long *new = g_realloc(old, new_len);
    bitmap_clear(new, old_nbits, new_nbits - old_nbits);
    return new;
}

2.2.1.6 cpu_physical_memory_set_dirty_range()
================================================================================
static inline void cpu_physical_memory_set_dirty_range(ram_addr_t start,
                                                       ram_addr_t length,
                                                       uint8_t mask)
{
    unsigned long end, page;
    unsigned long **d = ram_list.dirty_memory;

    end = TARGET_PAGE_ALIGN(start + length) >> TARGET_PAGE_BITS;
    page = start >> TARGET_PAGE_BITS;
    if (likely(mask & (1 << DIRTY_MEMORY_MIGRATION))) {
        bitmap_set_atomic(d[DIRTY_MEMORY_MIGRATION], page, end - page);
    }
    if (unlikely(mask & (1 << DIRTY_MEMORY_VGA))) {
        bitmap_set_atomic(d[DIRTY_MEMORY_VGA], page, end - page);
    }
    if (unlikely(mask & (1 << DIRTY_MEMORY_CODE))) {
        bitmap_set_atomic(d[DIRTY_MEMORY_CODE], page, end - page);
    }
    xen_modified_memory(start, length);
}

2.2.1.7 qemu_ram_setup_dump()
================================================================================
static void qemu_ram_setup_dump(void *addr, ram_addr_t size)
{
    int ret;

    /* Use MADV_DONTDUMP, if user doesn't want the guest memory in the core */
    if (!machine_dump_guest_core(current_machine)) {
        ret = qemu_madvise(addr, size, QEMU_MADV_DONTDUMP);
        if (ret) {
            perror("qemu_madvise");
            fprintf(stderr, "madvise doesn't support MADV_DONTDUMP, "
                            "but dump_guest_core=off specified\n");
        }
    }
}

2.2.1.8 qemu_madvise()
================================================================================
int qemu_madvise(void *addr, size_t len, int advice)
{
    if (advice == QEMU_MADV_INVALID) {
        errno = EINVAL;
        return -1;
    }
#if defined(CONFIG_MADVISE)
    return madvise(addr, len, advice);
#elif defined(CONFIG_POSIX_MADVISE)
    return posix_madvise(addr, len, advice);
#else
    errno = EINVAL;
    return -1;
#endif
}

2.2.1.9 kvm_setup_guest_memory()
================================================================================
void kvm_setup_guest_memory(void *start, size_t size)
{
    if (!kvm_has_sync_mmu()) {
        int ret = qemu_madvise(start, size, QEMU_MADV_DONTFORK);

        if (ret) {
            perror("qemu_madvise");
            fprintf(stderr,
                    "Need MADV_DONTFORK in absence of synchronous KVM MMU\n");
            exit(1);
        }
    }
}

2.3 memory_region_destructor_ram()
================================================================================

3. memory_region_add_subregion/overlap(offset)
================================================================================
; offset is the address in guest

void memory_region_add_subregion(MemoryRegion *mr,
                                 hwaddr offset,
                                 MemoryRegion *subregion)
{
    subregion->may_overlap = false;
    subregion->priority = 0;
    memory_region_add_subregion_common(mr, offset, subregion);
}

void memory_region_add_subregion_overlap(MemoryRegion *mr,
                                         hwaddr offset,
                                         MemoryRegion *subregion,
                                         int priority)
{
    subregion->may_overlap = true;
    subregion->priority = priority;
    memory_region_add_subregion_common(mr, offset, subregion);
}

3.1 memory_region_add_subregion_common()
================================================================================
static void memory_region_add_subregion_common(MemoryRegion *mr,
                                               hwaddr offset,
                                               MemoryRegion *subregion)
{
    assert(!subregion->container);
    subregion->container = mr;
    subregion->addr = offset;
    memory_region_update_container_subregions(subregion);
}

3.1.1 memory_region_update_container_subregions()
================================================================================
static void memory_region_update_container_subregions(MemoryRegion *subregion)
{
    hwaddr offset = subregion->addr;
    MemoryRegion *mr = subregion->container;
    MemoryRegion *other;

    memory_region_transaction_begin();

    memory_region_ref(subregion);
    QTAILQ_FOREACH(other, &mr->subregions, subregions_link) {
        if (subregion->may_overlap || other->may_overlap) {
            continue;
        }
        if (int128_ge(int128_make64(offset),
                      int128_add(int128_make64(other->addr), other->size))
            || int128_le(int128_add(int128_make64(offset), subregion->size),
                         int128_make64(other->addr))) {
            continue;
        }
#if 0
        printf("warning: subregion collision %llx/%llx (%s) "
               "vs %llx/%llx (%s)\n",
               (unsigned long long)offset,
               (unsigned long long)int128_get64(subregion->size),
               subregion->name,
               (unsigned long long)other->addr,
               (unsigned long long)int128_get64(other->size),
               other->name);
#endif
    }
    QTAILQ_FOREACH(other, &mr->subregions, subregions_link) {
        if (subregion->priority >= other->priority) {
            QTAILQ_INSERT_BEFORE(other, subregion, subregions_link);
            goto done;
        }
    }
    QTAILQ_INSERT_TAIL(&mr->subregions, subregion, subregions_link);
done:
    memory_region_update_pending |= mr->enabled && subregion->enabled;
    memory_region_transaction_commit();
}

3.1.1.1 memory_region_transaction_begin()
================================================================================
void memory_region_transaction_begin(void)
{
    qemu_flush_coalesced_mmio_buffer();
    ++memory_region_transaction_depth;
}

3.1.1.2 memory_region_ref()
================================================================================
void memory_region_ref(MemoryRegion *mr)
{
    /* MMIO callbacks most likely will access data that belongs
     * to the owner, hence the need to ref/unref the owner whenever
     * the memory region is in use.
     *
     * The memory region is a child of its owner.  As long as the
     * owner doesn't call unparent itself on the memory region,
     * ref-ing the owner will also keep the memory region alive.
     * Memory regions without an owner are supposed to never go away,
     * but we still ref/unref them for debugging purposes.
     */
    Object *obj = OBJECT(mr);
    if (obj && obj->parent) {
        object_ref(obj->parent);
    } else {
        object_ref(obj);
    }
}

3.1.1.3 memory_region_transaction_commit()
================================================================================
void memory_region_transaction_commit(void)
{
    AddressSpace *as;

    assert(memory_region_transaction_depth);
    --memory_region_transaction_depth;
    if (!memory_region_transaction_depth) {
        if (memory_region_update_pending) {
            MEMORY_LISTENER_CALL_GLOBAL(begin, Forward);

            QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
                address_space_update_topology(as);
            }

            MEMORY_LISTENER_CALL_GLOBAL(commit, Forward);
        } else if (ioeventfd_update_pending) {
            QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
                address_space_update_ioeventfds(as);
            }
        }
        memory_region_clear_pending();
   }
}

4. address_space_init()
================================================================================
void address_space_init(AddressSpace *as, MemoryRegion *root, const char *name)
{
    memory_region_ref(root);
    memory_region_transaction_begin();
    as->root = root;
    as->current_map = g_new(FlatView, 1);
    flatview_init(as->current_map);
    as->ioeventfd_nb = 0;
    as->ioeventfds = NULL;
    QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);
    as->name = g_strdup(name ? name : "anonymous");
    address_space_init_dispatch(as);
    memory_region_update_pending |= root->enabled;
    memory_region_transaction_commit();
}

4.1 memory_region_transaction_begin()
================================================================================
void memory_region_transaction_begin(void)
{
    qemu_flush_coalesced_mmio_buffer();
    ++memory_region_transaction_depth;
}

4.2 flatview_init()
================================================================================
static void flatview_init(FlatView *view)
{
    view->ref = 1;
    view->ranges = NULL;
    view->nr = 0;
    view->nr_allocated = 0;
}

4.3 add to address_spaces link
================================================================================
QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);

4.4 address_space_init_dispatch(), init the MemoryListener of as->dispatch_listener 
================================================================================
void address_space_init_dispatch(AddressSpace *as)
{
    as->dispatch = NULL;
    as->dispatch_listener = (MemoryListener) {
        .begin = mem_begin,
        .commit = mem_commit,
        .region_add = mem_add,
        .region_nop = mem_add,
        .priority = 0,
    };
    memory_listener_register(&as->dispatch_listener, as);
}

4.4.1 memory_listener_register, register listerner to memory_listeners list
================================================================================
; add to memory_listeners and sorted with priority

void memory_listener_register(MemoryListener *listener, AddressSpace *filter)
{
    MemoryListener *other = NULL;
    AddressSpace *as;

    listener->address_space_filter = filter;
    if (QTAILQ_EMPTY(&memory_listeners)
        || listener->priority >= QTAILQ_LAST(&memory_listeners,
                                             memory_listeners)->priority) {
        QTAILQ_INSERT_TAIL(&memory_listeners, listener, link);
    } else {
        QTAILQ_FOREACH(other, &memory_listeners, link) {
            if (listener->priority < other->priority) {
                break;
            }
        }
        QTAILQ_INSERT_BEFORE(other, listener, link);
    }

    QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
        listener_add_address_space(listener, as);
    }
}

4.5 memory_region_transaction_commit()
================================================================================

5. memory_region_transaction_commit(), update topology or ioeventfds
================================================================================

5.1 flatviews_reset()
================================================================================

5.1.1 flatviews_init()
================================================================================
; create flat_views/empty_view if necessary
; add empty_view into flat_views if necessary

5.1.1.1 flat_views = g_hash_table_new_full()
================================================================================

5.1.1.2 empty_view = generate_memory_topology(NULL);
================================================================================

5.1.2 generate_memory_topology()
================================================================================

5.2 MEMORY_LISTENER_CALL_GLOBAL(begin, Forward)
================================================================================

5.3 address_space_set_flatview()
================================================================================

5.3.1 address_space_update_topology_pass(false)
================================================================================
; invoke listeners region_del/region_add in case FV change

5.3.2 address_space_update_topology_pass(true)
================================================================================

5.4 address_space_update_ioeventfds()
================================================================================

5.4.1 address_space_add_del_ioeventfds()
================================================================================
; invoke listeners eventfd_del/eventfd_add in case FV change

5.5 MEMORY_LISTENER_CALL_GLOBAL(commit, Forward)
================================================================================

6. memory_listener_register()
================================================================================
void memory_listener_register(MemoryListener *listener, AddressSpace *filter)
{
    MemoryListener *other = NULL;
    AddressSpace *as;

    listener->address_space_filter = filter;
    if (QTAILQ_EMPTY(&memory_listeners)
        || listener->priority >= QTAILQ_LAST(&memory_listeners,
                                             memory_listeners)->priority) {
        QTAILQ_INSERT_TAIL(&memory_listeners, listener, link);
    } else {
        QTAILQ_FOREACH(other, &memory_listeners, link) {
            if (listener->priority < other->priority) {
                break;
            }
        }
        QTAILQ_INSERT_BEFORE(other, listener, link);
    }

    QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
        listener_add_address_space(listener, as);
    }
}

6.1 listener_add_address_space(), call listener->region_add on each FlatRange
================================================================================
static void listener_add_address_space(MemoryListener *listener,
                                       AddressSpace *as)
{
    FlatView *view;
    FlatRange *fr;

    if (listener->address_space_filter
        && listener->address_space_filter != as) {
        return;
    }

    if (global_dirty_log) {
        if (listener->log_global_start) {
            listener->log_global_start(listener);
        }
    }

    view = address_space_get_flatview(as);
    FOR_EACH_FLAT_RANGE(fr, view) {
        MemoryRegionSection section = {
            .mr = fr->mr,
            .address_space = as,
            .offset_within_region = fr->offset_in_region,
            .size = fr->addr.size,
            .offset_within_address_space = int128_get64(fr->addr.start),
            .readonly = fr->readonly,
        };
        if (listener->region_add) {
            listener->region_add(listener, &section);
        }
    }
    flatview_unref(view);
}

6. generate_memory_topology()
================================================================================

6.1 render_memory_region()
================================================================================

6.2 flatview_simplify()
================================================================================

6.3 address_space_dispatch_new()
================================================================================

6.4 flatview_add_to_dispatch()
================================================================================

6.4.1 register_subpage()
================================================================================

6.4.1.1 phys_page_find()
================================================================================

6.4.1.2 subpage_init()
================================================================================

6.4.1.3 phys_page_set()
================================================================================

6.4.1.3.1 phys_page_set_level()
================================================================================

6.4.1.4 subpage_register()
================================================================================

6.4.2 register_multipage()
================================================================================

6.5 address_space_dispatch_compact()
================================================================================

7. kvm listener
================================================================================
    kml->listener.region_add = kvm_region_add;
    kml->listener.region_del = kvm_region_del;
    kml->listener.log_start = kvm_log_start;
    kml->listener.log_stop = kvm_log_stop;
    kml->listener.log_sync = kvm_log_sync;
    kml->listener.priority = 10;

7.1 kvm_region_add()
================================================================================
static void kvm_region_add(MemoryListener *listener,
                           MemoryRegionSection *section)
{
    KVMMemoryListener *kml = container_of(listener, KVMMemoryListener, listener);

    memory_region_ref(section->mr);
    kvm_set_phys_mem(kml, section, true);
}

7.1.1 kvm_set_phys_mem()
================================================================================
static void kvm_set_phys_mem(KVMMemoryListener *kml,
                             MemoryRegionSection *section, bool add)
{
    KVMState *s = kvm_state;
    KVMSlot *mem, old;
    int err;
    MemoryRegion *mr = section->mr;
    bool writeable = !mr->readonly && !mr->rom_device;
    hwaddr start_addr = section->offset_within_address_space;
    ram_addr_t size = int128_get64(section->size);
    void *ram = NULL;
    unsigned delta;

    /* kvm works in page size chunks, but the function may be called
       with sub-page size and unaligned start address. Pad the start
       address to next and truncate size to previous page boundary. */
    delta = (TARGET_PAGE_SIZE - (start_addr & ~TARGET_PAGE_MASK));
    delta &= ~TARGET_PAGE_MASK;
    if (delta > size) {
        return;
    }
    start_addr += delta;
    size -= delta;
    size &= TARGET_PAGE_MASK;
    if (!size || (start_addr & ~TARGET_PAGE_MASK)) {
        return;
    }

    if (!memory_region_is_ram(mr)) {
        if (writeable || !kvm_readonly_mem_allowed) {
            return;
        } else if (!mr->romd_mode) {
            /* If the memory device is not in romd_mode, then we actually want
             * to remove the kvm memory slot so all accesses will trap. */
            add = false;
        }
    }

    ram = memory_region_get_ram_ptr(mr) + section->offset_within_region + delta;

    while (1) {
        mem = kvm_lookup_overlapping_slot(kml, start_addr, start_addr + size);
        if (!mem) {
            break;
        }

        if (add && start_addr >= mem->start_addr &&
            (start_addr + size <= mem->start_addr + mem->memory_size) &&
            (ram - start_addr == mem->ram - mem->start_addr)) {
            /* The new slot fits into the existing one and comes with
             * identical parameters - update flags and done. */
            kvm_slot_update_flags(kml, mem, mr);
            return;
        }

        old = *mem;

        if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
            kvm_physical_sync_dirty_bitmap(kml, section);
        }

        /* unregister the overlapping slot */
        mem->memory_size = 0;
        err = kvm_set_user_memory_region(kml, mem);
        if (err) {
            fprintf(stderr, "%s: error unregistering overlapping slot: %s\n",
                    __func__, strerror(-err));
            abort();
        }

        /* Workaround for older KVM versions: we can't join slots, even not by
         * unregistering the previous ones and then registering the larger
         * slot. We have to maintain the existing fragmentation. Sigh.
         *
         * This workaround assumes that the new slot starts at the same
         * address as the first existing one. If not or if some overlapping
         * slot comes around later, we will fail (not seen in practice so far)
         * - and actually require a recent KVM version. */
        if (s->broken_set_mem_region &&
            old.start_addr == start_addr && old.memory_size < size && add) {
            mem = kvm_alloc_slot(kml);
            mem->memory_size = old.memory_size;
            mem->start_addr = old.start_addr;
            mem->ram = old.ram;
            mem->flags = kvm_mem_flags(mr);

            err = kvm_set_user_memory_region(kml, mem);
            if (err) {
                fprintf(stderr, "%s: error updating slot: %s\n", __func__,
                        strerror(-err));
                abort();
            }

            start_addr += old.memory_size;
            ram += old.memory_size;
            size -= old.memory_size;
            continue;
        }

        /* register prefix slot */
        if (old.start_addr < start_addr) {
            mem = kvm_alloc_slot(kml);
            mem->memory_size = start_addr - old.start_addr;
            mem->start_addr = old.start_addr;
            mem->ram = old.ram;
            mem->flags =  kvm_mem_flags(mr);

            err = kvm_set_user_memory_region(kml, mem);
            if (err) {
                fprintf(stderr, "%s: error registering prefix slot: %s\n",
                        __func__, strerror(-err));
#ifdef TARGET_PPC
                fprintf(stderr, "%s: This is probably because your kernel's " \
                                "PAGE_SIZE is too big. Please try to use 4k " \
                                "PAGE_SIZE!\n", __func__);
#endif
                abort();
            }
        }

        /* register suffix slot */
        if (old.start_addr + old.memory_size > start_addr + size) {
            ram_addr_t size_delta;

            mem = kvm_alloc_slot(kml);
            mem->start_addr = start_addr + size;
            size_delta = mem->start_addr - old.start_addr;
            mem->memory_size = old.memory_size - size_delta;
            mem->ram = old.ram + size_delta;
            mem->flags = kvm_mem_flags(mr);

            err = kvm_set_user_memory_region(kml, mem);
            if (err) {
                fprintf(stderr, "%s: error registering suffix slot: %s\n",
                        __func__, strerror(-err));
                abort();
            }
        }
    }

    /* in case the KVM bug workaround already "consumed" the new slot */
    if (!size) {
        return;
    }
    if (!add) {
        return;
    }
    mem = kvm_alloc_slot(kml);
    mem->memory_size = size;
    mem->start_addr = start_addr;
    mem->ram = ram;
    mem->flags = kvm_mem_flags(mr);

    err = kvm_set_user_memory_region(kml, mem);
    if (err) {
        fprintf(stderr, "%s: error registering slot: %s\n", __func__,
                strerror(-err));
        abort();
    }
}

7.1.1.1 memory_region_get_ram_ptr(), return the virtual address on host
================================================================================
void *memory_region_get_ram_ptr(MemoryRegion *mr)
{
    if (mr->alias) {
        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;
    }

    assert(mr->ram_addr != RAM_ADDR_INVALID);

    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);
}

7.1.1.2 kvm_lookup_overlapping_slot(), find overlapped slot
================================================================================
static KVMSlot *kvm_lookup_overlapping_slot(KVMMemoryListener *kml,
                                            hwaddr start_addr,
                                            hwaddr end_addr)
{
    KVMState *s = kvm_state;
    KVMSlot *found = NULL;
    int i;

    for (i = 0; i < s->nr_slots; i++) {
        KVMSlot *mem = &kml->slots[i];

        if (mem->memory_size == 0 ||
            (found && found->start_addr < mem->start_addr)) {
            continue;
        }

        if (end_addr > mem->start_addr &&
            start_addr < mem->start_addr + mem->memory_size) {
            found = mem;
        }
    }

    return found;
}

7.1.1.3 kvm_slot_update_flags()
================================================================================

7.1.1.4 kvm_physical_sync_dirty_bitmap()
================================================================================

7.1.1.5 kvm_set_user_memory_region(), register mem slot to kvm
================================================================================
static int kvm_set_user_memory_region(KVMMemoryListener *kml, KVMSlot *slot)
{
    KVMState *s = kvm_state;
    struct kvm_userspace_memory_region mem;

    mem.slot = slot->slot | (kml->as_id << 16);
    mem.guest_phys_addr = slot->start_addr;
    mem.userspace_addr = (unsigned long)slot->ram;
    mem.flags = slot->flags;

    if (slot->memory_size && mem.flags & KVM_MEM_READONLY) {
        /* Set the slot size to 0 before setting the slot to the desired
         * value. This is needed based on KVM commit 75d61fbc. */
        mem.memory_size = 0;
        kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem);
    }
    mem.memory_size = slot->memory_size;
    return kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem);
}

7.1.1.6 kvm_alloc_slot(), get a free KVMSlot
================================================================================
static KVMSlot *kvm_alloc_slot(KVMMemoryListener *kml)
{
    KVMSlot *slot = kvm_get_free_slot(kml);

    if (slot) {
        return slot;
    }

    fprintf(stderr, "%s: no free slot available\n", __func__);
    abort();
}

7.1.1.7 kvm_mem_flags()
================================================================================
static int kvm_mem_flags(MemoryRegion *mr)
{
    bool readonly = mr->readonly || memory_region_is_romd(mr);
    int flags = 0;

    if (memory_region_get_dirty_log_mask(mr) != 0) {
        flags |= KVM_MEM_LOG_DIRTY_PAGES;
    }
    if (readonly && kvm_readonly_mem_allowed) {
        flags |= KVM_MEM_READONLY;
    }
    return flags;
}

7.2 kvm_region_del()
================================================================================

8. address_space_rw(as, addr, attrs, buf, len, is_write)
================================================================================

8.1 address_space_write()
================================================================================

8.1.1 address_space_to_flatview()
================================================================================

8.1.2 flatview_write(fv, addr, attrs, buf, len)
================================================================================

8.1.2.1 mr = flatview_translate(), from addr to MemoryRegion
================================================================================

8.1.2.2 flatview_write_continue()
================================================================================

8.2 address_space_read_full()
================================================================================

8.2.1 address_space_to_flatview()
================================================================================

8.2.2 flatview_read(fv, addr, attrs, buf, len)
================================================================================

8.2.2.1 mr = flatview_translate()
================================================================================

8.2.2.2 flatview_read_continue()
================================================================================

0. data structure
================================================================================

0.1 TYPE_MEMORY_REGION
================================================================================
       +------------------+
       |     TypeImpl     |
       |                  |
       |  +---------------+
       |  |               |
       |  |ObjectClass    |
       |  |  class_init   |
       +--+---------------+
                 |         
                 |         
                 v                           struct MemoryRegion
       +---------------------+               +------------------------+
       |                     |               |ops                     |
       |TYPE_MEMORY_REGION   |-------------->|  (MemoryRegionOps *)   |
       |     class_init      |               +------------------------+
       | memory_region_initfn|               |iommu_ops               |
       +---------+-----------+               |  (MemoryRegionIOMMUOps)|
                 |                           +------------------------+
                                             |                        |
                                             |                        |
                                             +------------------------+

0.1.1 MemoryRegion <-> MemoryRegion
================================================================================
; B and C is subregion of A

          struct MemoryRegion(A)
          +------------------------+
          |name                    |<------+---------------------------------+
          |  (const char *)        |       |                                 |
          +------------------------+       |                                 |
          |ops                     |       |                                 |
          |  (MemoryRegionOps *)   |       |                                 |
          +------------------------+       |                                 |
          |iommu_ops               |       |                                 |
          |  (MemoryRegionIOMMUOps)|       |                                 |
          +------------------------+       |                                 |
          |addr                    |       |                                 |
          |  (hwaddr)              |       |                                 |
          |size                    |       |                                 |
          |  (Int128)              |       |                                 |
          +------------------------+       |                                 |
          |ram_addr                |       |                                 |
          |  (ram_addr_t)          |       |                                 |
          +------------------------+       |                                 |
          |ioeventfds              |       |                                 |
          |(MemoryRegionIoeventfd*)|       |                                 |
          +------------------------+       |                                 |
          |may_overlap             |       |                                 |
          |  (bool)                |       |                                 |
          |priority                |       |                                 |
          |  (int)                 |       |                                 |
          +------------------------+       |                                 |
          |subregions              |       |                                 |
          |QTAILQ_HEAD()           |       |                                 |
          +------------------------+       |                                 |
           |                               |                                 |
           |                               |                                 |
           |                               |                                 |
           |  struct MemoryRegion(B)       |    struct MemoryRegion(C)       |      struct MemoryRegion(B)
           |  +------------------------+   |    +------------------------+   |      +------------------------+
           |  |container               |---+    |container               |---+      |container               |
           |  | (struct MemoryRegion *)|        | (struct MemoryRegion *)|          | (struct MemoryRegion *)|
           |  +------------------------+        +------------------------+          +------------------------+
           +->|subregions_link         |------->|subregions_link         |--------->|subregions_link         |
              |  QTAILQ_ENTRY          |        |  QTAILQ_ENTRY          |          |  QTAILQ_ENTRY          |
              +------------------------+        +------------------------+          +------------------------+
                                                |name                    |
                                                |  (const char *)        |
                                                +------------------------+
                                                |ops                     |
                                                |  (MemoryRegionOps *)   |
                                                +------------------------+
                                                |iommu_ops               |
                                                |  (MemoryRegionIOMMUOps)|
                                                +------------------------+
                                                |addr                    |
                                                |  (hwaddr)              |
                                                |size                    |
                                                |  (Int128)              |
                                                +------------------------+
                                                |ram_addr                |
                                                |  (ram_addr_t)          |
                                                +------------------------+
                                                |ioeventfds              |
                                                |(MemoryRegionIoeventfd*)|
                                                +------------------------+
                                                |may_overlap             |
                                                |  (bool)                |
                                                |priority                |
                                                |  (int)                 |
                                                +------------------------+



0.1.2 MemoryRegion(RAM) <-> RAMBlock/ram_list
================================================================================

  ram_list (RAMList), a list ordered by size(max_length)
  +------------------------------+
  |dirty_memory[]                |
  |    (unsigned long *)         |
  +------------------------------+
  |                              |
  |                              |
  +------------------------------+
  |blocks                        |
  |    QLIST_HEAD                |
  +------------------------------+
   |
   |     RAMBlock                                                     RAMBlock
   |     +---------------------------+                                +---------------------------+
   +---> |next                       | -----------------------------> |next                       |
         |    QLIST_ENTRY(RAMBlock)  |                                |    QLIST_ENTRY(RAMBlock)  |
         +---------------------------+                                +---------------------------+
         |offset                     |                                |offset                     |
         |used_length                |                                |used_length                |
         |max_length                 |                                |max_length                 |
         |    (ram_addr_t)           |                                |    (ram_addr_t)           |
         +---------------------------+                                +---------------------------+
         |fd                         |                                |fd                         |
         |    (int)                  |                                |    (int)                  |
         +---------------------------+                                +---------------------------+
         |host                       |  virtual address of a ram      |host                       |  
         |    (uint8_t *)            |  in host (mmap)                |    (uint8_t *)            |
         +---------------------------+                                +---------------------------+
         |mr                         |                                |mr                         |
         |    (struct MemoryRegion *)|                                |    (struct MemoryRegion *)|
         +---------------------------+                                +---------------------------+
          |                                                            |
          |                                                            |
          |                                                            |
          |   struct MemoryRegion                                      |   struct MemoryRegion
          +-->+------------------------+                               +-->+------------------------+
              |name                    |                                   |name                    |
              |  (const char *)        |                                   |  (const char *)        |
              +------------------------+                                   +------------------------+
              |ops                     |                                   |ops                     |
              |  (MemoryRegionOps *)   |                                   |  (MemoryRegionOps *)   |
              +------------------------+                                   +------------------------+
              |iommu_ops               |                                   |iommu_ops               |
              |  (MemoryRegionIOMMUOps)|                                   |  (MemoryRegionIOMMUOps)|
              +------------------------+                                   +------------------------+
              |addr                    |  physical address in guest        |addr                    |
              |  (hwaddr)              |  (offset in RAMBlock)             |  (hwaddr)              |
              |size                    |                                   |size                    |
              |  (Int128)              |                                   |  (Int128)              |
              +------------------------+                                   +------------------------+
              |ram_addr                |                                   |ram_addr                |
              |  (ram_addr_t)          |                                   |  (ram_addr_t)          |
              +------------------------+                                   +------------------------+
              |ioeventfds              |                                   |ioeventfds              |
              |(MemoryRegionIoeventfd*)|                                   |(MemoryRegionIoeventfd*)|
              +------------------------+                                   +------------------------+

0.1.2.1 MemoryRegion(RAM) <-> RAMBlock/ram_list
================================================================================


         struct MemoryRegion                                      
         +---------------------------+                               
         |addr                       |  GPA ---+
         |  (hwaddr)                 |         |
         |size                       |         |                     
         |  (Int128)                 |         |                     
         +---------------------------+         |        kvm_userspace_memory_region                   
	 |ram_block                  |         |        +----------------------------+
	 |  (RAMBlock *) ---+        |         +------->|guest_phys_addr             |
         +---------------------------+                  |                            |
                            |                  +------->|userspace_addr              |
                            |                  |        |                            |
                            |                  |        +----------------------------+
                            |                  |
         RAMBlock           v                  |
         +---------------------------+         |
         |host                       |  HVA ---+
         |    (uint8_t *)            |  
         +---------------------------+
         |mr                         |
         |    (struct MemoryRegion *)|
         +---------------------------+

0.2 address_space
================================================================================

    address_space(global)
    +-------------------------------+
    |tqh_last                       |
    |tqh_first                      |
    +-+-----------------------------+
      |        
      |   address_space_memory             address_space_io
      |   (AddressSpace)                   (AddressSpace)
      |   +------------------------+       +------------------------+
      +-->|address_spaces_link     | ----->|address_spaces_link     |
          |                        |       |                        |
          +------------------------+       +------------------------+

0.2.1 AddressSpace                                                                      
================================================================================        
                                                                                        
    AddressSpace               
    +-------------------------+
    |name                     |
    |   (char *)              |          FlatView (An array of FlatRange)
    +-------------------------+          +----------------------+
    |current_map              | -------->|nr                    |
    |   (FlatView *)          |          |nr_allocated          |
    +-------------------------+          |   (unsigned)         |         FlatRange             FlatRange
    |                         |          +----------------------+         
    |                         |          |ranges                | ------> +---------------------+---------------------+
    |                         |          |   (FlatRange *)      |         |offset_in_region     |offset_in_region     |
    |                         |          +----------------------+         |    (hwaddr)         |    (hwaddr)         |
    |                         |                                           +---------------------+---------------------+
    |                         |                                           |addr(AddrRange)      |addr(AddrRange)      |
    |                         |                                           |    +----------------|    +----------------+
    |                         |                                           |    |start (Int128)  |    |start (Int128)  |
    |                         |                                           |    |size  (Int128)  |    |size  (Int128)  |
    |                         |                                           +----+----------------+----+----------------+
    |                         |                                           |mr                   |mr                   |
    |                         |                                           | (MemoryRegion *)    | (MemoryRegion *)    |
    |                         |                                           +---------------------+---------------------+
    |                         |
    |                         |
    |                         |
    |                         |          MemoryRegion(system_memory/system_io)
    +-------------------------+          +----------------------+
    |root                     |          |                      | root of a MemoryRegion
    |   (MemoryRegion *)      | -------->|                      | tree
    +-------------------------+          +----------------------+
    |                         |
    |                         |
    +-------------------------+
    |ioeventfd_nb             |
    |   (int)                 |          MemoryRegionIoeventfd[]
    |ioeventfds               |          +-------------------------+
    |(MemoryRegionIoeventfd *)| -------->|addr(AddrRange)          |
    +-------------------------+          |   +---------------------+
    |                         |          |   | start (Int128)      |
    |                         |          |   | size  (Int128)      |
    |                         |          +---+---------------------+
    |                         |          |match_data (bool)        |
    |                         |          |data (uint64_t)          |
    |                         |          +-------------------------+
    |                         |          |e (EventNotifier *)      |
    |                         |          |   +---------------------+
    |                         |          |   |  rfd   (int)        |
    |                         |          |   |  wfd   (int)        |
    |                         |          +---+---------------------+
    |                         |
    |                         |
    +-------------------------+
    |listerners               |
    |(list of MemoryListener) |
    |                         |
    |                         |
    |                         |
    +-------------------------+




        FlatView (An array of FlatRange)
        +----------------------+
        |nr                    |
        |nr_allocated          |
        |   (unsigned)         |         FlatRange             FlatRange
        +----------------------+         
        |ranges                | ------> +---------------------+---------------------+
        |   (FlatRange *)      |         |offset_in_region     |offset_in_region     |
        +----------------------+         |    (hwaddr)         |    (hwaddr)         |
        |                      |         +---------------------+---------------------+
        |                      |         |addr(AddrRange)      |addr(AddrRange)      |
        |                      |         |    +----------------|    +----------------+
        |                      |         |    |start (Int128)  |    |start (Int128)  |     
        |                      |         |    |size  (Int128)  |    |size  (Int128)  |
        |                      |         +----+----------------+----+----------------+
        |                      |         |mr                   |mr                   |
        |                      |         | (MemoryRegion *)    | (MemoryRegion *)    |
        |                      |         +---------------------+---------------------+
        |                      |
        |                      |         AddressSpaceDispatch
        +----------------------+         +-------------------------+
        |dispatch              | ------->|as                       |
        |(AddressSpaceDispatch)|         |   (AddressSpace *)      |
        +----------------------+         +-------------------------+
                                         |mru_section              |
                                         |   (MemoryRegionSection*)|
                                         |                         |
                                         |                         |
                                         |                         |
                                         |                         |
                                         |                         |
                                         +-------------------------+
                                         |map(PhysPageMap)         |         MemoryRegionSection[]
                                         |   +---------------------+         +---------------------------+---------------------------+---------------------------+---------------------------+---------------------------+---------------------------+
                                         |   |sections             |-------->|mr = io_mem_unassigned     |mr = io_mem_notdirty       |mr = io_mem_rom            |mr = io_mem_watch          |mr  = one mr in tree       |mr  = subpage_t->iomem     |
                                         |   | MemoryRegionSection*|         |   (MemoryRegion *)        |   (MemoryRegion *)        |   (MemoryRegion *)        |   (MemoryRegion *)        |   (MemoryRegion *)        |   (MemoryRegion *)        |
                                         |   |                     |         |                           |                           |                           |                           |                           |                           |
                                         |   +---------------------+         +---------------------------+---------------------------+---------------------------+---------------------------+---------------------------+---------------------------+
                                         |   |sections_nb          |         |fv                         |fv                         |fv                         |fv                         |fv                         |fv                         |
                                         |   |sections_nb_alloc    |         |   (FlatView *)            |   (FlatView *)            |   (FlatView *)            |   (FlatView *)            |   (FlatView *)            |   (FlatView *)            |
                                         |   |   (unsigned)        |         +---------------------------+---------------------------+---------------------------+---------------------------+---------------------------+---------------------------+
                                         |   +---------------------+         |size (Int128)              |size (Int128)              |size (Int128)              |size (Int128)              |size (Int128)              |size (Int128)              |
                                         |   |                     |         +---------------------------+---------------------------+---------------------------+---------------------------+---------------------------+---------------------------+
                                         |   |                     |         |offset_within_region       |offset_within_region       |offset_within_region       |offset_within_region       |offset_within_region       |offset_within_region       |
                                         |   |                     |         |   (hwaddr)                |   (hwaddr)                |   (hwaddr)                |   (hwaddr)                |   (hwaddr)                |   (hwaddr)                |
                                         |   |                     |         |offset_within_address_space|offset_within_address_space|offset_within_address_space|offset_within_address_space|offset_within_address_space|offset_within_address_space|
                                         |   |                     |         |   (hwaddr)  GPA           |   (hwaddr)  GPA           |   (hwaddr)  GPA           |   (hwaddr)  GPA           |   (hwaddr)                |   (hwaddr)                |
                                         |   |                     |         +---------------------------+---------------------------+---------------------------+---------------------------+---------------------------+---------------------------+
                                         |   |                     |                                                                                                                                  ^
                                         |   |                     |                                                           nodes[1]                                                               |
                                         |   |                     |                                                     +---->+------------------+                                                   |
                                         |   |                     |                                                     |     |u32 skip:6        | = 0                                               |
                                         |   |                     |                                                     |     |u32 ptr:26        | = 4      -----------------------------------------+
                                         |   |                     |         P_L2_LEVELS = 6                             |     +------------------+
                                         |   |                     |         nodes[0] = PhysPageEntry[P_L2_SIZE = 2^9]   |     |                  |
                                         |   +---------------------+         +------------------+                        |     |  ...             |
                                         |   |nodes                | ------->|u32 skip:6        | = 1                    |     |                  |
                                         |   |  (Node *)           |         |u32 ptr:26        | = 1       -------------+     +------------------+
                                         |   +---------------------+         +------------------+                              |u32 skip:6        | = 0
                                         |   |nodes_nb             |         |                  |                              |u32 ptr:26        | = PHYS_SECTION_UNASSIGNED
                                         |   |nodes_nb_alloc       |         |  ...             |                              +------------------+
                                         |   |  (unsigned)         |         |                  |
                                         |   +---------------------+         +------------------+
                                         |   |                     |         |u32 skip:6        | = 1
                                         |   |                     |         |u32 ptr:26        | = PHYS_MAP_NODE_NIL          nodes[2]
                                         |   |                     |         +------------------+                        +---->+------------------+
                                         |   |                     |         |u32 skip:6        | = 1                    |     |u32 skip:6        |
                                         |   |                     |         |u32 ptr:26        | = 2       -------------+     |u32 ptr:26        |
                                         |   |                     |         +------------------+                              +------------------+
                                         |   |                     |              ^                                            |                  |
                                         |   |                     |              |                                            |  ...             |
                                         |   |                     |              |                                            |                  |
                                         +---+---------------------+              |                                            +------------------+
                                         |phys_map(PhysPageEntry)  |              |                                            |u32 skip:6        |
                                         |   +---------------------+              |                                            |u32 ptr:26        |
                                         |   |u32 skip:6           | = 1          |                                            +------------------+
                                         |   |u32 ptr:26           | = 0  --------+
                                         +---+---------------------+


     subpage_t                                               TARGET_PAGE_SIZE entries
     +----------------------------+                          +-------------------+
     |sub_section[]               | ------------------------>| 0                 |
     |    (uint16_t)              |                          | 0                 |
     +----------------------------+                          | 0                 |
     |fv                          |                     -+-  |                   |
     |    (FlatView*)             |                      ^   |                   |
     |base                        | = GPA if correct     |   |                   |
     |    (hwaddr)                |                          |                   |
     +----------------------------+                    size  |                   |
     |iomem                       |                      |   |                   |
     |    (MemoryRegion)          |                      v   |                   |
     |    +-----------------------+                     -+-  |                   |
     |    |ops                    | = subpage_ops            | 0                 |
     |    |size                   | = TARGET_PAGE_SIZE       | 0                 |
     |    |subpage                | = true                   | 0                 |
     |    |                       |                          | 0                 |
     +----+-----------------------+                          +-------------------+



0.3 memory_listeners
================================================================================

    memory_listeners(global)
    +-------------------------------+
    |tqh_last                       |
    |tqh_first                      |
    +-+-----------------------------+
      |        
      |   (MemoryListener)                 (MemoryListener)
      |   +------------------------+       +------------------------+
      +-->|link                    | ----->|link                    |
          |                        |       |                        |
          +------------------------+       +------------------------+

0.3.1 MemoryListener
================================================================================


     MemoryListener
     +---------------------------+
     |begin                      |
     |commit                     |
     +---------------------------+
     |region_add                 |
     |region_del                 |
     +---------------------------+
     |eventfd_add                |
     |eventfd_del                |
     +---------------------------+
     |log_start                  |
     |log_stop                   |
     +---------------------------+
     |address_space              |
     |    (AddressSpace *)       |
     +---------------------------+


0.4 address and offset
================================================================================

    MemoryRegion
    +---------------------------+
    |addr                       |      GPA
    |                           |
    |                           |
    |alias_offset               |      offset in alias region
    +---------------------------+

    FlatRange
    +---------------------------+
    |addr                       |      GPA
    |                           |
    |offset_in_region           |      offset to FlatRange->mr
    |                           |
    +---------------------------+

    MemoryRegionSection
    +---------------------------+
    |offset_within_address_space|      GPA
    |offset_within_region       |      same as FlatRange->offset_in_region
    +---------------------------+

    RAMBlock
    +---------------------------+
    |host                       |      HVA
    |                           |
    |offset                     |      offset in ram_list
    +---------------------------+
