1. acpi_pci_root_init()
================================================================================
acpi_pci_root_init()
	acpi_hest_init() <-- hardware error table
	pci_acpi_crs_quirks()

	acpi_bus_register_driver(&acpi_pci_root_driver); acpi_pci_root_driver is struct acpi_driver
                    static struct acpi_driver acpi_pci_root_driver = {
                    	.name = "pci_root",
                    	.class = ACPI_PCI_ROOT_CLASS,
                    	.ids = root_device_ids,
                    	.ops = {
                    		.add = acpi_pci_root_add,
                    		.remove = acpi_pci_root_remove,
                    		.start = acpi_pci_root_start,
                    		},
                    };
		driver->drv.name = driver->name;
		driver->drv.bus  = &acpi_bus_type;
			struct bus_type acpi_bus_type = {
				.name		= "acpi",
				.suspend	= acpi_device_suspend,
				.resume		= acpi_device_resume,
				.match		= acpi_bus_match,
				.probe		= acpi_device_probe,
				.remove		= acpi_device_remove,
				.uevent		= acpi_device_uevent,
			};
		driver->drv.owner = driver->owner;
		driver_register(&driver->drv); this drv is struct device_driver 
continue:
		driver_find(name, bus); search by the name
			if this return non-zero, it means there is already a driver
			for this bus
		bus_add_driver(drv)
			priv = kzalloc(sizeof(*priv), GFP_KERNEL);
			klist_init(&priv->klist_devices, NULL, NULL); this list indicate the devices match the driver
			priv->driver = drv;
			drv->p = priv;
			; bus->p->drivers_kset is the drivers kset
			priv->kobj.kset = bus->p->drivers_kset;
			error = kobject_init_and_add(&priv->kobj, &driver_ktype, NULL,
						     "%s", drv->name);
			driver_attach(drv->bus, NULL, drv, __driver_attach); try to bind driver to devices
				bus_for_each_dev(drv->bus, NULL, drv, __driver_attach); go through the bus devices list
					klist_iter_init_node(&bus->p->klist_devices, &i,
							     (start ? &start->p->knode_bus : NULL));
					; acpi_scan_init() is called to enumerate the devices on acpi bus
					__driver_attach(dev, data);
						driver_match_device(drv, dev);
							 drv->bus->match == acpi_bus_match();
						driver_probe_device();
							really_probe(); 
								driver_sysfs_add(dev);
								; dev->bus should be acpi_bus_type
								if (dev->bus->probe) {
									ret = dev->bus->probe(dev);== acpi_device_probe();
									if (ret)
										goto probe_failed;
								} else if (drv->probe) {
									ret = drv->probe(dev);
									if (ret)
										goto probe_failed;
								}
								driver_bound(dev);
									klist_add_tail(&dev->p->knode_driver, &dev->driver->p->klist_devices);
			;add into the klist_drivers
			klist_add_tail(&priv->knode_bus, &bus->p->klist_drivers);
			module_add_driver(drv->owner, drv);
			; create sysfs file for driver
			error = driver_create_file(drv, &driver_attr_uevent);

continue here:
	acpi_device_probe()
		acpi_bus_driver_init(acpi_device , acpi_driver);
			driver->ops.add(device); == acpi_pci_root_add(); <-- this is in the acpi_pci_root_driver;

struct acpi_pci_root {
	struct list_head node;
	struct acpi_device * device;
	struct acpi_pci_id id;
	struct pci_bus *bus;
	u16 segment;
	struct resource secondary;	/* downstream bus range */

	u32 osc_support_set;	/* _OSC state of support bits */
	u32 osc_control_set;	/* _OSC state of control bits */
};

acpi_pci_root_add()
	acpi_evaluate_integer(struct acpi_device *device); get the _SEG, which indidate the domain
	try_get_root_bridge_busnr(device->handle, res); get the bus number range from ACPI namespace
		acpi_walk_resources(handle, METHOD_NAME__CRS, get_root_bridge_busnr_callback, res);
		                      ;get the bus number range under root bridge;
			acpi_rs_get_method_data(); <-- put resource info into buffer
	    			acpi_ut_evaluate_object(handle, path, ACPI_BTYPE_BUFFER, &obj_desc);
					status = acpi_ns_evaluate(info);
				acpi_rs_create_resource_list();
				acpi_ut_remove_reference();
			now buffer contains several resources.
			for each resource, get_root_bridge_busnr_callback will process it
			while there is only one(I guess) resource which describe 
			the pci bus range number.
			get_root_bridge_busnr_callback() is used to assign the context 

	root->device = device;
	device->driver_data = root;
	list_add_tail(&root->node, &acpi_pci_roots); acpi_pci_roots is a list of pci roots

	root->bus = pci_acpi_scan_root(root) ; <-- get the root bus of this root bridge
		bus = pci_find_bus(domain, busnum); <-- start from 0:0, find doman:busnum
			pci_find_next_bus() ;<- 
				search from pci_root_buses(a list), or its' next
				for each entry first match the domain
				then match the busnr, also tranverse the children
		if bus == NULL;
			bus = pci_create_bus(NULL, busnum, &pci_root_ops, sd); <- pci_root_ops is the operations
				b = pci_alloc_bus();
				b->sysdata = sysdata;
				b->ops = ops; <- this is assigend to pci_root_ops
				b2 = pci_find_bus(pci_domain_nr(b), bus); 
				list_add_tail(&b->node, &pci_root_buses); <- why this is under root?
				dev->parent = parent; parent = NULL;
				dev_set_name(dev, "pci%04x:%02x", pci_domain_nr(b), bus);
				error = device_register(dev);
				b->bridge = get_device(dev); <- ? i'm curious
				if (!parent)
					set_dev_node(b->bridge, pcibus_to_node(b)); numa node
				b->dev.class = &pcibus_class;
				b->dev.parent = b->bridge;
				b->number = b->secondary = bus;
				b->resource[0] = &ioport_resource;
				b->resource[1] = &iomem_resource;
			get_current_resources(device, busnum, domain, bus); allocate resource for this device
				info.bus = bus;
				acpi_walk_resources(); <- get res number
				acpi_walk_resources(setup_resource); <- get res detail from namespace
					setup_resource(); setup the res in bus
						res = &info->res[info->res_num];
						res->name = info->name;
						res->flags = flags;
						res->start = start;
						res->end = end;
						res->child = NULL;
				add_resources(&info)
					insert_resource_conflict();Insert a resource into the resource tree
					if no conflict, add this in the bus res list
					pci_bus_add_resource(); add this info in bus structure
			bus->subordinate = pci_scan_child_bus(bus); <- pass in the root bus, get the max child
				/* Go find them, Rover! */
				for (devfn = 0; devfn < 0x100; devfn += 8); scan each dev/slot
					pci_scan_slot(bus, devfn);
						pci_scan_single_device(bus, devfn);
							pci_get_slot()<- get the corresponding dev, or
							pci_scan_device(bus, devfn); <- scan the bus, assign the devfn number
								dev = alloc_pci_dev(); not we create a new pci_dev
								dev->bus = bus; pci_dev->bus is the bus which device on
								dev->devfn = devfn;
								pci_setup_device(dev);
									dev->dev.parent = dev->bus->bridge;
									dev->dev.bus = &pci_bus_type;
									dev->slot = slot; <- associate the slot
									dev->class = class;
									dev->cfg_size = pci_cfg_space_size(dev);
									dev->current_state = PCI_UNKNOWN;
									base on dev->hdr_type process 
									for normal device
										pci_read_irq(dev);
										pci_read_bases(dev, 6, PCI_ROM_ADDRESS); retrieve 6 BAR and ROM
											res = &dev->resource[pos];
											__pci_read_base(dev, pci_bar_unknown, res, reg);
												fetch the bar and their res start/stop
										pci_read_config_word(SUBSYSTEM_VENDOR_ID);
										pci_read_config_word(SUBSYSTEM_ID);
							pci_device_add(dev, bus); Add the device to our list of discovered devices
								                  And then we will iterate on this list to scan
										  the bridge
								pci_dev_get(dev);
								pci_init_capabilities(dev); Initialize various capabilities
									pci_msi_init_pci_dev(dev);
									pci_allocate-cap_save_buffers(dev);
									pci_pm_init(dev); Power Management
									platform_pci_wakeup_init(dev);
									pci_vpd_pci22_init(dev); Vital Product Data
									pci_enable_ari(dev);
									pci_iov_init(dev); iov init!
										pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_SRIOV)
										sriov_init(dev, pos);
											pci_read_config_word(dev, pos + PCI_SRIOV_CTRL, &ctrl);
											pci_read_config_word(dev, pos + PCI_SRIOV_TOTAL_VF, &total);
											list_for_each_entry(pdev, &dev->bus->devices, bus_list); ? confused
												if (pdev->is_physfn)
													goto found;
											pci_write_config_word(dev, pos + PCI_SRIOV_CTRL, ctrl);
											pci_write_config_word(dev, pos + PCI_SRIOV_NUM_VF, total);
											pci_read_config_word(dev, pos + PCI_SRIOV_VF_OFFSET, &offset);
											pci_read_config_word(dev, pos + PCI_SRIOV_VF_STRIDE, &stride);
											pci_read_config_dword(dev, pos + PCI_SRIOV_SUP_PGSIZE, &pgsz);
											read 6 SRIOV_BAR;
										pci_enable_acs(dev); ACS P2P upstream forwarding
					pci_iov_bus_range(bus);
						for each virtual device under the bus
					pci_scan_bridge(bus, dev, max, pass); it has two passes get the max child
							bus is the current bus
							dev is one device under this bus
							max is the current larget bus number
							pass indicate the round
						pci_bus *child;
						pci_read_config_dword(dev, PCI_PRIMARY_BUS, &buses);
						get the bus number

						primary = buses & 0xFF;
						secondary = (buses >> 8) & 0xFF;
						subordinate = (buses >> 16) & 0xFF;
						
						pass 0
						child = pci_find_bus(pci_domain_nr(bus), secondary);
						if child == NULL
							create a child
							pci_add_new_bus(bus, dev, secondary);
								pci_alloc_child_bus(parent, bridge, busnr);
									pci_bus *child = pci_alloc_bus();
									child->parent = parent;
									child->ops = parent->ops;
									child->sysdata = parent->sysdata;
									child->bus_flags = parent->bus_flags;

									child->number = child->secondary = busnr;
									child->primary = parent->secondary;
									child->subordinate = 0xff;

									if (!bridge)
										return child;
									child->self = bridge;
									child->bridge = get_device(&bridge->dev);
									for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++) {
										child->resource[i] = &bridge->resource[PCI_BRIDGE_RESOURCES+i];
										child->resource[i]->name = child->name;
									}
									bridge->subordinate = child; 
									        if a pci_dev is a bridge, then its subordinate 
										will not be null and point to its subordinate bus
								list_add_tail(&child->node, &parent->children);
						cmax = pci_scan_child_bus(child);

						pass 1, i think
						child = pci_add_new_bus(bus, dev, ++max);

				return max;
		return bus;




2. pci arch init on x86
================================================================================
start_kernel
	rest_init();
		kernel_thread(kernel_init);
			do_basic_setup();
				do_initcalls();
pci_arch_init <--- just on x86?
	pci_direct_probe(); return 1
		request_region(0xCF8, 8, "PCI conf1");
		pci_check_type1();
			raw_pci_ops = &pci_direct_conf1; <-- assign the raw_pci_ops
	pci_mmcfg_early_init();  <-- this works for mmcfg pci system
		__pci_mmcfg_init();
			pci_mmcfg_check_hostbridge();
				pci_mmcfg_probes[i].probe();
					pci_mmconfig_add();  <--- add to the *pci_mmcfg_list*
				pci_mmcfg_check_end_bus_number();
			if pci_mmcfg_check_hostbridge failed
			acpi_sfi_table_parse(ACPI_SIG_MCFG, pci_parse_mcfg);
				acpi_table_parse(ACPI_SIG_MCFG, pci_parse_mcfg); <-- this is a very interesting function
										; here it trys to access the 
										PCI Memory Mapped Configuration table
					acpi_get_table_with_size(); <- walk the acpi_gbl_root_table_list
								 ; and get the content of the table
						acpi_tb_verify_table();
							acpi_os_map_memory(); <--- not clear
					pci_parse_mcfg(table);  handle the table content
						free_all_mmcfg();
						extract the table
						pci_mmconfig_add();
	x86_init.pci.arch_init()	
	pci_pcbios_init()
		raw_pci_ops = pci_find_bios(); if pcbios exist, *raw_pci_ops* 
		                              would be pci_bios_access
	pci_direct_init()
		set *raw_pci_ops* depends on type
	dmi_check_pciprobe()
		dmi_check_system(pciprobe_dmi_table)
	dmi_check_skip_isa_align()
		dmi_check_system(can_skip_pciprobe_dmi_table);


3. sriov_init how to reserve resource for VF and how sriov is initialized
================================================================================
There are different path to call pci_iov_init()
*pci_enable_sriov() called in driver probe function
pci_enable_sriov();
	sriov_enable(struct pci_dev *dev, int nr_virfn); here dev is a phy func
		get initial vf number
		verify the bus number of vf
		pci_enable_resources(dev, bars)
		enabe VF by writing 1 to PCI_SRIOV_CTRL_VFE;
		for each VF call, 
		virtfn_add()
			virtfn = alloc_pci_dev()
			virtfn->bus = virtfn_add_bus(dev->bus, virtfn_bus(dev, id))
				child = pci_find_bus();
				pci_add_new_bus(bus, busnr);
				pci_bus_add_child(child);
			pci_setup_device(virtfn);
				setup the bar
			pci_device_add(struct pci_dev *dev, struct pci_bus *bus);
				pci_init_capabilities(struct pci_dev *dev);
					pci_iov_init(dev); does VF has this EXT_CAP?
			virtfn->physfn = pci_dev_get(dev); point to his PF
			virtfn->is_virtfn = 1;
			pci_bus_add_device(virtfn);

*when scan the slot in pci_scan_child_bus()
pci_scan_child_bus();
	pci_scan_slot();
		pci_scan_single_device();
			pci_device_add();
				pci_init_capabilities(dev);
					pci_iov_init();
	pci_iov_bus_range(bus);

pci_iov_init()
	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_SRIOV);
	sriov_init(dev, pos); this dev is a PF
		disable the VF first.
		get TotalVFs, total = TotalVFs

		get the VF_OFFSET, offset = VF_OFFSET
		get the VF_STRIDE, stride = VF_STRIDE
		get supported page size, pgsz
		set page size

		initialize those IOV resource
		initialize the pci_sriov structure


4. reassign
================================================================================
kernel command line option, pci=assign-busses

in pcibios_setup()
	pci_probe |= PCI_ASSIGN_ALL_BUSSES;
	
Then 
unsigned int pcibios_assign_all_busses(void)
{
	return (pci_probe & PCI_ASSIGN_ALL_BUSSES) ? 1 : 0;
}

The pcibios_assign_all_busses() will be called pci_scan_bridge(), which means
1. if the command line option is set, then kernel will reassign the bus numbers 
   for all the devices. Ignore the BIOS work.
2. If the command line option is not set, then the kernel will just accept the 
   BIOS's config for those devices works fine. 
   Reassign the bus number for those not work fine with the BIOS.

5. resourse realloc
================================================================================
kernel command line option, pci=realloc

This will pci_setup() call pci_realloc() to set the pci_realloc_enable to 1.

function pci_assign_unassigned_resources() will try to test this bit. 
If set will realloc res.
pci_assign_unassigned_resources();
	int max_depth = pci_get_max_depth();
	pci_try_num = max_depth + 1;
	/* Depth first, calculate sizes and alignments of all
	   subordinate buses. */
	; for each bus linked to pci_root_buses
	; traverse each domain
	list_for_each_entry(bus, &pci_root_buses, node)
	{
		; calculate the resource must needed and the 
		; additional resouces. 
		; add them in add_list;
		__pci_bus_size_bridges(bus, &add_list);
			; go through the child bridge first

			; then check our bus
			pci_bridge_check_ranges(bus);
			if (bus->self->is_hotplug_bridge) {
				additional_io_size  = pci_hotplug_io_size;
				additional_mem_size = pci_hotplug_mem_size;
			}
			pbus_size_io(bus, 0, additional_io_size, add_head);
				struct resource *b_res = find_free_bus_resource(bus, IORESOURCE_IO);
					; return no parent resource
					if (r && (r->flags & type_mask) == type && !r->parent)
						return r;
				summarize the all io resource size of device under this bus, no parent
				size = sum of res less than 1k.
				size1 = sum of res more than 1k.
				calculate_iosize(size, 0, size1, resource_size(b_res), 4096);
					size = ALIGN(size+size1, 4096);
					return size;
				still confused with the algorithm
				not understand how much size added to the list
			pbus_size_mem(bus, prefmask, prefmask, 0, additional_mem_size, add_head)
				go through each device under this bus
				calculate the size of resources with out parent
				calculate_memsize(size, 0, 0, resource_size(b_res), min_align);
					size = max(size, min_size, old_size);
					size = ALIGN(size+size1, min_align); here size1==0
					return size;
				not understand how much size added to the list
	}
	/* Depth last, allocate resources and update the hardware. */
	list_for_each_entry(bus, &pci_root_buses, node) ; do the real work
	{
		__pci_bus_assign_resources(bus, &add_list, &head);
			pbus_assign_resources_sorted(bus, add_head, fail_head);
				for each device attached on this bus call
				__dev_sort_resources(dev, &head); form an ordered list of all the
					                          res of devices under one bus
					pdev_sort_resources(dev, head); sort res by alignment
						add the dev->res who has no parent, to the *head*
						int alignment order
				__assign_resources_sorted(&head, add_head, fail_head);
					/* Satisfy the must-have resource requests */
					assign_requested_resources_sorted(head, fail_head); 
					; allocate res here
						pci_assign_resource(list->dev, idx);
							go through the parent and call
							__pci_assign_resource(bus, dev, resno); 
							; this function really do the allocation 
							; of the resource
								pci_bus_alloc_resource(bus, res, size, align, min
										IORESOURCE_PREFETCH, pcibios_align_resource, dev);
								; allocate a resource from a parent bus
								allocate_resource();
								or call this one directly
								request_resource_confict(root, res);

								pci_update_resource(dev, resno);
					/* Try to satisfy any additional nice-to-have resource
						requests */
					adjust_resources_sorted(add_head, head);
						call
						pci_assign_resource(list->dev, idx);
						or
						adjust_resource(res, res->start);

			then call this function for each subordinate bus
			could this miss some bus?
	}
	BUG_ON(add_list.next);
	tried_times++;

	/* don't realloc if asked to do so */
	if (!pci_realloc_enabled()) {
		free_list(resource_list_x, &head);
		goto enable_and_dump;
	}

	failed_type = 0; get the types of res
	for (list = head.next; list;) {
		failed_type |= list->flags;
		list = list->next;
	}

	/*
	 * Try to release leaf bridge's resources that doesn't fit resource of
	 * child device under that bridge
	 */
	; for each bus need to adjust, it will release 
	for (list = head.next; list;) 
	{
		bus = list->dev->bus;
		pci_bus_release_bridge_resources(bus, list->flags & type_mask,
						  rel_type);
			;
			if rel_type == whole_subtree, will call itself on each bridge
			on this bus
			;
			pci_bridge_release_resources(bus, type); release the bridge res
				release_child_resources(r);
				release_resource(r);
				r->flags = 0; clean it means disable
				__pci_setup_bridge(bus, type);
					pci_setup_bridge_io(bus);
					pci_setup_bridge_mmio(bus);
					pci_setup_bridge_mmio_pref(bus);
					pci_write_config_word(bridge, PCI_BRIDGE_CONTROL, bus->bridge_ctl);
		list = list->next;
	}

	/* restore size and flags */
	for (list = head.next; list;) {
		struct resource *res = list->res;

		res->start = list->start;
		res->end = list->end;
		res->flags = list->flags;
		if (list->dev->subordinate)
			res->flags = 0;

		list = list->next;
	}
	free_list(resource_list_x, &head);

enable_and_dump:
	/* Depth last, update the hardware. */
	list_for_each_entry(bus, &pci_root_buses, node)
		pci_enable_bridges(bus);
			pci_enable_device(dev);
			pci_set_master(dev); bridge will be the master of this bus

	/* dump the resource on buses */
	list_for_each_entry(bus, &pci_root_buses, node)
		pci_bus_dump_resources(bus);
		{
		}

6. where those kernel parameters get processed
================================================================================
start_kernel();
	setup_arch(&command_line);
		strlcpy(command_line, boot_command_line, COMMAND_LINE_SIZE);
			parse_early_param();
				parse_early_options(tmp_cmdline);
					parse_args("early options", cmdline, NULL, 0, do_early_param); in kernel/params.c
						ret = parse_one(param, val, params, num, unknown);
							do_early_param("pci", "xxx");
								pci_setup();
									pcibios_setup();
										pci_probe |= PCI_ASSIGN_ALL_BUSSES;
									pci_realloc(); 
										pci_realloc_enable = 1;


	 
7. pcibios_allocate_resources()        
================================================================================
pcibios_allocate_resources()
	go throught all the devices under pci_bus_type
	for each pci_dev, go throught pci_dev.resource[]
		request_resource_confict()

8. relationship between acpi_pci_root_init(), pcibios_allocate_resources(), pci_assign_unassigned_resources()
================================================================================
These three functions will be called in the following sequence.
They are called at boot up to initialize the pci subsystem.
They are the major functions.

acpi_pci_root_init();                         scan the bridge, form the bus hierachy
pci_subsys_init()
	pcibios_resource_survey()
		pcibios_allocate_resources(); allocate the res on the parent bus
pci_assign_unassigned_resources();            reallocate those missed by BIOS

9. how pci driver find his pci_dev
================================================================================
static struct pci_driver enic_driver = {
	.name = DRV_NAME,
	.id_table = enic_id_table,
	.probe = enic_probe,
	.remove = __devexit_p(enic_remove),
};

pci_register_driver(&enic_driver)
	__pci_register_driver(drv, owner, mod_name)
		drv->driver.name = drv->name;
		drv->driver.bus = &pci_bus_type;
		drv->driver.owner = owner;
		drv->driver.mod_name = mod_name;

		driver_register(drv->driver)
			other = driver_find(driver->name, driver->bus); search the drivers_kset of bus
			bus_add_driver(drv);
				driver_attach(drv);
					bus_for_each_dev(drv->bus, NULL, drv, __driver_attach);
						walk through the bus->p->klist_devices and call __driver_attach
						__driver_attach(dev, drv);
							driver_match_device(drv, dev);
								pci_bus_match(dev, drv);
									match the id
							driver_probe_device(drv, dev);
								really_probe(dev, drv);
									dev->driver = drv;
									pci_device_probe(dev);
										__pci_device_probe(drv, pci_dev);
											...
											drv->probe(dev, id);
											enic_probe(dev, id);
												pci_enable_device_mem();
												pci_request_regions(); register those resource to tree.


		pci_create_newid_files(drv);
