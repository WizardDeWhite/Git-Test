1. main
================================================================================
virt-handler --port 8443 --hostname-override $(NODE_NAME) \
    --pod-ip-address $(MY_POD_IP) --max-metric-request 3 \
    --console-server-port 8186 -v verbosity

podsBaseDir = "/var/lib/kubelet/pods"

app = &virtHandlerApp{}
service.Setup(app)
app.Run()
    app.virtCli = kubecli.GetKubevirtClient()
    app.markNodeAsUnschedulable(logger)
    vmiSourceLabel
    vmiTargetLabel
    vmSourceSharedInformer = {vmiSourceLabel}
    vmTargetSharedInformer = {vmiTargetLabel}
    domainSharedInformer = virtcache.NewSharedInformer()
    os.MkdirAll("/var/run/kubevirt-private/network-info-cache")
    cmdclient.SetPodsBaseDir("/pods")
    cmdclient.SetLegacyBaseDir(app.VirtShareDir)
    containerdisk.SetKubeletPodsDirectory(app.KubeletPodsDir)

    app.namespace, err = clientutil.GetNamespace()
    factory = controller.NewKubeInformerFactory()
    vmiInformer = factory.VMI()
    app.clusterConfig = virtconfig.NewClusterConfig(factory.ConfigMap(), factory.CRD(), factory.KubeVirt(), app.namespace)
        defaultConfig = defaultClusterConfig()
            return v1.KubeVirtConfiguration{}
        c = ClusterConfig{}

1.1 vmController = virthandler.NewController()
================================================================================
    vmController = virthandler.NewController()
         recorder,
         app.virtCli,
         app.HostOverride,
         app.PodIpAddress,
         app.VirtShareDir,
         app.VirtPrivateDir,
         vmSourceSharedInformer,
         vmTargetSharedInformer,
         domainSharedInformer,
         gracefulShutdownInformer,
         int(app.WatchdogTimeoutDuration.Seconds()),
         app.MaxDevices,
         app.clusterConfig,
         app.serverTLSConfig,
         app.clientTLSConfig,
         podIsolationDetector,
    )
        c = VirtualMachineController{}
        vmiSourceInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
        	AddFunc:    c.addFunc,
        	DeleteFunc: c.deleteFunc,
        	UpdateFunc: c.updateFunc,
        })
        
        vmiTargetInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
        	AddFunc:    c.addFunc,
        	DeleteFunc: c.deleteFunc,
        	UpdateFunc: c.updateFunc,
        })
        
        domainInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
        	AddFunc:    c.addDomainFunc,
        	DeleteFunc: c.deleteDomainFunc,
        	UpdateFunc: c.updateDomainFunc,
        })
        
        gracefulShutdownInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
        	AddFunc:    c.addFunc,
        	DeleteFunc: c.deleteFunc,
        	UpdateFunc: c.updateFunc,
        })

1.2 vmController.Run(10, stop)
================================================================================
log.Log.Info("Starting virt-handler controller.")
go c.domainInformer.Run(stopCh)
go c.deviceManagerController.Run(stopCh)
go c.vmiSourceInformer.Run(stopCh)
go c.vmiTargetInformer.Run(stopCh)
c.runWorker() -> c.Execute()
    key = c.Queue.Get()

1.2.1 c.execute()
================================================================================
c.execute(key.(string))
    vmi, vmiExists, err := d.getVMIFromCache(key)
    domain, domainExists, domainCachedUID, err := d.getDomainFromCache(key)
    c.defaultExecute(key, vmi, vmiExists, domain, domainExists)
        c.processVmShutdown()
        c.processVmDelete()
        c.processVmCleanup()
        d.updateVMIStatus()

1.3 app.runServer(errCh, consoleHandler, lifecycleHandler)
================================================================================
ws := new(restful.WebService)
ws.Route(ws.GET("/v1/namespaces/{namespace}/virtualmachineinstances/{name}/console").To(consoleHandler.SerialHandler))
ws.Route(ws.GET("/v1/namespaces/{namespace}/virtualmachineinstances/{name}/vnc").To(consoleHandler.VNCHandler))
ws.Route(ws.PUT("/v1/namespaces/{namespace}/virtualmachineinstances/{name}/pause").To(lifecycleHandler.PauseHandler))
ws.Route(ws.PUT("/v1/namespaces/{namespace}/virtualmachineinstances/{name}/unpause").To(lifecycleHandler.UnpauseHandler))
ws.Route(ws.GET("/v1/namespaces/{namespace}/virtualmachineinstances/{name}/guestosinfo").To(lifecycleHandler.GetGuestInfo).Produces(restful.MIME_JSON).Consumes(restful.MIME_JSON).Returns(http.StatusOK, "OK", v1.VirtualMachineInstanceGuestAgentInfo{}))
ws.Route(ws.GET("/v1/namespaces/{namespace}/virtualmachineinstances/{name}/userlist").To(lifecycleHandler.GetUsers).Produces(restful.MIME_JSON).Consumes(restful.MIME_JSON).Returns(http.StatusOK, "OK", v1.VirtualMachineInstanceGuestOSUserList{}))
ws.Route(ws.GET("/v1/namespaces/{namespace}/virtualmachineinstances/{name}/filesystemlist").To(lifecycleHandler.GetFilesystems).Produces(restful.MIME_JSON).Consumes(restful.MIME_JSON).Returns(http.StatusOK, "OK", v1.VirtualMachineInstanceFileSystemList{}))
restful.DefaultContainer.Add(ws)
server := &http.Server{
	Addr:    fmt.Sprintf("%s:%d", app.ServiceListen.BindAddress, app.consoleServerPort),
	Handler: restful.DefaultContainer,
	// we use migration TLS also for console connections (initiated by virt-api)
	TLSConfig: app.serverTLSConfig,
}
errCh <- server.ListenAndServeTLS("", "")
