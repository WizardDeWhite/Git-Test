1. main
================================================================================
virt-handler --port 8443 --hostname-override $(NODE_NAME) \
    --pod-ip-address $(MY_POD_IP) --max-metric-request 3 \
    --console-server-port 8186 -v verbosity

podsBaseDir = "/var/lib/kubelet/pods"

app = &virtHandlerApp{}
service.Setup(app)
app.Run()
    app.virtCli = kubecli.GetKubevirtClient()
    app.markNodeAsUnschedulable(logger)
    vmiSourceLabel
    vmiTargetLabel
    vmSourceSharedInformer = {vmiSourceLabel}
    vmTargetSharedInformer = {vmiTargetLabel}
    domainSharedInformer = virtcache.NewSharedInformer()
        lw = newListWatchFromNotify(virtShareDir, watchdogTimeout, recorder,)
            d := &DomainWatcher{
            	backgroundWatcherStarted: false,
            	virtShareDir:             virtShareDir,
            	watchdogTimeout:          watchdogTimeout,
            	recorder:                 recorder,
            	vmiStore:                 vmiStore,
            	unresponsiveSockets:      make(map[string]int64),
            	resyncPeriod:             resyncPeriod,
            }
        informer = cache.NewSharedInformer(lw, &api.Domain{})
    os.MkdirAll("/var/run/kubevirt-private/network-info-cache")
    cmdclient.SetPodsBaseDir("/pods")
    cmdclient.SetLegacyBaseDir(app.VirtShareDir)
    containerdisk.SetKubeletPodsDirectory(app.KubeletPodsDir)

    app.namespace, err = clientutil.GetNamespace()
    factory = controller.NewKubeInformerFactory()
    vmiInformer = factory.VMI()
    app.clusterConfig = virtconfig.NewClusterConfig(factory.ConfigMap(), factory.CRD(), factory.KubeVirt(), app.namespace)
        defaultConfig = defaultClusterConfig()
            return v1.KubeVirtConfiguration{}
        c = ClusterConfig{}

1.1 vmController = virthandler.NewController()
================================================================================
    vmController = virthandler.NewController()
         recorder,
         app.virtCli,
         app.HostOverride,
         app.PodIpAddress,
         app.VirtShareDir,
         app.VirtPrivateDir,
         vmSourceSharedInformer,
         vmTargetSharedInformer,
         domainSharedInformer,
         gracefulShutdownInformer,
         int(app.WatchdogTimeoutDuration.Seconds()),
         app.MaxDevices,
         app.clusterConfig,
         app.serverTLSConfig,
         app.clientTLSConfig,
         podIsolationDetector,
    )
        c = VirtualMachineController{}
        vmiSourceInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
        	AddFunc:    c.addFunc,
        	DeleteFunc: c.deleteFunc,
        	UpdateFunc: c.updateFunc,
        })
        
        vmiTargetInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
        	AddFunc:    c.addFunc,
        	DeleteFunc: c.deleteFunc,
        	UpdateFunc: c.updateFunc,
        })
        
        domainInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
        	AddFunc:    c.addDomainFunc,
        	DeleteFunc: c.deleteDomainFunc,
        	UpdateFunc: c.updateDomainFunc,
        })
        
        gracefulShutdownInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
        	AddFunc:    c.addFunc,
        	DeleteFunc: c.deleteFunc,
        	UpdateFunc: c.updateFunc,
        })

1.2 vmController.Run(10, stop)
================================================================================
log.Log.Info("Starting virt-handler controller.")
go c.domainInformer.Run(stopCh)
go c.deviceManagerController.Run(stopCh)
go c.vmiSourceInformer.Run(stopCh)
go c.vmiTargetInformer.Run(stopCh)
c.runWorker() -> c.Execute()
    key = c.Queue.Get()

1.2.1 c.execute()
================================================================================
c.execute(key.(string))
    vmi, vmiExists, err := d.getVMIFromCache(key)
    domain, domainExists, domainCachedUID, err := d.getDomainFromCache(key)
    c.defaultExecute(key, vmi, vmiExists, domain, domainExists)
	// based on domain and vmi, do operate on vm
        c.processVmShutdown()
        c.processVmDelete()
        c.processVmCleanup()
        d.updateVMIStatus()

1.3 app.runServer(errCh, consoleHandler, lifecycleHandler), restful server invoked by virt-api
================================================================================
ws := new(restful.WebService)
ws.Route(ws.GET("/v1/namespaces/{namespace}/virtualmachineinstances/{name}/console").To(consoleHandler.SerialHandler))
ws.Route(ws.GET("/v1/namespaces/{namespace}/virtualmachineinstances/{name}/vnc").To(consoleHandler.VNCHandler))
ws.Route(ws.PUT("/v1/namespaces/{namespace}/virtualmachineinstances/{name}/pause").To(lifecycleHandler.PauseHandler))
ws.Route(ws.PUT("/v1/namespaces/{namespace}/virtualmachineinstances/{name}/unpause").To(lifecycleHandler.UnpauseHandler))
ws.Route(ws.GET("/v1/namespaces/{namespace}/virtualmachineinstances/{name}/guestosinfo").To(lifecycleHandler.GetGuestInfo).Produces(restful.MIME_JSON).Consumes(restful.MIME_JSON).Returns(http.StatusOK, "OK", v1.VirtualMachineInstanceGuestAgentInfo{}))
ws.Route(ws.GET("/v1/namespaces/{namespace}/virtualmachineinstances/{name}/userlist").To(lifecycleHandler.GetUsers).Produces(restful.MIME_JSON).Consumes(restful.MIME_JSON).Returns(http.StatusOK, "OK", v1.VirtualMachineInstanceGuestOSUserList{}))
ws.Route(ws.GET("/v1/namespaces/{namespace}/virtualmachineinstances/{name}/filesystemlist").To(lifecycleHandler.GetFilesystems).Produces(restful.MIME_JSON).Consumes(restful.MIME_JSON).Returns(http.StatusOK, "OK", v1.VirtualMachineInstanceFileSystemList{}))
restful.DefaultContainer.Add(ws)
server := &http.Server{
	Addr:    fmt.Sprintf("%s:%d", app.ServiceListen.BindAddress, app.consoleServerPort),
	Handler: restful.DefaultContainer,
	// we use migration TLS also for console connections (initiated by virt-api)
	TLSConfig: app.serverTLSConfig,
}
errCh <- server.ListenAndServeTLS("", "")

2. LifecycleHandler::PauseHandler(request, response)
================================================================================
vmi, code = getVMI(request, lh.vmiInformer)
sockFile = cmdclient.FindSocketOnHost(vmi)
client = cmdclient.NewClient(sockFile)
    conn, err := grpcutil.DialSocket(socketPath)
    return NewClientWithInfoClient(infoClient, conn)
client.PauseVirtualMachine(vmi)

3. domainInformer.Run(stopCh)
================================================================================
DomainWatcher::List()
    d.startBackground()
        // start a thread to handle stuff
        // start notifyserver
        notifyserver.RunServer()
            grpcServer = grpc.NewServer()
            notifyServer = Notify {}
            RegisterNotifyServer(grpcServer, notifyServer)
    domains = d.listAllKnownDomains()
    list = api.DomainList{}
    list.Items = appent(list.Items, *domain)
    return &list

4. Notify::HandleDomainEvent(), grpc called by virt-launcher
================================================================================
err := json.Unmarshal(request.DomainJSON, domain)
err := json.Unmarshal(request.StatusJSON, status)
n.EventChan <- watch.Event{Type: watch.Added, Object: domain}
n.EventChan <- watch.Event{Type: watch.Modified, Object: domain}
n.EventChan <- watch.Event{Type: watch.Deleted, Object: domain}

And this EventChan is handled in:
PS, this how callback works

domainInformer.Run() -> sharedIndexInformer::Run()
    s.controller.Run() -> controller::Run()
        r = NewReflector()
        r.Run() -> Reflector::Run()
            r.ListAndWatch()
                w = r.listerWatcher.Watch(options), this is DomainWatcher
                r.watchHandler(w watch.Interface)
                    w.ResultChan() -> DomainWatcher::ResultChan()
                        d.eventChan
