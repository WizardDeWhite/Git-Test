1. arch
================================================================================
virt-api --port 8443 --console-server-port 8168 --subresource-only -v verbosity

app = virt_api.NewVirtApi()
service.Setup(app)
app.Execute() -> virtAPIApp::Execute()
    app.ConfigureOpenAPIService()
        webservice at /swagger
    app.Run()
        app.readRequestHeader()
        app.prepareCertManager()
        app.registerMutatingWebhook()

        # retrieve Informers
        webhookInformers := webhooks.GetInformers()
        kubeInformerFactory := controller.NewKubeInformerFactory(
		app.virtCli.RestClient(),
		app.virtCli,
		app.aggregatorClient,
		app.namespace)
        configMapInformer := kubeInformerFactory.ConfigMap()
        crdInformer := kubeInformerFactory.CRD()
        authConfigMapInformer := kubeInformerFactory.ApiAuthConfigMap()
        kubevirtCAConfigInformer := kubeInformerFactory.KubeVirtCAConfigMap()
        kubeVirtInformer := kubeInformerFactory.KubeVirt()

        # run Informers
        go webhookInformers.VMIInformer.Run(stopChan)
        go webhookInformers.VMIPresetInformer.Run(stopChan)
        go webhookInformers.NamespaceLimitsInformer.Run(stopChan)
        go webhookInformers.VMRestoreInformer.Run(stopChan)
        go kubeVirtInformer.Run(stopChan)
        go configMapInformer.Run(stopChan)
        go crdInformer.Run(stopChan)
        go authConfigMapInformer.Run(stopChan)
        go kubevirtCAConfigInformer.Run(stopChan)

        cache.WaitForCacheSync()

        app.startTLS(kubeInformerFactory, stopChan)
            app.setupTLS()
            app.Compose()
                app.composeSubresources()
                    subws = new(restful.WebService)
                    subws.Path("/apis/%s/%s")

                    subresourceApp := rest.NewSubresourceAPIApp(app.virtCli, app.consoleServerPort, app.handlerTLSConfiguration, app.clusterConfig)
                        SubresourceAPIApp{
                            statusUpdater: status.NewVMStatusUpdater(virtCli)
                        }

                    "restart" -> subresourceApp.RestartVMRequestHandler
                    "start" -> subresourceApp.StartVMRequestHandler
                    "stop" -> subresourceApp.StopVMRequestHandler
                restful.Filter(filter.RequestLoggingFilter())
            server.ListenAndServeTLS()

3. List of webservice 
================================================================================
There are at least two categories of API, based on the target of object

  * vm
  * vmi

Generally, these two categories would be handled differently.

For vms:

    "restart"    subresourceApp.RestartVMRequestHandler
    "migrate"    subresourceApp.MigrateVMRequestHandler
    "start"      subresourceApp.StartVMRequestHandler
    "stop"       subresourceApp.StopVMRequestHandler
    "rename"     subresourceApp.RenameVMRequestHandler

For vms:

    "pause"      subresourceApp.PauseVMRequestHandler
    "unpause"    subresourceApp.UnpauseVMRequestHandler
    "console"    subresourceApp.ConsoleRequestHandler
    "vnc"        subresourceApp.VNCRequestHandler
    "guestinfo"  subresourceApp.GuestOSInfo
    "userlist"   subresourceApp.UserList
    "filesystemlist"     subresourceApp.FilesystemList

"healthz"    healthz.KubeConnectionHealthzFuncFactory(app.clusterConfig)

3.1 SubresourceAPIApp::RestartVMRequestHandler, by change VM State
================================================================================
vm = app.fetchVirtualMachine(name, namespace)
    vm, err := app.virtCli.VirtualMachine(namespace).Get(name, &k8smetav1.GetOptions{})
vmi = app.virtCli.VirtualMachineInstance(namespace).Get(name, &k8smetav1.GetOptions{})
bodyString = getChangeRequestJson(vm,
	v1.VirtualMachineStateChangeRequest{Action: v1.StopRequest, UID: &vmi.UID},
	v1.VirtualMachineStateChangeRequest{Action: v1.StartRequest})
    test = "{ "op": "test", "path": "/status/stateChangeRequests", "value": %s}"
    update = "{ "op": "add", "path": "/status/stateChangeRequests", "value": %s}"
    return "[%s, %s]", test, update
app.statusUpdater.PatchStatus(vm, types.JSONPatchType, []byte(bodyString))
    VMStatusUpdater::PatchStatus(vm, types.JSONPatchType, bytes)
        updater::patchWithSubresource(obj, pt, data)
            updater::patchStatusUnstructured(obj, patchType, data)
                updater.cli.VirtualMachine(a.GetNamespace()).PatchStatus(a.GetName(), patchType, data)

3.2 subresourceApp.PauseVMIRequestHandler
================================================================================
validate = 
getURL = 
app.putRequestHandler(request, response, validate, getURL)
    url, conn, statusErr = app.prepareConnection(request, validate, getURL)
        vmiName := request.PathParameter("name")
        namespace := request.PathParameter("namespace")
        vmi = app.fetchVirtualMachineInstance(vmiName, namespace)
        conn = app.getVirtHandlerConnForVMI(vmi)
            kubecli.NewVirtHandlerClient(app.virtCli).Port(app.consoleServerPort).ForNode(vmi.Status.NodeName)
                &virtHandler{
                    client:          client,
                    virtHandlerPort: 0,
                    namespace:       "",
                }.Port().ForNode(vmi.Status.NodeName)
                    conn = virtHandlerConn{}
                    pod = v.getVirtHandler(nodeName, ), one virt-handler per node
                    conn.pod = pod
                    conn.port = v.virtHandlerPort
                    return conn
        url = getURL(vmi, conn)
            conn.PauseURI(vmi) -> virtHandlerConn::PauseURI()
            fmt.Sprintf(pauseTemplateURI, formatIpForUri(ip), port, vmi.ObjectMeta.Namespace, vmi.ObjectMeta.Name), nil
            "https://%s:%v/v1/namespaces/%s/virtualmachineinstances/%s/pause"
    conn.Put(url, app.handlerTLSConfiguration) -> virtHandlerConn::Put()
        client = http.Client{}
        req = http.NewRequest(http.MethodPut, url)
        client.Do(req)
