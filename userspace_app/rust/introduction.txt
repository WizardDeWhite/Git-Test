1. Reference
================================================================================

The Rust Programming Language
https://doc.rust-lang.org/book/title-page.html

The Cargo Book
https://doc.rust-lang.org/cargo/index.html

Rust by Example
https://doc.rust-lang.org/rust-by-example/macros.html

Rust book
https://kaisery.gitbooks.io/rust-book-chinese/content/

1.1 Install & Setup environment
================================================================================

1.1.1 Install Rust

curl https://sh.rustup.rs -sSf | sh

Add ~/.cargo/bin into your $PATH.

1.1.2 Setup

Change rust source for fast access in Shanghai.

cat ~/.cargo/env
export RUSTUP_DIST_SERVER="https://mirrors.ustc.edu.cn/rust-static"
export RUSTUP_UPDATE_ROOT="https://mirrors.ustc.edu.cn/rust-static/rustup"

cat ~/.cargo/config
[source.crates-io]
registry = "https://github.com/rust-lang/crates.io-index"
replace-with = 'ustc'
[source.ustc]
registry = "git://mirrors.ustc.edu.cn/crates.io-index"

2. Build & run
================================================================================

There are two ways to build and run rust

  * traditional compile and run with rustc
  * use cargo

2.1 compile with rustc
================================================================================

For example, we have a source file hello.rs

```
fn main() {
    println!("Hello, world!");
}
```

We can compile and run like below:

# rustc hello.rs
# ./hello

2.2 use cargo
================================================================================

Cargo is Rust¡¯s build system and package manager.

2.2.1 create a project
================================================================================

The simplest way to create a project by cargo is:

# cargo new hello_cargo

A folder hello_cargo would be created with following files:

©À©¤©¤ Cargo.toml
©¸©¤©¤ src
    ©À©¤©¤ bin
    ©¸©¤©¤ main.rs

Then you can write your own code in main.rs or put your source code, e.g.
hello_world.rs into src directory.

2.2.2 build and running
================================================================================

Instead of using rustc, we can build the project with

# cargo build

This will build and put binary into target/debug/hello_cargo.

If you want to build a release version, use

# cargo build --release


3. Syntax
================================================================================

3.1 variable definition
================================================================================

let var = value;             // immutable
let mut var = value;         // mutable

let var: u32 = value;        // specify the type

let (x, y) = (1, 2);         // define x,y by pattern 
let (_x: i32, _y) = (1, 2);  // not work


3.2 function definition
================================================================================

```
fn foo() {
}

fn foo(x: i32) {
}

fn foo(x: i32) -> i32 {
	x                     // DO NOT append ';' at last
}
```

// function pointer
```
fn plus_one(i: i32) -> i32 {
	i + 1
}
let f = plus_one;
let res = f(5);
```

3.3 built-in type
================================================================================

let y: bool = false;
let x: char = 'x';
let a: i32  = 8;

3.3.1 array
================================================================================

let a = [1, 2, 3];
println!("a has {} elements", a.len());
println!("the second is {}", a[1]);

3.3.2 slice
================================================================================

Slice doesn't have ownership. (So it must be a reference?)

let a = [1, 2, 3, 4];
let complete = &a[..];
let middle = &a[1..4];

3.3.3 tuple
================================================================================

let x: (i32, &str) = (1, "hello")
println!("x value is {}", x.0);

3.3.4 vector
================================================================================

// different from array, vector is dynamic
let v = vec![1, 2, 3, 4 , 5];

// access an element
println!("The third element of v is {}", v[2]);

// access out range element
let v = vec![1, 2, 3];
match v.get(7) {
    Some(x) => println!("Item 7 is {}", x),
    None => println!("Sorry, this vector is too short.")
}

// iterate on vector
for i in &v {
    println!("This is a reference to {}", i);
}

3.3.5 enum
================================================================================

enum IpAddrKind {
    V4,
    V6,
}

enum IpAddr2 {
    V4(String),
    V6(String),
}

enum GenericEnum<T> {
    First(T),
    Second(T),
}

3.3.6 struct
================================================================================


struct Rectangle {
    width: u32,
    height: u32,
}

// define associated functions, no self is required
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle {width: size, height: size}
    }
}


3.4 if
================================================================================

let x = 5;

if x == 5 {
    println!("x is five!");
} else if x == 6 {
    println!("x is six!");
} else {
    println!("x is not five or six :(");
}

let x = 5;

let y = if x == 5 {
    10
} else {
    15
}; // y: i32

3.5 loop
================================================================================

loop {
    println!("Loop forever!");
}

let mut x = 5; // mut x: i32
let mut done = false; // mut done: bool

// while loop
while !done {
    x += x - 3;

    println!("{}", x);

    if x % 5 == 0 {
        done = true;
    }
}

// for loop
for x in 0..10 {
    println!("{}", x); // x: i32
}

for var in expression {
    code
}

// on range
for (index, value) in (5..10).enumerate() {
    println!("index = {} and value = {}", index, value);
}

// on iterators
let lines = "hello\nworld".lines();

for (linenumber, line) in lines.enumerate() {
    println!("{}: {}", linenumber, line);
}

// loop labels
'outer: for x in 0..10 {
    'inner: for y in 0..10 {
        if x % 2 == 0 { continue 'outer; } // Continues the loop over `x`.
        if y % 2 == 0 { continue 'inner; } // Continues the loop over `y`.
        println!("x: {}, y: {}", x, y);
    }
}

3.6 Generic Types
================================================================================

3.6.1 Function
================================================================================

fn function<T>(param: T) -> T {}

fn function<T: Trait>(param: T) -> T {}

fn function<T>(param: T) -> T 
    where T: Trait
{}

3.6.2 Struct
================================================================================

struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T { &self.x }
}

// tuple struct, a more verbose way to use tuple
struct Color(i32, i32, i32);

3.7 trait
================================================================================

3.7.1 define trait
================================================================================

pub trait Summary {
    fn summary(&self) -> String;
}

3.7.2 impl trait
================================================================================

impl Summary for NewsArticle {
    fn summary(&self) -> String {
        format!("{}", self.name)
    }
}

3.7.3 trait parameter
================================================================================

fn notify(item: impl Summary) {
    item.summary();
}

This is the same as:

fn notify<T: Summary>(item: T) {
    item.summary();
}

3.7.4 conditional method by trait
================================================================================

pub trait Display {
    fn show(&self) -> String;
}

impl<T: Summary> Display for T {
    fn show(&self) -> String {
        format!("{}", self.summary())
    }
}

3.8 Macros
================================================================================
https://doc.rust-lang.org/book/ch19-06-macros.html

A little book of Rust Macros

https://danielkeep.github.io/tlborm/book/index.html


Macro Example
https://doc.rust-lang.org/rust-by-example/macros/syntax.html

  * Declarative macros with macro_rules!
  * Procedural macros
    - custom #[derive] macros
    - attribute-like macros
    - function-like macros

3.8.0 expand macros
================================================================================

For better understanding macro from others, you can use

  cargo expand [--bin name]

Before doing this you need to install two things:

  rustup install nightly
  cargo install cargo-expand

3.8.1 Declarative macros
================================================================================

#[macro_export]
macro_rules! my_vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}

3.8.2 custom #[derive] macros
================================================================================

3.9 Conditional Compilation
================================================================================

https://doc.rust-lang.org/reference/conditional-compilation.html

4. Ownership
================================================================================

4.1 Ownership
================================================================================

Rules:

  * Each value in Rust has a variable that's called its owner.
  * There can only be one owner at a time.
  * When the owner goes out of scope, the value will be dropped.

For variables allocated on heap, Rust will return the memory automatically
when the owner goes out of scope. The secret function to do this is -- drop().

4.1.1 Ownership Movement
================================================================================
You can't access a variable after it is assigned to other.
This is called a movement of ownership.

https://kaisery.gitbooks.io/rust-book-chinese/content/content/Ownership%20ËùÓÐÈ¨.html

```
fn take(v: Vec<i32>) {
    // What happens here isn¡¯t important.
}

let v = vec![1, 2, 3];

take(v);

println!("v[0] is: {}", v[0]); // error: use of moved value: `v`
```

4.1.2 Copy
================================================================================
The exception is if the type implement Copy trait.
Actually, more memory is used.

```
fn main() {
    let a = 5;

    let _y = double(a);
    println!("{}", a);
}

fn double(x: i32) -> i32 {
    x * 2
}
```

4.1.3 Return Ownership
================================================================================

```
fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {
    // Do stuff with `v1` and `v2`.

    // Hand back ownership, and the result of our function.
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
```

4.2 Borrow & Reference
================================================================================
https://zhuanlan.zhihu.com/p/59998584

Use reference to borrow the ownership

```
fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {
    // Do stuff with `v1` and `v2`.

    //  Return the answer.
    42
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let answer = foo(&v1, &v2);
```

4.2.1 mutable reference
================================================================================

```
let mut x = 5;
{
    let y = &mut x;
    *y += 1;
}
println!("{}", x);
```

4.3 Lifetime
================================================================================
Refer to : https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html

Every reference in Rust has a lifetime, which is the scope for which that
reference is valid.

4.3.1 Definition
================================================================================

&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {}

struct ImportantExcerpt<'a> {
    part: &'a str,
}

4.3.1 prevent dangling reference
================================================================================

5. Error
================================================================================

5.1 unrecoverable error with panic
================================================================================

fn main() {
    panic!("crash and burn");
}

RUST_BACKTRACE=1 cargo run

5.2 recoverable error with Result
================================================================================

Use match to handle the return value Result.

    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => panic!("Problem opening the file: {:?}", other_error),
        },
    };

5.2.1 unwrap()
================================================================================

If the Result value is the Ok variant, unwrap will return the value inside the Ok.
If the Result is the Err variant, unwrap will call the panic! macro for us. 

    let f = File::open("hello.txt").unwrap();

5.2.2 expect()
================================================================================

The same as unwrap(), except move verbose panic! message.

    let f = File::open("hello.txt").expect("Failed to open hello.txt");

5.2.3 propagate error with ?
================================================================================

If the value of the Result is an Ok, the value inside the Ok will get returned
from this expression, and the program will continue.

If the value is an Err, the Err will be returned from the whole function as if
we had used the return keyword so the error value gets propagated to the
calling code.

Following two functions are the same.

fn read_username_from_file() -> Result<String, io::Error> {
    let f = File::open("hello.txt");

    let mut f = match f {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
    }
}

// shorten with ?
fn read_username_from_file2() -> Result<String, io::Error> {
    let mut s = String::new();

    File::open("hello.txt")?.read_to_string(&mut s)?;

    Ok(s)
}

6. Closure
================================================================================

Compared with function:

fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;

Environment variable ownership

FnOnce consumes the variables it captures from its enclosing scope, known as
the closure¡¯s environment. To consume the captured variables, the closure
must take ownership of these variables and move them into the closure when it
is defined. The Once part of the name represents the fact that the closure
can¡¯t take ownership of the same variables more than once, so it can be
called only once.

FnMut can change the environment because it mutably borrows values.

Fn borrows values from the environment immutably.


7. Iterator
================================================================================

https://www.twle.cn/c/yufei/rust/rust-basic-iterator.html

5. Project Management
================================================================================

5.1 Packages & Crates
================================================================================

A crate is a binary or library. The crate root is a source file that the Rust
compiler starts from and makes up the root module of your crate.

A package is one or more crates that provide a set of functionality. A package
contains a Cargo.toml file that describes how to build those crates.

5.2 Modules
================================================================================

Modules let us organize code within a crate into groups for readability and
easy reuse

5.3 Workspace
================================================================================


5.4 Dependency
================================================================================
Reference https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html

[dependencies]
name = "version"

5.4.1 specify the version
================================================================================
^1.2.3  :=  >=1.2.3, <2.0.0
^1.2    :=  >=1.2.0, <2.0.0
^1      :=  >=1.0.0, <2.0.0
^0.2.3  :=  >=0.2.3, <0.3.0
^0.2    :=  >=0.2.0, <0.3.0
^0.0.3  :=  >=0.0.3, <0.0.4
^0.0    :=  >=0.0.0, <0.1.0
^0      :=  >=0.0.0, <1.0.0

~1.2.3  := >=1.2.3, <1.3.0
~1.2    := >=1.2.0, <1.3.0
~1      := >=1.0.0, <2.0.0

*     := >=0.0.0
1.*   := >=1.0.0, <2.0.0
1.2.* := >=1.2.0, <1.3.0

5.4.2 specify the registry
================================================================================

[dependencies]
some-crate = { version = "1.0", registry = "my-registry" }

5.4.3 dependency from git
================================================================================

[dependencies]
rand = { git = "https://github.com/rust-lang-nursery/rand" }

[dependencies]
rand = { git = "https://github.com/rust-lang-nursery/rand", branch = "next" }

Note:

To access a private git repo, you may need to configure git authentication.
https://doc.rust-lang.org/cargo/appendix/git-authentication.html

5.4.4 local dependency
================================================================================

[dependencies]
hello_utils = { path = "hello_utils" }

[dependencies]
hello_utils = { path = "hello_utils", version = "0.1.0" }

5.4.4 platform specific dependency
================================================================================

[target.'cfg(windows)'.dependencies]
winhttp = "0.4.0"

[target.'cfg(unix)'.dependencies]
openssl = "1.0.1"

[target.'cfg(target_arch = "x86")'.dependencies]
native = { path = "native/i686" }

[target.'cfg(target_arch = "x86_64")'.dependencies]
native = { path = "native/x86_64" }

5.4.5 feature specific dependency
================================================================================

[dependencies]
foo = { version = "1.0", optional = true }
bar = { version = "1.0", optional = true }

[features]
fancy-feature = ["foo", "bar"]

5.4.6 development dependency
================================================================================

[dev-dependencies]
tempdir = "0.3"

[target.'cfg(unix)'.dev-dependencies]
mio = "0.0.1"

5.4.7 choose feature
================================================================================

[dependencies.awesome]
version = "1.3.5"
default-features = false # do not include the default features, and optionally
                         # cherry-pick individual features
features = ["secure-password", "civet"]

5.5 feature
================================================================================
Reference: https://doc.rust-lang.org/cargo/reference/features.html

5.5.1 definition
================================================================================

Define two features: tastes, cook. The first one is the default feature, and
the second one it optional.

[features]

default = ["tastes"]

tastes = []
cook = []

5.5.2 usage
================================================================================

A crate depends on the restaurant, and also depends on the optional feature:
cook.

[dependencies.restaurant]
path = "../restaurant"
features = ["cook"]

5.5.3 conditional compilation
================================================================================

When we need to build an optional feature, we can specify the feature in
command line:

cargo build --features "feature_name"

5.6 registry
================================================================================
https://doc.rust-lang.org/cargo/reference/registries.html

Add a registry in .cargo/config

[registries]
my-registry = { index = "https://my-intranet:8080/git/index" }

Use is in Cargo.toml

# Sample Cargo.toml
[package]
name = "my-project"
version = "0.1.0"

[dependencies]
other-crate = { version = "1.0", registry = "my-registry" }

