1. Reference
================================================================================

The Rust Programming Language
https://doc.rust-lang.org/book/title-page.html

The Cargo Book
https://doc.rust-lang.org/cargo/index.html

Rust by Example
https://doc.rust-lang.org/rust-by-example/macros.html

Rust book
https://kaisery.gitbooks.io/rust-book-chinese/content/

1.1 Install & Configuration
================================================================================

1.1.1 Install Rust
================================================================================

curl https://sh.rustup.rs -sSf | sh

Add ~/.cargo/bin into your $PATH.

1.1.2 Setup Environment
================================================================================

Change rust source for fast access in Shanghai.

cat ~/.cargo/env
export RUSTUP_DIST_SERVER="https://mirrors.ustc.edu.cn/rust-static"
export RUSTUP_UPDATE_ROOT="https://mirrors.ustc.edu.cn/rust-static/rustup"

cat ~/.cargo/config
[source.crates-io]
registry = "https://github.com/rust-lang/crates.io-index"
replace-with = 'ustc'
[source.ustc]
registry = "git://mirrors.ustc.edu.cn/crates.io-index"

1.1.3 Setup IDE
================================================================================

There are several IDE for rust, the one I choose is vim + coc-rust-analyzer.

Refer https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/user/manual.adoc#vimneovim
for more detail.

There are two things to install:

  * coc and its extension coc-rust-analyzer
  * vim-lsp

2. Build & run
================================================================================

There are two ways to build and run rust

  * traditional compile and run with rustc
  * use cargo

2.1 compile with rustc
================================================================================

For example, we have a source file hello.rs

```
fn main() {
    println!("Hello, world!");
}
```

We can compile and run like below:

# rustc hello.rs
# ./hello

2.2 use cargo
================================================================================

Cargo is Rust¡¯s build system and package manager.

2.2.1 create a project
================================================================================

The simplest way to create a project by cargo is:

# cargo new hello_cargo

A folder hello_cargo would be created with following files:

©À©¤©¤ Cargo.toml
©¸©¤©¤ src
    ©À©¤©¤ bin
    ©¸©¤©¤ main.rs

Then you can write your own code in main.rs or put your source code, e.g.
hello_world.rs into src directory.

2.2.2 build and running
================================================================================

Instead of using rustc, we can build the project with

# cargo build

This will build and put binary into target/debug/hello_cargo.

If you want to build a release version, use

# cargo build --release


3. Syntax
================================================================================

3.1 variable definition
================================================================================

let var = value;             // immutable
let mut var = value;         // mutable

let var: u32 = value;        // define with type annotation

let (x, y) = (1, 2);         // define x,y by pattern 
let (_x: i32, _y) = (1, 2);  // not work


3.2 function definition
================================================================================

```
fn foo() {
}

fn foo(x: i32) {
}

// statement vs expression
// https://doc.rust-lang.org/book/ch03-03-how-functions-work.html#function-bodies-contain-statements-and-expressions
fn foo(x: i32) -> i32 {
	x                     // DO NOT append ';' at last
}
```

// function pointer
```
fn plus_one(i: i32) -> i32 {
	i + 1
}
let f = plus_one;
let res = f(5);
```

3.3 built-in type
================================================================================

3.3.1 scalar types
================================================================================

// integer
let a: u32 = 10_000u32;
let a: i32 = 8;
let b = 10_000u32;

// float
let a = 2.0;
let b: f32 = 3.0;

// boolean
let y: bool = false;

// character
let x: char = 'x';

3.3.2 array
================================================================================

// must have same the type
// and it is fixed length
let a = [1, 2, 3];
// type annotation of array
let b: [i32; 5] = [1, 2, 3, 4, 5];
// an array with 5 same value: 3
let c: [i32; 5] = [3; 5];

// access element in array
println!("a has {} elements", a.len());
println!("the second is {}", a[1]);

3.3.3 tuple
================================================================================

// could have different types
let y              = (1, "hello")
let x: (i32, &str) = (1, "hello")
println!("x value is {}", x.0);

// destruct
let (num, _) = x;
println!("get number {}", num);

3.3.4 slice
================================================================================

Slice doesn't have ownership, it let you reference a contiguous sequence of
elements in a collection rather than the whole collection. So it must be a
reference.

let a = [1, 2, 3, 4];
let complete = &a[..];
let middle = &a[1..4];

Also with the combination of reference, slice is useful to solve some run time
error. See the detail example: https://doc.rust-lang.org/book/ch04-03-slices.html

3.3.5 vector
================================================================================

// different from array, vector is dynamic
let v = vec![1, 2, 3, 4 , 5];

// access an element
println!("The third element of v is {}", v[2]);

// access out range element
let v = vec![1, 2, 3];
match v.get(7) {
    Some(x) => println!("Item 7 is {}", x),
    None => println!("Sorry, this vector is too short.")
}

// iterate on vector
for i in &v {
    println!("This is a reference to {}", i);
}

3.3.6 enum
================================================================================

enum IpAddrKind {
    V4,
    V6,
}

enum IpAddr2 {
    V4(String),
    V6(String),
}

enum GenericEnum<T> {
    First(T),
    Second(T),
}

3.3.7 struct
================================================================================


struct Rectangle {
    width: u32,
    height: u32,
}

// define associated functions, no self is required
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle {width: size, height: size}
    }
}

3.4 Control Flow
================================================================================

3.4.1 if
================================================================================

let x = 5;

if x == 5 {
    println!("x is five!");
} else if x == 6 {
    println!("x is six!");
} else {
    println!("x is not five or six :(");
}

let x = 5;

let y = if x == 5 {
    10
} else {
    15
}; // y: i32

3.4.2 loop
================================================================================

// infinite loop
loop {
    println!("Loop forever!");
}

let mut x = 5; // mut x: i32
let mut done = false; // mut done: bool

// while loop
while !done {
    x += x - 3;

    println!("{}", x);

    if x % 5 == 0 {
        done = true;
    }
}

// for loop
for x in 0..10 {
    println!("{}", x); // x: i32
}

for var in expression {
    code
}

// on range
for (index, value) in (5..10).enumerate() {
    println!("index = {} and value = {}", index, value);
}

// on iterators
let lines = "hello\nworld".lines();

for (linenumber, line) in lines.enumerate() {
    println!("{}: {}", linenumber, line);
}

// loop labels
'outer: for x in 0..10 {
    'inner: for y in 0..10 {
        if x % 2 == 0 { continue 'outer; } // Continues the loop over `x`.
        if y % 2 == 0 { continue 'inner; } // Continues the loop over `y`.
        println!("x: {}, y: {}", x, y);
    }
}

3.4.3 Pattern Match
================================================================================

https://doc.rust-lang.org/book/ch06-02-match.html

// value match
```
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

```

// value extract
```
enum IpAddr2 {
    V4(String),
    V6(String),
}

let home = IpAddr2::V4(String::from("127.0.0.1"));

let addr = match home {
    IpAddr2::V4(val) => val,
    IpAddr2::V6(val) => val,
};
println!("\tthe text is {}", addr);
```

// if let just match one case and ignore the rest
```
fn main() {
    let some_u8_value = Some(0u8);
    match some_u8_value {
        Some(3) => println!("three"),
        _ => (),
    }
}
```

equals

```
fn main() {
    let some_u8_value = Some(0u8);
    if let Some(3) = some_u8_value {
        println!("three");
    }
}
```

3.5 Generic Types
================================================================================

3.5.1 Function
================================================================================

fn function<T>(param: T) -> T {}

fn function<T: Trait>(param: T) -> T {}

fn function<T>(param: T) -> T 
    where T: Trait
{}

3.5.2 Struct
================================================================================

struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T { &self.x }
}

// tuple struct, a more verbose way to use tuple
struct Color(i32, i32, i32);

3.6 trait
================================================================================

3.6.1 define trait
================================================================================

pub trait Summary {
    fn summary(&self) -> String;
}

3.6.2 impl trait
================================================================================

impl Summary for NewsArticle {
    fn summary(&self) -> String {
        format!("{}", self.name)
    }
}

3.6.3 trait parameter
================================================================================

fn notify(item: impl Summary) {
    item.summary();
}

This is the same as:

fn notify<T: Summary>(item: T) {
    item.summary();
}

3.6.4 conditional method by trait
================================================================================

pub trait Display {
    fn show(&self) -> String;
}

impl<T: Summary> Display for T {
    fn show(&self) -> String {
        format!("{}", self.summary())
    }
}

3.7 Macros
================================================================================
https://doc.rust-lang.org/book/ch19-06-macros.html

A little book of Rust Macros

https://danielkeep.github.io/tlborm/book/index.html


Macro Example
https://doc.rust-lang.org/rust-by-example/macros/syntax.html

  * Declarative macros with macro_rules!
  * Procedural macros
    - custom #[derive] macros
    - attribute-like macros
    - function-like macros

3.7.0 expand macros
================================================================================

For better understanding macro from others, you can use

  cargo expand [--bin name]

Before doing this you need to install two things:

  rustup install nightly
  cargo install cargo-expand

3.7.1 Declarative macros
================================================================================

#[macro_export]
macro_rules! my_vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}

3.7.2 custom #[derive] macros
================================================================================

3.8 Conditional Compilation
================================================================================

https://doc.rust-lang.org/reference/conditional-compilation.html

4. Ownership
================================================================================

Rust¡¯s central feature is ownership.

Three ways to control memory at run time for a program language:

  * garbage collection
  * explicitly allocate and free
  * through a system of ownership with a set of rules that the compiler checks
    at compile time

Rust takes the third one.

4.1 Ownership
================================================================================

Rules:

  * Each value in Rust has a variable that's called its owner.
  * There can only be one owner at a time.
  * When the owner goes out of scope, the value will be dropped.

For variables, they could be allocated on two locations:

  * stack
  * heap

For variables allocated on stack, usually we don't need to do more than move
the stack pointer to get back those memory.

For variables allocated on heap, Rust will return the memory automatically
when the owner goes out of scope. The secret function to do this is -- drop().

Based on this, we face a challenge for variables on heap at variable
assignment. Because, if we call drop() for each variables on heap, double free
happens. This is the reason for rust to solve the problem by ownership.

> After assignment, the new one is valid and the old one is invalid.

4.1.1 Ownership Movement
================================================================================
You can't access a variable after it is assigned to other.
This is called a movement of ownership.

https://kaisery.gitbooks.io/rust-book-chinese/content/content/Ownership%20ËùÓÐÈ¨.html

```
fn take_ownership(v: Vec<i32>) {
    // What happens here isn¡¯t important
}

let v = vec![1, 2, 3];

take_ownership(v);

println!("v[0] is: {}", v[0]); // error: use of moved value: `v`
```

Reason:

If we don't grab the ownership in "take_ownership", variable v would be freed
twice. So rust think v is no longer available after "take_ownership".

Rust calls this ownership is moved, which is basically introduced to solve
double free for variables on the heap.

4.1.2 Copy
================================================================================
The exception is if the type implement Copy trait. Actually, more memory is
used. And I think those variables must be put on stack.

Note: a type implement Drop() trait can't inherit Copy() trait.

```
fn main() {
    let a = 5;

    let _y = double(a);
    println!("{}", a);
}

fn double(x: i32) -> i32 {
    x * 2
}
```

Or for a complex structure, clone() is used.

```
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
}
```

4.1.3 Return Ownership
================================================================================

```
fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {
    // Do stuff with `v1` and `v2`.

    // Hand back ownership, and the result of our function.
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
```

4.2 Ownership Borrow & Reference
================================================================================
https://zhuanlan.zhihu.com/p/59998584

Use reference to borrow the ownership, which means the function never own the
variable and won't call drop when variable goes out of scope. That's why we
call it borrow.

```
fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {
    // Do stuff with `v1` and `v2`.

    //  Return the answer.
    42
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let answer = foo(&v1, &v2);
```

4.2.1 mutable reference
================================================================================

```
let mut x = 5;
{
    let y = &mut x;
    *y += 1;
}
println!("{}", x);
```

4.2.1.1 Restriction
================================================================================

There is restriction on (mutable) reference, which is actually a powerful tool
to prevent data race at compile time.

  * you can have only one mutable reference to a particular piece of data in a
    particular scope.
  * no mixture of mutable and immutable reference

Here is some examples:

Restriction 1:

```
fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;  // cannot borrow `s` as mutable more than once at a time

    println!("{}, {}", r1, r2);
}
```

Restriction 2:
```
fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    let r3 = &mut s; // cannot borrow `s` as mutable because it is also
                     // borrowed as immutable

    println!("{}, {}, and {}", r1, r2, r3);
}
```

4.2.2 Dangling reference
================================================================================

An example of dangling reference.

```
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```

The reason:

    Because s is created inside dangle, when the code of dangle is finished, s
    will be deallocated. But we tried to return a reference to it. That means
    this reference would be pointing to an invalid String.

4.3 Lifetime of Reference
================================================================================
Refer to : https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html

Every **reference** in Rust has a lifetime, which is the scope for which that
reference is valid.

Most of the time, lifetimes are implicit and inferred, just like most of the
time, types are inferred.

We must annotate lifetimes when the lifetimes of references could be related
in a few different ways.

4.3.1 How it works -- Borrow Check
================================================================================

One of the strength of lifetime is to prevent dangling reference.

Following is an example:

```
    {
        let r;

        {
            let x = 5;
            r = &x;
        }

        println!("r: {}", r);
    }
```

The Rust compiler has a **borrow checker** that compares scopes to determine
whether all borrows are valid.

```
    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &x;           //  |       |
        }                     // -+       |
                              //          |
        println!("r: {}", r); //          |
    }                         // ---------+
```

4.3.2 Annotation Syntax
================================================================================

One lifetime annotation by itself doesn¡¯t have much meaning, because the
annotations are meant to tell Rust how generic lifetime parameters of multiple
references relate to each other.

While first, we need to know how Rust defines it.

4.3.2.1 Lifetime annotation
================================================================================

&i32        // a reference with inferred lifetime
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime


4.3.2.2 Lifetime annotation for function
================================================================================

```
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

The function signature tells Rust that:

  * for some lifetime 'a, the function takes two parameters that live at least
    as long as lifetime 'a
  * return value will live at least as long as lifetime 'a

These two help the borrow checker should reject any values that don't adhere
to these constrains.

When annotating lifetimes in functions, the annotations go in the function
signature, not in the function body. Rust can analyze the code within the
function without any help.

How 'a is replaced with concrete lifetime:

  When we pass concrete references to longest, the concrete lifetime that is
  substituted for 'a is the part of the scope of x that overlaps with the
  scope of y. In other words, the generic lifetime 'a will get the concrete
  lifetime that is equal to the **smaller** of the lifetimes of x and y.
  Because we¡¯ve annotated the returned reference with the same lifetime
  parameter 'a, the returned reference will also be valid for the length of
  the smaller of the lifetimes of x and y.

4.3.2.3 Lifetime Annotations in Struct Definitions
================================================================================

It¡¯s possible for structs to hold references, but in that case we would need
to add a lifetime annotation on every reference in the struct¡¯s definition.

```
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```

This annotation means an instance of ImportantExcerpt can¡¯t outlive the
reference it holds in its "part" field.


4.3.2.4 Lifetime Annotations in Method Definitions
================================================================================

```
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }

    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
```

After applying elision rule, the definition looks like:

```
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&'a self) -> i32 {
        3
    }

    fn announce_and_return_part(&'a self, announcement: &'b str) -> &'a str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
```

4.3.3 Lifetime Elision
================================================================================

The compiler uses three rules to figure out what lifetimes references have
when there aren¡¯t explicit annotations.

  * The first rule is that each parameter that is a reference gets its own
    lifetime parameter. 
  * The second rule is if there is exactly one input lifetime parameter, that
    lifetime is assigned to all output lifetime parameters.
  * The third rule is if there are multiple input lifetime parameters, but one
    of them is &self or &mut self because this is a method, the lifetime of
    self is assigned to all output lifetime parameters.

Example 1:

  Original code:  fn first_word(s: &str) -> &str {
  Rule 1:         fn first_word(s: &'a str) -> &str {
  Rule 2:         fn first_word(s: &'a str) -> &'a str {

  After applying Rule 1/2, all references in this function signature have
  lifetime.

Example 2:

  Original code:  fn longest(x: &str, y: &str) -> &str {
  Rule 1:         fn longest(x: &'a str, y: &'b str) -> &str {
  Rule 2 can't apply.

  There still is un-certain lifetime in this function signature, so we have to
  specify it or we would have compile error.

5. Error
================================================================================

5.1 unrecoverable error with panic
================================================================================

fn main() {
    panic!("crash and burn");
}

RUST_BACKTRACE=1 cargo run

5.2 recoverable error with Result
================================================================================

Use match to handle the return value Result.

    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => panic!("Problem opening the file: {:?}", other_error),
        },
    };

5.2.1 unwrap()
================================================================================

If the Result value is the Ok variant, unwrap will return the value inside the Ok.
If the Result is the Err variant, unwrap will call the panic! macro for us. 

    let f = File::open("hello.txt").unwrap();

5.2.2 expect()
================================================================================

The same as unwrap(), except more verbose panic! message.

    let f = File::open("hello.txt").expect("Failed to open hello.txt");

5.2.3 propagate error with ?
================================================================================

If the value of the Result is an Ok, the value inside the Ok will get returned
from this expression, and the program will continue.

If the value is an Err, the Err will be returned from the whole function as if
we had used the return keyword so the error value gets propagated to the
calling code.

Following two functions are the same.

fn read_username_from_file() -> Result<String, io::Error> {
    let f = File::open("hello.txt");

    let mut f = match f {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
    }
}

// shorten with ?
fn read_username_from_file2() -> Result<String, io::Error> {
    let mut s = String::new();

    File::open("hello.txt")?.read_to_string(&mut s)?;

    Ok(s)
}

6. Functional Language Feature
================================================================================
https://doc.rust-lang.org/book/ch13-00-functional-features.html

6.1 Closura(lambda)
================================================================================

6.1.1 Difference from function
================================================================================
Compared with function:

fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;

    1. type annotations for parameter and return value is optional
    2. if closure body is a single expression, curly brackets is optional

6.1.2 Closure's Type and Environment Capture
================================================================================

Unlike functions, closures can capture their environment from the scope in
which they¡¯re defined. 

All closures implement at least one of the traits: Fn, FnMut, or FnOnce, and
each type specify environment variable ownership:

  * FnOnce: take ownership
    consumes the variables it captures from its enclosing scope, known as
    the closure¡¯s environment. To consume the captured variables, the closure
    must take ownership of these variables and move them into the closure when it
    is defined. The Once part of the name represents the fact that the closure
    can¡¯t take ownership of the same variables more than once, so it can be
    called only once.
    
  * FnMut: borrowing mutably
    can change the environment because it mutably borrows values.
    
  * Fn: borrow immutably
    borrows values from the environment immutably.

Define a struct field with Fn type:

```
struct Cacher<T>
where
    T: Fn(u32) -> u32,
{
    calculation: T,
    value: Option<u32>,
}
```

Compiler would infer the type of capture value automatically. See this link
for more example:
https://doc.rust-lang.org/rust-by-example/fn/closures/capture.html.

6.2 Iterator
================================================================================

https://www.twle.cn/c/yufei/rust/rust-basic-iterator.html

7. Smart Pointer
================================================================================

7.1 Box<>
================================================================================

let b = Box::new(5);

7.2 Deref trait
================================================================================

implement * operation for customized Box.

7.3 Drop trait
================================================================================

8. Project Management
================================================================================

8.1 Packages & Crates
================================================================================

A crate is a binary or library. The crate root is a source file that the Rust
compiler starts from and makes up the root module of your crate.

A package is one or more crates that provide a set of functionality. A package
contains a Cargo.toml file that describes how to build those crates.

8.2 Modules
================================================================================

Modules let us organize code within a crate into groups for readability and
easy reuse

8.3 Workspace
================================================================================


8.4 Dependency
================================================================================
Reference https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html

[dependencies]
name = "version"

8.4.1 specify the version
================================================================================
^1.2.3  :=  >=1.2.3, <2.0.0
^1.2    :=  >=1.2.0, <2.0.0
^1      :=  >=1.0.0, <2.0.0
^0.2.3  :=  >=0.2.3, <0.3.0
^0.2    :=  >=0.2.0, <0.3.0
^0.0.3  :=  >=0.0.3, <0.0.4
^0.0    :=  >=0.0.0, <0.1.0
^0      :=  >=0.0.0, <1.0.0

~1.2.3  := >=1.2.3, <1.3.0
~1.2    := >=1.2.0, <1.3.0
~1      := >=1.0.0, <2.0.0

*     := >=0.0.0
1.*   := >=1.0.0, <2.0.0
1.2.* := >=1.2.0, <1.3.0

8.4.2 specify the registry
================================================================================

[dependencies]
some-crate = { version = "1.0", registry = "my-registry" }

8.4.3 dependency from git
================================================================================

[dependencies]
rand = { git = "https://github.com/rust-lang-nursery/rand" }

[dependencies]
rand = { git = "https://github.com/rust-lang-nursery/rand", branch = "next" }

Note:

To access a private git repo, you may need to configure git authentication.
https://doc.rust-lang.org/cargo/appendix/git-authentication.html

8.4.4 local dependency
================================================================================

[dependencies]
hello_utils = { path = "hello_utils" }

[dependencies]
hello_utils = { path = "hello_utils", version = "0.1.0" }

8.4.4 platform specific dependency
================================================================================

[target.'cfg(windows)'.dependencies]
winhttp = "0.4.0"

[target.'cfg(unix)'.dependencies]
openssl = "1.0.1"

[target.'cfg(target_arch = "x86")'.dependencies]
native = { path = "native/i686" }

[target.'cfg(target_arch = "x86_64")'.dependencies]
native = { path = "native/x86_64" }

8.4.5 feature specific dependency
================================================================================

[dependencies]
foo = { version = "1.0", optional = true }
bar = { version = "1.0", optional = true }

[features]
fancy-feature = ["foo", "bar"]

8.4.6 development dependency
================================================================================

[dev-dependencies]
tempdir = "0.3"

[target.'cfg(unix)'.dev-dependencies]
mio = "0.0.1"

8.4.7 choose feature
================================================================================

[dependencies.awesome]
version = "1.3.5"
default-features = false # do not include the default features, and optionally
                         # cherry-pick individual features
features = ["secure-password", "civet"]

8.5 feature
================================================================================
Reference: https://doc.rust-lang.org/cargo/reference/features.html

8.5.1 definition
================================================================================

Define two features: tastes, cook. The first one is the default feature, and
the second one it optional.

[features]

default = ["tastes"]

tastes = []
cook = []

8.5.2 usage
================================================================================

A crate depends on the restaurant, and also depends on the optional feature:
cook.

[dependencies.restaurant]
path = "../restaurant"
features = ["cook"]

8.5.3 conditional compilation
================================================================================

When we need to build an optional feature, we can specify the feature in
command line:

cargo build --features "feature_name"

8.6 registry
================================================================================
https://doc.rust-lang.org/cargo/reference/registries.html

Add a registry in .cargo/config

[registries]
my-registry = { index = "https://my-intranet:8080/git/index" }

Use is in Cargo.toml

# Sample Cargo.toml
[package]
name = "my-project"
version = "0.1.0"

[dependencies]
other-crate = { version = "1.0", registry = "my-registry" }

